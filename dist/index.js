var we={create(e){let n=e.sourceCode||e.getSourceCode(),I=e.options[0]||{},v=I.maxItems!==void 0?I.maxItems:3;return{ArrayExpression(x){let{elements:r}=x;if(r.length===0)return;if(x.parent&&x.parent.type==="CallExpression"&&x.parent.callee&&x.parent.callee.type==="Identifier"&&/^use[A-Z]/.test(x.parent.callee.name)){let l=x.parent.arguments;if(l[l.length-1]===x)return}if(r.some(l=>l?l.type==="SpreadElement"||l.type==="ObjectExpression"||l.type==="ArrayExpression"||l.type==="ArrowFunctionExpression"||l.type==="FunctionExpression":!1))return;let i=n.getFirstToken(x),s=n.getLastToken(x);if(!i||!s)return;let c=r[0],o=r[r.length-1];if(!c||!o)return;if(x.parent&&x.parent.type==="Property"){let l=n.getTokenBefore(x);l&&l.value===":"&&i.loc.start.line!==l.loc.end.line&&e.report({fix:a=>a.replaceTextRange([l.range[1],i.range[0]]," "),message:"Array should start on same line as property key",node:i})}let t="";x.parent&&x.parent.type==="Property"?t=n.lines[x.parent.loc.start.line-1].match(/^\s*/)[0]:t=n.lines[x.loc.start.line-1].match(/^\s*/)[0];let h=t+"    ";if(r.length<=v){if(!(x.loc.start.line!==x.loc.end.line)){let T=n.text.slice(i.range[1],c.range[0]),y=n.text.slice(o.range[1],s.range[0]),b=T.length>0,m=y.includes(" ");if(b||m){let k=r.filter(A=>A!==null).map(A=>n.getText(A)).join(", ");e.report({fix:A=>A.replaceText(x,`[${k}]`),message:"No spaces inside array brackets",node:x})}return}let u=`[${r.filter(T=>T!==null).map(T=>n.getText(T)).join(", ")}]`;u.length<=100&&e.report({fix:T=>T.replaceText(x,u),message:`Array with \u2264${v} simple items should be single line: [a, b, c]. Multi-line only for >${v} items or complex values`,node:x});return}c.loc.start.line>i.loc.end.line+1?e.report({fix:l=>l.replaceTextRange([i.range[1],c.range[0]],`
`+h),message:"No empty line after opening bracket",node:c}):i.loc.end.line===c.loc.start.line&&e.report({fix:l=>l.replaceTextRange([i.range[1],c.range[0]],`
`+h),message:"First array item should be on its own line",node:c});for(let l=0;l<r.length-1;l+=1){let a=r[l],u=r[l+1];if(!a||!u)continue;let T=n.getTokenAfter(a,y=>y.value===",");a.loc.end.line===u.loc.start.line?T&&e.report({fix:y=>y.replaceTextRange([T.range[1],u.range[0]],`
`+h),message:"Each array item should be on its own line",node:u}):u.loc.start.line>a.loc.end.line+1&&T&&e.report({fix:y=>y.replaceTextRange([T.range[1],u.range[0]],`
`+h),message:"No empty lines between array items",node:u})}let p=n.getTokenBefore(s);if(s.loc.start.line>o.loc.end.line+1){let l=p&&p.value===",";e.report({fix:a=>l?a.replaceTextRange([p.range[1],s.range[0]],`
`+t):a.replaceTextRange([o.range[1],s.range[0]],`,
`+t),message:"No empty line before closing bracket",node:s})}else if(s.loc.start.line===o.loc.end.line){let l=p&&p.value===",";e.report({fix:a=>l?a.replaceTextRange([p.range[1],s.range[0]],`
`+t):a.replaceTextRange([o.range[1],s.range[0]],`,
`+t),message:"Closing bracket should be on its own line",node:s})}}}},meta:{docs:{description:"Enforce array formatting based on item count (default: \u22643 on one line, >3 each on new line)"},fixable:"code",schema:[{additionalProperties:!1,properties:{maxItems:{default:3,description:"Maximum items to keep on single line (default: 3)",minimum:1,type:"integer"}},type:"object"}],type:"layout"}},ve={create(e){let n=e.sourceCode||e.getSourceCode(),I=["map","filter","find","findIndex","findLast","findLastIndex","some","every","forEach","reduce","reduceRight","flatMap","sort","toSorted"],v=(x,r)=>{if(x.type!=="ObjectPattern")return;let d=x.properties.filter(p=>p.type==="Property");if(d.length<2)return;let i=d[0],s=d[d.length-1],c=n.getLastToken(x),t=n.lines[r.loc.start.line-1].match(/^\s*/)[0],h=t+"        ";if(i.loc.start.line===s.loc.end.line){e.report({fix(p){let l=n.getFirstToken(x),a=d.map(u=>h+n.getText(u)).join(`,
`);return p.replaceTextRange([l.range[0],c.range[1]],`{
${a},
${t}    }`)},message:"Destructured properties in array callback should each be on their own line when there are 2 or more properties",node:x});return}c.loc.start.line===s.loc.end.line&&e.report({fix(p){let l=n.getTokenBefore(c);return l.value===","?p.replaceTextRange([l.range[1],c.range[0]],`
`+t+"    "):p.replaceTextRange([s.range[1],c.range[0]],`,
`+t+"    ")},message:"Closing brace should be on its own line in multiline destructuring",node:c})};return{CallExpression(x){if(x.callee.type!=="MemberExpression")return;let r=x.callee.property&&x.callee.property.name;if(!I.includes(r))return;let d=x.arguments[0];d&&(d.type==="ArrowFunctionExpression"||d.type==="FunctionExpression")&&d.params.forEach(i=>{v(i,x)})}}},meta:{docs:{description:"Enforce multiline destructuring in array method callbacks (map, filter, find, etc.) when there are 2+ properties"},fixable:"code",schema:[],type:"layout"}},Ce={create(e){let n=e.sourceCode||e.getSourceCode();return{ArrayExpression(I){let v=I.elements;if(v.length===0||v.filter(c=>c&&c.type==="ObjectExpression").length===0||I.loc.start.line===I.loc.end.line)return;let r=n.getFirstToken(I),d=v[0];if(d&&d.type==="ObjectExpression"&&r.loc.end.line===d.loc.start.line){let c=n.getFirstToken(d),o=" ".repeat(r.loc.start.column+4);e.report({fix:t=>t.replaceTextRange([r.range[1],c.range[0]],`
`+o),message:"First object in array should start on a new line",node:d})}let i=n.getLastToken(I),s=v[v.length-1];if(s&&s.type==="ObjectExpression"){let c=n.getLastToken(s),o=n.getTokenAfter(c),t=o;if(o&&o.value===","&&(t=n.getTokenAfter(o)),c.loc.end.line===i.loc.start.line){let h=" ".repeat(r.loc.start.column);e.report({fix:p=>n.text.slice(s.range[1],i.range[0]).includes(",")?p.replaceTextRange([s.range[1],i.range[0]],`,
`+h):p.replaceTextRange([s.range[1],i.range[0]],`,
`+h),message:"Closing bracket should be on its own line after array of objects",node:i})}}for(let c=1;c<v.length;c++){let o=v[c-1],t=v[c];if(!t||t.type!=="ObjectExpression"||!o)continue;let h=n.getTokenAfter(o);if(!(!h||h.value!==",")&&h.loc.end.line===t.loc.start.line){let p=" ".repeat(r.loc.start.column+4),l=n.getFirstToken(t);e.report({fix:a=>a.replaceTextRange([h.range[1],l.range[0]],`
`+p),message:"Each object in array should start on a new line",node:t})}}}}},meta:{docs:{description:"Enforce array of objects to have each object on a new line"},fixable:"code",schema:[],type:"layout"}};var Ae={create(e){let n=e.sourceCode||e.getSourceCode(),I=x=>{let r=x.parent,d=0,i=15,s=!1,c=!1;for(;r&&d<i;){if(r.type==="JSXExpressionContainer"){let o=r.parent;if(o&&o.type==="JSXAttribute")return!0}if(r.type==="Property"&&r.key&&r.key.type==="Identifier"){let o=r.key.name;(o==="cell"||o==="header")&&(s=!0)}if(r.type==="ArrayExpression"&&(c=!0),s&&c)return!0;if(r.type==="Property"||r.type==="ObjectExpression"||r.type==="ArrayExpression"||r.type==="CallExpression"||r.type==="ArrowFunctionExpression"){r=r.parent,d+=1;continue}break}return!1};return{ArrowFunctionExpression:x=>{if(!I(x)||x.body.type==="BlockStatement")return;let r=x.body;if(r.type==="ObjectExpression")return;let d=n.getTokenBefore(r,o=>o.value==="=>");if(!d||r.loc.start.line===d.loc.start.line)return;let i=n.getTokenAfter(d);if(i&&i.value==="("||!n.getText().slice(d.range[1],r.range[0]).includes(`
`))return;if(r.type==="ConditionalExpression"||r.loc.start.line!==r.loc.end.line){let o=n.getFirstToken(r);e.report({fix:t=>t.replaceTextRange([d.range[1],o.range[0]]," "),message:"Arrow function body should start on same line as =>",node:r});return}let c=n.getText(r);e.report({fix:o=>o.replaceTextRange([d.range[1],r.range[1]],` ${c}`),message:"Arrow function body should start on same line as =>",node:r})}}},meta:{docs:{description:"Enforce parentheses for arrow functions in JSX props with multiline expressions (preserves implicit return)"},fixable:"code",schema:[],type:"layout"}},$e={create(e){let n=e.sourceCode||e.getSourceCode(),I=x=>{if(x.type!=="JSXElement"&&x.type!=="JSXFragment"||x.type==="JSXElement"&&x.openingElement.attributes.length>1)return!1;if(x.type==="JSXElement")for(let d of x.openingElement.attributes){if(d.type==="JSXSpreadAttribute")return!1;if(d.value&&d.value.type==="JSXExpressionContainer"){let i=d.value.expression;if(i.type==="ObjectExpression"||i.type==="ArrayExpression"||i.type==="ArrowFunctionExpression"||i.type==="FunctionExpression")return!1}}let r=x.children.filter(d=>d.type==="JSXText"?d.value.trim().length>0:!0);if(r.length===0)return!0;if(r.length===1){let d=r[0];if(d.type==="JSXText")return!0;if(d.type==="JSXExpressionContainer"){let i=d.expression;if(i.type==="Identifier"||i.type==="MemberExpression"||i.type==="Literal")return!0}}return!1},v=x=>n.getText(x).replace(/>\s+</g,"><").replace(/>\s+\{/g,">{").replace(/\}\s+</g,"}<").replace(/\s+$/g,"").replace(/^\s+/g,"");return{ArrowFunctionExpression(x){let{body:r}=x,d=n.getTokenBefore(r);if(d&&d.value==="=>"&&r.range[0]===d.range[1]&&e.report({fix:p=>p.insertTextBefore(r," "),message:"Missing space after arrow (=>)",node:r}),r.type!=="JSXElement"&&r.type!=="JSXFragment"||d.loc.end.line===r.loc.start.line||!I(r))return;let i=v(r);if(d.loc.start.column+3+i.length>120)return;let o=n.getTokenBefore(r),t=n.getTokenAfter(r);o&&o.value==="("&&t&&t.value===")"?e.report({fix:p=>p.replaceTextRange([o.range[0],t.range[1]],i),message:"Simple JSX should be on same line as arrow function without parentheses",node:r}):e.report({fix:p=>{let l=n.getTokenBefore(r);return p.replaceTextRange([l.range[1],r.range[1]]," "+i)},message:"Simple JSX should be on same line as arrow function",node:r})}}},meta:{docs:{description:"Simplify arrow functions returning simple JSX to single line"},fixable:"code",schema:[],type:"layout"}},Le={create(e){let n=e.sourceCode||e.getSourceCode(),I=s=>{let c=s.parent;return!!(c&&c.type==="JSXExpressionContainer"&&(c=c.parent,c&&c.type==="JSXAttribute"))},v=s=>{if(s.type!=="CallExpression")return!1;let{arguments:c,callee:o}=s;if(o.type!=="Identifier"&&o.type!=="MemberExpression")return!1;if(c.length===0)return!0;if(c.length===1){let t=c[0];if(t.type==="Identifier"||t.type==="Literal")return!0;if(t.type==="CallExpression")return v(t);if(t.type==="MemberExpression")return!0}return!1},x=s=>{if(s.type!=="CallExpression")return n.getText(s);let c=n.getText(s.callee),o=s.arguments.map(t=>t.type==="CallExpression"?x(t):n.getText(t)).join(", ");return`${c}(${o})`},r=s=>s?s.type==="Identifier"||s.type==="Literal"||s.type==="ThisExpression"?!0:s.type==="MemberExpression"?r(s.object)&&r(s.property):s.type==="UnaryExpression"?r(s.argument):s.type==="CallExpression"?s.arguments.length>2?!1:s.arguments.every(r):s.type==="ObjectExpression"||s.type==="ArrayExpression":!1;return{ArrowFunctionExpression:s=>{if(s.body.type!=="BlockStatement")return;let{body:c}=s.body;if(c.length!==1)return;let o=c[0];if(o.type==="ExpressionStatement"){let t=o.expression;if(t.loc.start.line===t.loc.end.line){let h=n.getText(t);e.report({fix:p=>p.replaceText(s.body,h),message:"Arrow function with single statement should use expression body: () => expression instead of () => { expression }",node:s.body});return}if(v(t)){let h=x(t);e.report({fix:p=>p.replaceText(s.body,h),message:"Arrow function with simple nested call should be simplified to one line",node:s.body});return}if(t.type==="CallExpression"){let h=n.getText(t);e.report({fix:p=>p.replaceText(s.body,h),message:"Arrow function with single statement should use expression body",node:s.body})}return}if(o.type==="ReturnStatement"){let t=o.argument;if(!t)return;let h=n.getText(t);if(t.type==="ObjectExpression"){e.report({fix:p=>p.replaceText(s.body,`(${h})`),message:"Arrow function with single return should use expression body: () => value instead of () => { return value }",node:s.body});return}if(r(t)){e.report({fix:p=>p.replaceText(s.body,h),message:"Arrow function with single return should use expression body: () => value instead of () => { return value }",node:s.body});return}e.report({fix:p=>p.replaceText(s.body,h),message:"Arrow function with single return should use expression body: () => value instead of () => { return value }",node:s.body})}},JSXExpressionContainer:s=>{let c=s.expression;if(c.type!=="ArrowFunctionExpression"||c.body.type==="BlockStatement"||c.body.type!=="CallExpression")return;let o=c.body,t=o.arguments[o.arguments.length-1];if(!t||t.type!=="ObjectExpression"&&t.type!=="ArrayExpression"||t.loc.start.line===t.loc.end.line)return;let h=n.getLastToken(o),p=n.getLastToken(s);!h||!p||h.value!==")"||p.value!=="}"||h.loc.end.line!==p.loc.start.line&&e.report({fix:l=>l.replaceTextRange([h.range[1],p.range[0]],""),message:"JSX expression closing brace should be on same line as function call: )}",node:p})}}},meta:{docs:{description:"Simplify arrow functions with single return to expression body: () => { return x } becomes () => x"},fixable:"code",schema:[],type:"layout"}},Ie={create(e){let n=e.sourceCode||e.getSourceCode();return{ArrowFunctionExpression(I){let{body:v}=I;if(v.type!=="ArrowFunctionExpression")return;let x=n.getTokenBefore(v,d=>d.value==="=>");if(!x)return;let r=n.getFirstToken(v);r&&x.loc.end.line!==r.loc.start.line&&e.report({fix:d=>d.replaceTextRange([x.range[1],r.range[0]]," "),message:"Curried arrow function should start on the same line as =>",node:v})}}},meta:{docs:{description:"Enforce curried arrow function to start on same line as =>"},fixable:"code",schema:[],type:"layout"}};var Te={absolute:10,block:10,contents:10,fixed:10,flex:10,grid:10,hidden:10,inline:10,"inline-block":10,"inline-flex":10,"inline-grid":10,relative:10,static:10,sticky:10,"bottom-":20,"inset-":20,"left-":20,"right-":20,"top-":20,"z-":25,"basis-":30,"flex-":30,"grid-cols-":30,"grid-rows-":30,"content-":40,"items-":40,"justify-":40,"place-":40,"self-":40,"col-":45,grow:45,"order-":45,"row-":45,shrink:45,"gap-":50,"-m-":60,"-mx-":60,"-my-":60,"m-":60,"mb-":60,"ml-":60,"mr-":60,"mt-":60,"mx-":60,"my-":60,"p-":70,"pb-":70,"pl-":70,"pr-":70,"pt-":70,"px-":70,"py-":70,"h-":80,"max-h-":80,"max-w-":80,"min-h-":80,"min-w-":80,"size-":80,"w-":80,"align-":90,antialiased:90,"break-":90,capitalize:90,"decoration-":90,"font-":90,"hyphens-":90,italic:90,"leading-":90,"line-clamp-":90,"list-":90,lowercase:90,"normal-case":90,"not-italic":90,ordinal:90,"text-":90,"tracking-":90,truncate:90,underline:90,uppercase:90,"whitespace-":90,"bg-":100,border:110,"border-":110,"divide-":110,"outline-":110,"ring-":110,rounded:110,"rounded-":110,blur:120,"blur-":120,"brightness-":120,"contrast-":120,"drop-shadow":120,grayscale:120,"hue-rotate-":120,invert:120,"opacity-":120,"saturate-":120,sepia:120,shadow:120,"shadow-":120,"animate-":130,"delay-":130,"duration-":130,"ease-":130,transition:130,"transition-":130,"-rotate-":140,"-scale-":140,"-skew-":140,"-translate-":140,"origin-":140,"rotate-":140,"scale-":140,"skew-":140,transform:140,"translate-":140,"accent-":150,"appearance-":150,"caret-":150,"cursor-":150,"pointer-events-":150,resize:150,"scroll-":150,"select-":150,"snap-":150,"touch-":150,"will-change-":150,"fill-":160,"stroke-":160,"sr-only":170},Gt=[/^(flex|grid|block|inline|hidden|absolute|relative|fixed|sticky)$/,/^(items|justify|content|self|place)-(start|end|center|between|around|evenly|stretch|baseline)$/,/^(flex|grid)-(row|col|wrap|nowrap|grow|shrink)/,/^(col|row)-span-/,/^gap-/,/^order-/,/^-?[mp][xytblr]?-\d/,/^-?[mp][xytblr]?-\[/,/^[wh]-/,/^(min|max)-[wh]-/,/^size-/,/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/,/^text-(left|center|right|justify)$/,/^text-\w+-\d{2,3}$/,/^font-(thin|extralight|light|normal|medium|semibold|bold|extrabold|black)$/,/^font-(sans|serif|mono)$/,/^leading-/,/^tracking-/,/^(uppercase|lowercase|capitalize|normal-case)$/,/^(truncate|line-clamp-)/,/^(bg|text|border|ring|divide|outline|fill|stroke)-(transparent|current|inherit)$/,/^(bg|text|border|ring|divide|outline|fill|stroke)-\w+-\d{2,3}$/,/^(bg|text|border|ring|divide|outline|fill|stroke)-(white|black)$/,/^rounded(-|$)/,/^border(-|$)/,/^ring(-|$)/,/^outline(-|$)/,/^shadow(-|$)/,/^opacity-/,/^blur(-|$)/,/^transition(-|$)/,/^duration-/,/^ease-/,/^delay-/,/^animate-/,/^-?(rotate|scale|skew|translate)-/,/^origin-/,/^transform$/,/^(grayscale|sepia|invert|brightness|contrast|saturate|hue-rotate)(-|$)/,/^cursor-/,/^select-/,/^pointer-events-/,/^(sm|md|lg|xl|2xl):/,/^(hover|focus|active|disabled|group-hover):/,/^(dark|light):/],Yt=2,be=3,ke=80,de=e=>{if(!e||typeof e!="string")return!1;let n=e.trim().split(/\s+/).filter(Boolean);if(n.length===0)return!1;let I=0;for(let v of n){for(let x of Gt)if(x.test(v)){I+=1;break}for(let x of Object.keys(Te))if(v===x.replace("-","")||v.startsWith(x)){I+=1;break}}return I>=Yt||n.length>0&&I/n.length>.5},Qt=e=>/class/i.test(e),ne=(e,n)=>Qt(e||"")||de(n),me=e=>{if(/^(sm|md|lg|xl|2xl):/.test(e))return 200;if(/^(hover|focus|active|disabled|visited|first|last|odd|even|group-):/.test(e))return 210;if(/^dark:/.test(e))return 220;if(Te[e]!==void 0)return Te[e];for(let[n,I]of Object.entries(Te))if(n.endsWith("-")&&e.startsWith(n))return I;return 180},pe=e=>{if(!e||typeof e!="string")return e;let n=e.trim().split(/\s+/).filter(Boolean);return n.length<=1?e:[...n].sort((v,x)=>{let r=me(v),d=me(x);return r!==d?r-d:v.localeCompare(x)}).join(" ")},ye=e=>{if(!e||typeof e!="string")return!1;let n=e.trim().split(/\s+/).filter(Boolean).join(" "),I=pe(n);return n!==I};var Pe={create(e){let n=e.sourceCode||e.getSourceCode(),I=e.options[0]||{},v=I.minArgs!==void 0?I.minArgs:2,x=I.skipHooks!==void 0?I.skipHooks:!0,r=I.skipSingleArg!==void 0?I.skipSingleArg:!0,d=["useEffect","useCallback","useMemo","useLayoutEffect","useImperativeHandle","useReducer","useRef","useState","useContext","useDebugValue","useDeferredValue","useTransition","useId","useSyncExternalStore","useInsertionEffect"],i=o=>o.callee.type==="Identifier"?d.includes(o.callee.name):!1,s=o=>o.some(t=>t.loc.start.line!==t.loc.end.line);return{CallExpression:o=>{if(x&&i(o))return;let t=o.arguments;if(t.length===0)return;if(r&&t.length===1){if(t[0].type==="ObjectExpression"||t[0].type==="ArrayExpression"||t[0].type==="ArrowFunctionExpression"||t[0].type==="FunctionExpression")return;if(t[0].type==="TemplateLiteral"){let k=n.getTokenAfter(o.callee,w=>w.value==="("),A=n.getLastToken(o);if(k&&A&&k.loc.end.line!==t[0].loc.start.line){let w=n.getText(t[0]),E=o.typeArguments||o.typeParameters,L=n.getText(o.callee);E&&(L+=n.getText(E)),e.report({fix:C=>C.replaceText(o,`${L}(${w})`),message:"Single template literal argument should start on same line as function call",node:o})}else if(k&&A){let w=n.getTokenAfter(t[0]),E=[];if(w&&w.value===","&&E.push(L=>L.remove(w)),A.loc.start.line!==t[0].loc.end.line){let L=w&&w.value===","?w:t[0];E.push(C=>C.replaceTextRange([L.range[1],A.range[0]],""))}E.length>0&&e.report({fix:L=>E.map(C=>C(L)),message:"Single template literal argument should not have trailing comma or closing paren on separate line",node:o})}return}}let h=t.length>=v,p=s(t);if(!h&&!p)return;let l=n.getTokenAfter(o.callee,k=>k.value==="("),a=n.getLastToken(o);if(!l||!a||a.value!==")")return;let u=t[0],T=t[t.length-1],b=n.lines[o.loc.start.line-1].match(/^\s*/)[0],m=b+"    ";l.loc.end.line===u.loc.start.line&&e.report({fix:k=>k.replaceTextRange([l.range[1],u.range[0]],`
`+m),message:"With multiple arguments, first argument should be on its own line: fn(\\n    arg1,\\n    arg2,\\n)",node:u});for(let k=0;k<t.length-1;k+=1){let A=t[k],w=t[k+1];if(A.loc.end.line===w.loc.start.line){let E=n.getTokenAfter(A,L=>L.value===",");E&&e.report({fix:L=>L.replaceTextRange([E.range[1],w.range[0]],`
`+m),message:"Each argument should be on its own line",node:w})}}if(a.loc.start.line===T.loc.end.line){let k=n.getTokenBefore(a),A=k&&k.value===",";e.report({fix:w=>A?w.replaceTextRange([k.range[1],a.range[0]],`
`+b):w.replaceTextRange([T.range[1],a.range[0]],`,
`+b),message:"Closing parenthesis should be on its own line",node:a})}}}},meta:{docs:{description:"Enforce function arguments formatting: each argument on its own line when >= minArgs (default: 2) or any argument is multiline"},fixable:"code",schema:[{additionalProperties:!1,properties:{minArgs:{default:2,description:"Minimum arguments to enforce multiline formatting (default: 2)",minimum:1,type:"integer"},skipHooks:{default:!0,description:"Skip React hooks (default: true)",type:"boolean"},skipSingleArg:{default:!0,description:"Skip single argument patterns like objects, arrays, callbacks (default: true)",type:"boolean"}},type:"object"}],type:"layout"}},Re={create(e){let n=e.sourceCode||e.getSourceCode(),I=(x,r)=>{let d=n.getLastToken(r),i=n.getTokenAfter(r);if(!i||i.value!==")")return;let s=n.getTokenAfter(i);s&&s.value===","&&(s=n.getTokenAfter(s));let c=s;if(!c||c.value!==")")return;if(d.loc.end.line!==i.loc.start.line){e.report({fix:t=>t.replaceTextRange([d.range[1],i.range[0]],""),message:"Closing brace and parenthesis should be on the same line: })",node:i});return}if(i.loc.end.line!==c.loc.start.line){e.report({fix:t=>t.replaceTextRange([i.range[1],c.range[0]],""),message:"Closing parentheses should be on the same line: ))",node:c});return}let o=n.getTokenAfter(c);o&&o.value==="||"&&c.loc.end.line!==o.loc.start.line&&e.report({fix:t=>t.replaceTextRange([c.range[1],o.range[0]]," "),message:"Logical operator || should be on the same line as closing ))",node:o})},v=x=>{let{arguments:r}=x;if(r.length!==1)return;let d=r[0],i=null;if(d.type==="ObjectExpression"||d.type==="ArrayExpression")i=n.getLastToken(d);else if(d.type==="ArrowFunctionExpression"){let t=d.body;if(t.type==="TSAsExpression"&&t.typeAnnotation&&t.typeAnnotation.type==="TSTypeLiteral")i=n.getLastToken(t.typeAnnotation);else if(t.type==="ObjectExpression"||t.type==="ArrayExpression")i=n.getLastToken(t);else{let h=n.getLastToken(d),p=n.getLastToken(x);if(!p||p.value!==")")return;let l=n.getTokenAfter(h);(l&&l.value===","?l:h).loc.end.line!==p.loc.start.line&&e.report({fix:T=>T.replaceTextRange([h.range[1],p.range[0]],""),message:"Closing parenthesis should be on same line as arrow function body",node:p});return}}if(!i||i.value!=="}"&&i.value!=="]")return;let s=n.getLastToken(x);if(!s||s.value!==")")return;let c=n.getTokenAfter(i),o=i;c&&c.value===","&&(o=c),o.loc.end.line!==s.loc.start.line&&e.report({fix:t=>t.replaceTextRange([o.range[1],s.range[0]],""),message:"Closing parenthesis should be on same line as closing brace: });",node:s})};return{CallExpression(x){let{callee:r,arguments:d}=x;if(v(x),d.length!==1)return;let i=d[0];if(!(i.type!=="ArrowFunctionExpression"||i.body.type!=="ObjectExpression")){if(r.type==="CallExpression"){I(x,i.body);return}r.type==="MemberExpression"&&I(x,i.body)}}}},meta:{docs:{description:"Enforce nested function call closing brackets on same line: }));"},fixable:"code",schema:[],type:"layout"}},Fe={create(e){let n=e.sourceCode||e.getSourceCode(),I=i=>["Literal","Identifier","MemberExpression","TemplateLiteral"].includes(i.type),v=i=>i.loc.start.line===i.loc.end.line,x=i=>i.type==="ObjectExpression"&&i.properties.length===1,r=i=>{let s=i.properties[0];if(s.type==="SpreadElement")return n.getText(i);let c=n.getText(s.key),o=n.getText(s.value);return`{ ${c}: ${o} }`};return{CallExpression:i=>{let s=i.arguments;if(s.length===0)return;let c=n.getTokenAfter(i.callee,p=>p.value==="("),o=n.getLastToken(i);if(!c||!o||o.value!==")")return;let t=s[0],h=s[s.length-1];if(s.length===1&&(I(t)||x(t))&&v(t)&&t.loc.start.line!==c.loc.end.line){let p=x(t)?r(t):n.getText(t);e.report({fix:l=>l.replaceTextRange([c.range[1],o.range[0]],p),message:"Single simple argument should be on the same line as function call",node:t});return}t.loc.start.line-c.loc.end.line>1&&e.report({fix:p=>p.replaceTextRange([c.range[1],t.range[0]],`
`+" ".repeat(t.loc.start.column)),message:"No empty line after opening parenthesis in function call",node:t}),o.loc.start.line-h.loc.end.line>1&&e.report({fix:p=>p.replaceTextRange([h.range[1],o.range[0]],`
`+" ".repeat(o.loc.start.column)),message:"No empty line before closing parenthesis in function call",node:h});for(let p=0;p<s.length-1;p+=1){let l=s[p],a=s[p+1];if(a.loc.start.line-l.loc.end.line>1){let u=n.getTokenAfter(l,T=>T.value===",");e.report({fix:T=>T.replaceTextRange([u.range[1],a.range[0]],`
`+" ".repeat(a.loc.start.column)),message:"No empty line between function arguments",node:a})}}}}},meta:{docs:{description:"Disallow empty lines in function calls and enforce single simple argument on same line"},fixable:"whitespace",schema:[],type:"layout"}},Be={create(e){let n=e.sourceCode||e.getSourceCode();return{ArrowFunctionExpression:i=>{if(i.body.type==="BlockStatement"){let a=n.getTokenBefore(i.body,T=>T.value==="=>"),u=n.getFirstToken(i.body);a&&u&&a.loc.end.line!==u.loc.start.line&&e.report({fix:T=>T.replaceTextRange([a.range[1],u.range[0]]," "),message:"Opening brace should be on the same line as arrow",node:u})}if(i.body.type==="CallExpression"){let a=n.getTokenBefore(i.body,u=>u.value==="=>");if(a){let u=n.getTokenAfter(a);if(u&&u.value==="("){a.loc.end.line!==u.loc.start.line&&e.report({fix:y=>y.replaceTextRange([a.range[1],u.range[1]]," ("),message:"Opening parenthesis should be on the same line as arrow: => (",node:u});return}n.text.slice(a.range[1],i.body.range[0])!==" "&&e.report({fix:y=>y.replaceTextRange([a.range[1],i.body.range[0]]," "),message:"Expression body should be on the same line as arrow with single space",node:i.body})}}if(i.body.type==="ObjectExpression"){let a=n.getTokenBefore(i.body,u=>u.value==="=>");if(a){let u=n.getTokenAfter(a);if(u&&u.value==="("){if(a.loc.end.line!==u.loc.start.line){e.report({fix:y=>y.replaceTextRange([a.range[1],u.range[1]]," ("),message:"Parenthesized object should be on the same line as arrow: => (",node:u});return}let T=n.getFirstToken(i.body);u.loc.end.line!==T.loc.start.line&&e.report({fix:y=>y.replaceTextRange([u.range[1],T.range[1]],"{"),message:"Opening brace should be on the same line as opening paren: ({",node:T})}}}if(i.body.type==="TSAsExpression"||i.body.type==="Identifier"||i.body.type==="MemberExpression"){let a=n.getTokenBefore(i.body,u=>u.value==="=>");if(a){let u=n.getTokenAfter(a);u&&u.value!=="("&&n.text.slice(a.range[1],i.body.range[0])!==" "&&e.report({fix:y=>y.replaceTextRange([a.range[1],i.body.range[0]]," "),message:"Expression body should be on the same line as arrow with single space",node:i.body})}}let s=n.getFirstToken(i,a=>a.value==="=>");if(s){let a=n.getTokenBefore(s);a&&n.text.slice(a.range[1],s.range[0])!==" "&&e.report({fix:T=>T.replaceTextRange([a.range[1],s.range[0]]," "),message:"Arrow function should have space before =>",node:s})}let c=i.params;if(c.length!==1)return;let o=c[0];if(o.type!=="ObjectPattern"||o.properties.length<2)return;let t=n.getTokenBefore(o);if(!t||t.value!=="(")return;let h=n.getFirstToken(o);t.loc.end.line!==h.loc.start.line&&e.report({fix:a=>a.replaceTextRange([t.range[1],h.range[1]],"{"),message:"Opening parenthesis and brace should be on the same line for destructured param",node:h});let p=n.getLastToken(o),l=n.getTokenAfter(o);l&&l.value===","&&(l=n.getTokenAfter(l)),l&&l.value===")"&&p.loc.end.line!==l.loc.start.line&&e.report({fix:a=>a.replaceTextRange([p.range[1],l.range[0]],""),message:"Closing brace and parenthesis should be on the same line for destructured param",node:l})},CallExpression:i=>{let{callee:s}=i,c=n.getLastToken(s),o=i.typeArguments||i.typeParameters,t;if(o?t=n.getTokenAfter(o):t=n.getTokenAfter(s),!t||t.value!=="("){let a=n.getTokenAfter(s);for(;a&&a.range[0]<i.range[1];){if(a.value==="("){t=a;break}a=n.getTokenAfter(a)}}if(!t||t.value!=="(")return;if(c.loc.end.line!==t.loc.start.line){if(o&&o.loc.start.line!==o.loc.end.line)return;let a="";o&&(a=n.getText(o)),a+="(",e.report({fix:u=>u.replaceTextRange([c.range[1],t.range[1]],a),message:"Opening parenthesis should be on the same line as function name",node:t});return}let h=i.arguments;if(h.length===0)return;let p=h[0],l=n.getTokenBefore(p);if(p.type==="ObjectExpression"&&p.properties.length>=1){let a=i.loc.start.line!==i.loc.end.line,u=h.length>1;if(a&&u)return;let T=n.getFirstToken(p);l.loc.end.line!==T.loc.start.line&&e.report({fix:m=>m.replaceTextRange([l.range[1],T.range[1]],"{"),message:"Opening parenthesis and brace should be on the same line",node:T});let y=n.getLastToken(p),b=n.getTokenAfter(p);b&&b.value===","&&(b=n.getTokenAfter(b)),b&&b.value===")"&&y.loc.end.line!==b.loc.start.line&&e.report({fix:m=>m.replaceTextRange([y.range[1],b.range[0]],""),message:"Closing brace and parenthesis should be on the same line",node:b});return}if(p.type==="ArrayExpression"&&h.length===1){let a=p.loc.start.line!==p.loc.end.line,u=n.getFirstToken(p);if(l.loc.end.line!==u.loc.start.line){e.report({fix:b=>b.replaceTextRange([l.range[1],u.range[0]],""),message:"Opening parenthesis and bracket should be on the same line: fn([",node:u});return}if(!a&&p.elements.length>0&&p.elements[0]&&p.elements[0].type==="ObjectExpression"){let b=p.elements[0],m=n.getFirstToken(b);u.loc.end.line!==m.loc.start.line&&e.report({fix:k=>k.replaceTextRange([u.range[1],m.range[1]],"{"),message:"Opening bracket and brace should be on the same line",node:m})}let T=n.getLastToken(p),y=n.getTokenAfter(p);y&&y.value===","&&(y=n.getTokenAfter(y)),y&&y.value===")"&&T.loc.end.line!==y.loc.start.line&&e.report({fix:b=>b.replaceTextRange([T.range[1],y.range[0]],""),message:"Closing bracket and parenthesis should be on the same line: ])",node:y});return}if(p.type==="CallExpression"&&h.length>1){if(l.loc.end.line===p.loc.start.line){let a=" ".repeat(l.loc.start.column+4);e.report({fix:u=>u.replaceTextRange([l.range[1],p.range[0]],`
`+a),message:"Function call argument should start on a new line when there are multiple arguments",node:p})}return}if(p.type==="ArrowFunctionExpression"){if(h.length>1)return;let a=p.params;if(a.length===0){l.loc.end.line!==p.loc.start.line&&e.report({fix:y=>y.replaceTextRange([l.range[1],p.range[0]],""),message:"Arrow function should start on the same line as opening parenthesis",node:p});return}let u=a[0],T=a[a.length-1];if(a.length===1&&u.type==="ObjectPattern"){let y=n.getTokenBefore(u);if(!y||y.value!=="(")return;if(l.loc.end.line!==y.loc.start.line){e.report({fix:w=>w.replaceTextRange([l.range[1],y.range[1]],"("),message:"Callback opening parenthesis should be on the same line as function call",node:y});return}let b=n.getFirstToken(u);if(y.loc.end.line!==b.loc.start.line){e.report({fix:w=>w.replaceTextRange([y.range[1],b.range[1]],"{"),message:"Opening parenthesis and brace should be on the same line for callback destructured param",node:b});return}let m=n.getTokenBefore(p.body),k=n.getTokenAfter(m),A=m.value==="=>"&&m.loc.end.line!==k.loc.start.line;if(u.properties.length>=2){let w=n.getLastToken(u);if(b.loc.start.line===w.loc.end.line&&A){let C=n.lines[l.loc.start.line-1].match(/^(\s*)/)[1],g=C+"    ",f=u.properties.map(S=>g+n.getText(S)).join(`,
`);e.report({fix:S=>[S.replaceTextRange([b.range[0],w.range[1]],`{
`+f+`
`+C+"}"),S.replaceTextRange([m.range[1],k.range[0]]," ")],message:"Destructured callback params with 2+ properties should each be on their own line",node:u});return}}A&&e.report({fix:w=>w.replaceTextRange([m.range[1],k.range[0]]," "),message:"Arrow function body should start on the same line as =>",node:k});return}if(a.length===1&&u.type==="Identifier"){let y=n.getTokenBefore(u);if(!y||y.value!=="(")return;if(l.loc.end.line!==y.loc.start.line){e.report({fix:b=>b.replaceTextRange([l.range[1],y.range[1]],"("),message:"Callback opening parenthesis should be on the same line as function call",node:y});return}y.loc.end.line!==u.loc.start.line&&e.report({fix:b=>b.replaceTextRange([y.range[1],u.range[0]],""),message:"Single callback param should be on the same line as opening parenthesis",node:u});return}if(a.length>=2){let y=n.getTokenBefore(u);if(!y||y.value!=="(")return;let b=y.loc.end.line!==u.loc.start.line,m=p.body,k=m&&m.loc.start.line!==m.loc.end.line;if(b||k)return;l.loc.end.line!==y.loc.start.line&&e.report({fix:A=>A.replaceTextRange([l.range[1],y.range[1]],"("),message:"Opening parentheses should be on the same line for callback params",node:y})}}},JSXExpressionContainer:i=>{let s=i.expression;if(s.type==="JSXEmptyExpression")return;let c=n.getFirstToken(i),o=n.getLastToken(i);if(s.type==="ObjectExpression"&&s.properties.length>=1){let p=n.getFirstToken(s);c.loc.end.line!==p.loc.start.line&&e.report({fix:a=>a.replaceTextRange([c.range[1],p.range[1]],"{"),message:"Opening braces should be on the same line for JSX object expression",node:p});let l=n.getLastToken(s);o.loc.start.line!==l.loc.end.line&&e.report({fix:a=>a.replaceTextRange([l.range[1],o.range[0]],""),message:"Closing braces should be on the same line for JSX object expression",node:o});return}if(s.type==="CallExpression"){c.loc.end.line!==s.loc.start.line&&e.report({fix:l=>l.replaceTextRange([c.range[1],s.range[0]],""),message:"Opening brace and expression should be on the same line",node:s}),s.loc.start.line===s.loc.end.line&&s.loc.end.line!==o.loc.start.line&&e.report({fix:l=>l.replaceTextRange([s.range[1],o.range[0]],""),message:"Closing brace should be on the same line as simple call expression",node:o});return}if(s.type==="TemplateLiteral"){if(s.expressions.every(l=>l.type==="Identifier"||l.type==="MemberExpression")){let l=s.quasis,a=s.expressions,u="`",T=[];for(let w=0;w<l.length;w+=1){let E=l[w].value.raw.replace(/\s*\n\s*/g," ").trim();E&&T.push(E),w<a.length&&T.push("${"+n.getText(a[w])+"}")}u="`"+T.join(" ")+"`";let y=i.parent;if(y&&y.type==="JSXAttribute"&&y.name&&y.name.name==="className"){let w=u.slice(1,-1),E=w.replace(/\$\{[^}]+\}/g,"").trim(),L=E.split(/\s+/).filter(Boolean),C=a.length,g=be,f=ke;if(L.length+C>g||w.length>f)return;if(a.length===0){let $=`"${E}"`,P=s.loc.start.line!==s.loc.end.line,R=c.loc.end.line!==s.loc.start.line;(P||R)&&e.report({fix:F=>F.replaceTextRange([c.range[0],o.range[1]],$),message:"Short className should use a string literal on a single line",node:s});return}}let m=s.loc.start.line!==s.loc.end.line,k=c.loc.end.line!==s.loc.start.line,A=s.loc.end.line!==o.loc.start.line;(m||k||A)&&u.length<=80&&e.report({fix:w=>w.replaceTextRange([c.range[1],o.range[0]],u),message:"Simple template literal should be on a single line",node:s})}return}let t=["Identifier","MemberExpression","Literal"],h=["ConditionalExpression","BinaryExpression","LogicalExpression","UnaryExpression"].includes(s.type)&&s.loc.start.line===s.loc.end.line;if(t.includes(s.type)||h){if(c.loc.end.line!==o.loc.start.line){let a=n.getText(s);e.report({fix:u=>u.replaceTextRange([c.range[1],o.range[0]],a),message:"Simple expression should be on single line in JSX attribute",node:s});return}let l=i.parent;if(l&&l.type==="JSXElement"){let a=l.children.filter(u=>!(u.type==="JSXText"&&/^\s*$/.test(u.value)));if(a.length===1&&a[0]===i){let u=l.openingElement,T=l.closingElement;if(T){let y=u.loc.end.line,b=T.loc.start.line;if(y!==b){let m=n.getText(u),k=n.getText(T),A=n.getText(i);m.length+A.length+k.length<=120&&e.report({fix:E=>E.replaceTextRange([u.range[1],T.range[0]],A),message:"JSX element with simple expression should be on single line",node:l})}}}}return}if(s.type==="ArrowFunctionExpression"){if(c.loc.end.line!==s.loc.start.line){e.report({fix:p=>p.replaceTextRange([c.range[1],s.range[0]],""),message:"Opening brace and arrow function should be on the same line in JSX attribute",node:s});return}if(s.body.type==="BlockStatement"){if(i.parent&&i.parent.type==="JSXAttribute"){let p=n.getLastToken(s.body);p&&o.loc.start.line!==p.loc.end.line&&e.report({fix:l=>l.replaceTextRange([p.range[1],o.range[0]],""),message:"Closing braces should be together for arrow function in JSX attribute",node:o})}return}if(i.parent&&i.parent.type==="JSXAttribute"){let p=s.loc.start.line===s.loc.end.line,l=c.loc.end.line!==s.loc.start.line,a=s.loc.end.line!==o.loc.start.line;if((l||a)&&p){let y=n.getText(s);e.report({fix:b=>b.replaceTextRange([c.range[1],o.range[0]],y),message:"Simple arrow function should be on single line in JSX attribute",node:s});return}if(s.body.loc.start.line===s.body.loc.end.line){let y=n.getTokenBefore(s.body,b=>b.value==="=>");if(y&&y.loc.end.line!==s.body.loc.start.line){let b=n.getText(s.body);e.report({fix:m=>m.replaceTextRange([y.range[1],o.range[0]]," "+b),message:"Simple arrow function expression should be on single line",node:s.body})}}}return}if(s.type==="JSXElement"||s.type==="JSXFragment"){let p=n.getTokenBefore(s);if(p&&p.value==="("){c.loc.end.line!==p.loc.start.line&&e.report({fix:a=>a.replaceTextRange([c.range[1],p.range[1]],"("),message:"Opening brace and parenthesis should be together for JSX expression",node:p});let l=n.getTokenAfter(s);l&&l.value===")"&&o.loc.start.line!==l.loc.end.line&&e.report({fix:a=>a.replaceTextRange([l.range[1],o.range[0]],""),message:"Closing parenthesis and brace should be together for JSX expression",node:o})}return}if(s.type==="LogicalExpression"){let p=b=>b.type==="LogicalExpression"?p(b.left)+p(b.right):1,l=p(s),a=n.getText(s),u=s.loc.start.line!==s.loc.end.line;if(l<=2&&a.length<=80){let b=a.replace(/\s*\n\s*/g," ");if(u||c.loc.end.line!==s.loc.start.line||s.loc.end.line!==o.loc.start.line){e.report({fix:k=>k.replaceTextRange([c.range[1],o.range[0]],b),message:"Simple logical expression should be on a single line",node:s});return}let m=i.parent;if(m&&m.type==="JSXElement"){let k=m.children.filter(A=>!(A.type==="JSXText"&&/^\s*$/.test(A.value)));if(k.length===1&&k[0]===i){let A=m.openingElement,w=m.closingElement;if(w){let E=A.loc.end.line,L=w.loc.start.line;if(E!==L){let C=n.getText(A),g=n.getText(w),f="{"+b+"}";C.length+f.length+g.length<=120&&e.report({fix:$=>$.replaceTextRange([A.range[1],w.range[0]],f),message:"JSX element with simple logical expression should be on single line",node:m})}}}}return}if(l>=3&&u){if(c.loc.end.line!==s.loc.start.line){e.report({fix:b=>b.replaceTextRange([c.range[1],s.range[0]],""),message:"Opening brace and logical expression should be on the same line",node:s});return}if(s.loc.end.line===o.loc.start.line){let m=n.lines[c.loc.start.line-1].match(/^\s*/)[0];e.report({fix:k=>k.replaceTextRange([s.range[1],o.range[0]],`
`+m),message:"Closing brace should be on its own line for multiline logical expression",node:o})}return}if(c.loc.end.line!==s.loc.start.line){e.report({fix:b=>b.replaceTextRange([c.range[1],s.range[0]],""),message:"Opening brace and logical expression should be on the same line",node:s});return}let T=b=>{if(b.type!=="LogicalExpression"&&b.type!=="BinaryExpression")return!1;let{left:m,right:k}=b;if(b.loc.start.line!==b.loc.end.line){let A=n.getTokenAfter(m,w=>["&&","||","===","!==","==","!=",">","<",">=","<="].includes(w.value));if(A){let w=n.text.slice(m.range[1],A.range[0]);if(w.includes(`
`)&&/\n\s*$/.test(w))return!1;let C=m.loc.end.line,g=A.loc.start.line,f=k.loc.start.line;if(C!==g||g!==f){let S=n.getTokenBefore(b),$=n.getTokenAfter(b),P=S?.value==="("&&$?.value===")",R=n.getText(b).replace(/\s*\n\s*/g," ").trim();return e.report({fix:F=>P?F.replaceTextRange([S.range[0],$.range[1]],`(${R})`):F.replaceText(b,R),message:"Condition operands should be on the same line",node:b}),!0}}}return b.type==="LogicalExpression"?T(m)||T(k):!1};if(s.operator==="&&"&&T(s.left))return;let y=n.getTokenAfter(s.left,b=>b.value==="&&"||b.value==="||");if(y){let b=s.right.type==="JSXElement"||s.right.type==="JSXFragment"||s.right.type==="ConditionalExpression"||s.right.type==="ObjectExpression"||n.getTokenBefore(s.right)?.value==="(",m=n.getTokenAfter(s.left),k=m&&m.value===")",A=k?m.range[1]:s.left.range[1],w=k?m.loc.end.line:s.left.loc.end.line;if(b&&w!==y.loc.start.line){e.report({fix:C=>C.replaceTextRange([A,y.range[1]]," "+y.value),message:"Logical operator should be on the same line as the left operand",node:y});return}let E=n.getTokenAfter(y);E&&E.value==="("&&y.loc.end.line!==E.loc.start.line&&e.report({fix:C=>C.replaceTextRange([y.range[1],E.range[1]]," ("),message:"Opening parenthesis should be on same line as logical operator",node:E});let L=n.getTokenAfter(s.right);L&&L.value===")"&&o.loc.start.line!==L.loc.end.line&&e.report({fix:C=>C.replaceTextRange([L.range[1],o.range[0]],""),message:"Closing parenthesis and brace should be together for logical expression",node:o})}}},JSXSpreadAttribute:i=>{let{argument:s}=i;if(!(s.type==="Identifier"||s.type==="MemberExpression"))return;let o=n.getFirstToken(i),t=n.getLastToken(i);if(o.loc.start.line!==t.loc.end.line){let h=n.getText(s);e.report({fix:p=>p.replaceTextRange([o.range[0],t.range[1]],`{...${h}}`),message:"Simple JSX spread attribute should be on a single line",node:i})}},LogicalExpression:i=>{if(i.parent&&i.parent.type==="JSXExpressionContainer"||i.parent&&i.parent.type==="LogicalExpression"||i.parent&&i.parent.type==="IfStatement"&&i.parent.test===i||i.parent&&i.parent.type==="ConditionalExpression"&&i.parent.test===i)return;let s=o=>o.type==="CallExpression"||o.type==="LogicalExpression"||o.type==="MemberExpression"||o.type==="Identifier"||o.type==="TSAsExpression"||o.type==="ObjectExpression"||o.type==="ArrayExpression";if(!s(i.left)||!s(i.right))return;let c=o=>{if(o.type!=="LogicalExpression")return;let{left:t,right:h,operator:p}=o;c(t),c(h);let l=n.getTokenAfter(t,y=>y.value==="||"||y.value==="&&");if(!l)return;let a=t.loc.end.line,u=l.loc.start.line,T=h.loc.start.line;if(a!==u||u!==T){let y=n.text.slice(t.range[1],l.range[0]);if(y.includes(`
`)&&/\n\s*$/.test(y))return;let m=n.getLastToken(t),k=n.getFirstToken(h);e.report({fix:A=>A.replaceTextRange([m.range[1],k.range[0]],` ${p} `),message:"Logical operator should be on the same line as both operands: ) || func(",node:l})}};c(i)}}},meta:{docs:{description:"Enforce opening brackets on same line for function calls and arrow function params"},fixable:"code",schema:[],type:"layout"}},He={create(e){let n=e.sourceCode||e.getSourceCode(),I=r=>r?r.type==="Literal"||r.type==="Identifier"||r.type==="TemplateLiteral"&&r.expressions.length===0:!1,v=r=>{if(r.type==="ImportExpression")return I(r.source);if(r.type==="CallExpression"){let d=r.callee.type==="Import",i=r.callee.type==="Identifier",s=r.callee.type==="MemberExpression";return!d&&!i&&!s||r.arguments.length>2?!1:r.arguments.every(I)}return!1},x=r=>r?!!(r.type==="Literal"||r.type==="Identifier"||r.type==="TemplateLiteral"&&r.expressions.length===0||v(r)||r.type==="BinaryExpression"||r.type==="LogicalExpression"||r.type==="MemberExpression"||r.type==="UnaryExpression"):!1;return{CallExpression(r){let{callee:d,arguments:i}=r;if(d.type!=="Identifier"&&d.type!=="MemberExpression"||i.length!==1)return;let s=i[0];if(s.type!=="ArrowFunctionExpression"||s.params.length>=2)return;let{body:c}=s;if(c.type==="BlockStatement"||!x(c))return;let o=r,t=r.parent;for(;t&&(t.type==="MemberExpression"||t.type==="ChainExpression");)o=t,t=t.parent;if(o.loc.start.line===o.loc.end.line||n.getCommentsInside(o).some(a=>a.type==="Line"))return;let l=n.getText(o).replace(/\s*\n\s*/g," ").replace(/\s+/g," ").replace(/\(\s+/g,"(").replace(/\s+\)/g,")").replace(/,\s*\)/,")").replace(/\s+\?\./g,"?.").replace(/\?\.\s+/g,"?.");e.report({fix:a=>a.replaceText(o,l),message:"Simple function call with arrow function should be on a single line",node:r})}}},meta:{docs:{description:"Simplify simple function calls with arrow function to single line"},fixable:"code",schema:[],type:"layout"}},Oe={create(e){let n=e.sourceCode||e.getSourceCode(),I=r=>r?r.type==="Literal"||r.type==="Identifier"?!0:r.type==="MemberExpression"?r.object.type==="Identifier"&&r.property.type==="Identifier"&&!r.computed:r.type==="TemplateLiteral"&&r.expressions.length===0?r.loc.start.line===r.loc.end.line:r.type==="UnaryExpression"?I(r.argument):!1:!1,v=r=>r?r.type==="Literal"||r.type==="Identifier"||r.type==="MemberExpression"||r.type==="UnaryExpression"||r.type==="TemplateLiteral"&&r.expressions.length===0&&r.loc.start.line===r.loc.end.line:!1,x=r=>{let d=[],i=r;for(;i&&i.type==="CallExpression"&&(d.unshift(i),i.callee&&i.callee.type==="MemberExpression");)i=i.callee.object;return d};return{CallExpression(r){let{arguments:d,callee:i}=r,s=!(r.parent&&r.parent.type==="MemberExpression"&&r.parent.parent&&r.parent.parent.type==="CallExpression"&&r.parent.parent.callee===r.parent);if(s&&i&&i.type==="MemberExpression"){let u=x(r);if(u.length>=2&&u[0].loc.start.line!==r.loc.end.line){let y=u.every(b=>!(b.arguments.length>1||b.arguments.length===1&&!v(b.arguments[0])));if(y){let b=n.getText(r),m=b.replace(/\s*\n\s*/g,"").replace(/\s{2,}/g," "),k=n.lines[r.loc.start.line-1],A=k.match(/^(\s*)/)[1].length,w=k.slice(A,k.indexOf(b.split(`
`)[0].trim()));if(A+w.length+m.length<=120){e.report({fix:L=>L.replaceText(r,m),message:"Method chain with single simple arguments should be on one line",node:r});return}}if(!y){let b=!1;for(let m=1;m<u.length;m++){let k=n.getLastToken(u[m-1]),A=n.getTokenAfter(u[m].callee.property,w=>w.value==="(");if(k.loc.end.line!==A.loc.start.line){b=!0;break}}if(b){let k=n.lines[r.loc.start.line-1].match(/^(\s*)/)[1].length,A=k+4;for(let S=1;S<u.length;S++){let $=n.getLastToken(u[S-1]),P=n.getTokenAfter(u[S].callee.property,R=>R.value==="(");if($.loc.end.line!==P.loc.start.line){A=n.lines[u[S].callee.property.loc.start.line-1].match(/^(\s*)/)[1].length;break}}let w=k-A,E="",L=r.range[0];for(let S=1;S<u.length;S++){let $=n.getLastToken(u[S-1]),P=n.getTokenAfter(u[S].callee.property,R=>R.value==="(");if($.loc.end.line!==P.loc.start.line){E+=n.text.slice(L,$.range[1]);let R=n.getTokenBefore(u[S].callee.property);E+=R.value+u[S].callee.property.name,L=P.range[0]}}if(E+=n.text.slice(L,r.range[1]),w!==0){let S=E.split(`
`);S.length>1&&(E=S[0]+`
`+S.slice(1).map($=>{let P=$.match(/^(\s*)/)[1].length,R=Math.max(0,P+w);return" ".repeat(R)+$.trimStart()}).join(`
`))}let C=E.split(`
`)[0],g=n.lines[r.loc.start.line-1].slice(0,r.loc.start.column),f=n.getText(r);if(g.length+C.length<=120&&E!==f){e.report({fix:S=>S.replaceText(r,E),message:"Method chain should not have line breaks between calls",node:r});return}}}}}if(!s||d.length!==1)return;let c=d[0];if(!I(c)||r.loc.start.line===r.loc.end.line)return;let o=n.getTokenAfter(i,u=>u.value==="("),t=n.getLastToken(r);if(!o||!t||t.value!==")")return;let h=r.typeArguments||r.typeParameters,p=n.getText(i);h&&(p+=n.getText(h));let l=n.getText(c),a=`${p}(${l})`;a.length>120||e.report({fix:u=>u.replaceText(r,a),message:"Single simple argument should be on one line",node:r})}}},meta:{docs:{description:"Enforce single simple argument calls and method chains to be on one line"},fixable:"code",schema:[],type:"layout"}};var je={create(e){let n=e.sourceCode||e.getSourceCode(),I=new Map,v=(x,r)=>{let d=[],i=s=>{if(!(!s||typeof s!="object")){s.type==="Identifier"&&s.name===r&&d.push(s);for(let c in s){if(c==="parent"||c==="range"||c==="loc")continue;let o=s[c];Array.isArray(o)?o.forEach(t=>i(t)):o&&typeof o=="object"&&o.type&&i(o)}}};return i(x),d};return{ClassDeclaration(x){if(!x.id||!x.id.name)return;let r=x.id.name;r.endsWith("Class")||I.set(r,{classIdNode:x.id,newName:`${r}Class`})},"Program:exit"(x){I.forEach(({classIdNode:r,newName:d},i)=>{let s=v(x,i);e.report({fix:c=>{let o=[];return s.forEach(t=>{o.push(c.replaceText(t,d))}),o},message:`Class name "${i}" should end with "Class" suffix`,node:r})})}}},meta:{docs:{description:"Enforce class names end with 'Class' suffix"},fixable:"code",schema:[],type:"suggestion"}},Me={create(e){let n=e.sourceCode||e.getSourceCode();return{ClassDeclaration(I){let v=I.body;if(!v)return;let x=n.getFirstToken(v);if(!x||x.value!=="{")return;let r=n.getTokenBefore(x);if(!r)return;if(r.loc.end.line!==x.loc.start.line){e.report({fix:i=>i.replaceTextRange([r.range[1],x.range[0]]," "),message:"Opening brace should be on the same line as class declaration",node:x});return}n.text.slice(r.range[1],x.range[0])!==" "&&e.report({fix:i=>i.replaceTextRange([r.range[1],x.range[0]]," "),message:"Expected single space before opening brace in class declaration",node:x})},MethodDefinition(I){let v=I.key,x=I.value;if(!v||!x)return;let r=I.computed?n.getTokenAfter(v,{filter:h=>h.value==="]"}):n.getLastToken(v);if(!r)return;let d=n.getTokenAfter(r);for(;d&&d.value!=="(";)d=n.getTokenAfter(d);if(!d||d.value!=="(")return;let i=n.getTokenBefore(d);if(i){let h=n.text.slice(i.range[1],d.range[0]);/\s/.test(h)&&e.report({fix:p=>p.replaceTextRange([i.range[1],d.range[0]],""),message:"No space between method name and opening parenthesis",node:d})}let s=x.body;if(!s||s.type!=="BlockStatement")return;let c=n.getFirstToken(s);if(!c||c.value!=="{")return;let o=n.getTokenBefore(c);if(!o)return;if(o.loc.end.line!==c.loc.start.line){e.report({fix:h=>h.replaceTextRange([o.range[1],c.range[0]]," "),message:"Opening brace should be on the same line as method signature",node:c});return}n.text.slice(o.range[1],c.range[0])!==" "&&e.report({fix:h=>h.replaceTextRange([o.range[1],c.range[0]]," "),message:"Expected single space before opening brace in method definition",node:c})}}},meta:{docs:{description:"Enforce consistent spacing in class and method definitions"},fixable:"whitespace",schema:[],type:"layout"}};var Ne={create(e){let n=e.sourceCode||e.getSourceCode();return{Program(I){let v=n.getAllComments();if(v.length===0)return;let x=n.getFirstToken(I);if(v.forEach(d=>{let{type:i,value:s}=d;if(i==="Block")if(!s.includes(`
`)){let t=s.trim();if(/^eslint-disable|^eslint-enable|^eslint-disable-next-line|^eslint-disable-line/.test(t))return;e.report({fix:p=>p.replaceText(d,`// ${t}`),loc:d.loc,message:"Single-line comments should use // syntax instead of /* */"})}else{let t=s.length>0&&!s.startsWith(" ")&&!s.startsWith("*")&&!s.startsWith(`
`),h=s.length>0&&!s.endsWith(" ")&&!s.endsWith("*")&&!s.endsWith(`
`);if(t||h){let p=s;t&&(p=" "+p),h&&(p=p+" "),e.report({fix:l=>l.replaceText(d,`/*${p}*/`),loc:d.loc,message:"Block comment should have space after /* and before */"})}}else i==="Line"&&s.length>0&&!s.startsWith(" ")&&!s.startsWith("/")&&e.report({fix:t=>t.replaceText(d,`// ${s}`),loc:d.loc,message:"Line comment should have space after //"});let c=n.getTokenBefore(d,{includeComments:!1});c&&c.loc.end.line===d.loc.start.line&&d.range[0]-c.range[1]!==1&&e.report({fix:t=>t.replaceTextRange([c.range[1],d.range[0]]," "),loc:d.loc,message:"Inline comment should have exactly one space before it"})}),!x)return;let r=v.filter(d=>d.loc.end.line<x.loc.start.line||d.loc.start.line===1&&x.loc.start.line===1&&d.range[1]<x.range[0]);if(r.length>1)for(let d=0;d<r.length-1;d+=1){let i=r[d],s=r[d+1];s.loc.start.line-i.loc.end.line>1&&e.report({fix:o=>o.replaceTextRange([i.range[1],s.range[0]],`
`),loc:s.loc,message:"No blank lines allowed between top-of-file comments"})}if(r.length>0){let d=r[r.length-1];x.loc.start.line===d.loc.end.line+1?e.report({fix:i=>i.insertTextAfter(d,`
`),loc:x.loc,message:"Expected empty line between top-of-file comments and code"}):x.loc.start.line===d.loc.end.line&&e.report({fix:i=>i.insertTextBefore(x,`

`),loc:x.loc,message:"Code should be on a new line after top-of-file comments"})}}}},meta:{docs:{description:"Enforce comment spacing and formatting"},fixable:"whitespace",schema:[],type:"layout"}};import Se from"fs";var Ee=e=>e.endsWith("ies")?e.slice(0,-3)+"y":e.endsWith("ses")||e.endsWith("xes")||e.endsWith("zes")?e.slice(0,-2):e.endsWith("s")?e.slice(0,-1):e,De={create(e){let n=e.sourceCode||e.getSourceCode(),I=i=>{if(!i)return!1;if(i.type==="JSXElement"||i.type==="JSXFragment")return!0;if(i.type==="BlockStatement"){for(let s of i.body)if(s.type==="ReturnStatement"&&s.argument&&I(s.argument))return!0}return i.type==="ConditionalExpression"?I(i.consequent)||I(i.alternate):i.type==="LogicalExpression"?I(i.left)||I(i.right):i.type==="ParenthesizedExpression"?I(i.expression):!1},v=i=>{let s=null;if(i.parent&&(i.parent.type==="VariableDeclarator"&&i.parent.id&&i.parent.id.type==="Identifier"?s=i.parent.id.name:i.id&&i.id.type==="Identifier"&&(s=i.id.name)),s&&/^[A-Z]/.test(s)){let c=i.body;return I(c)}return!1},x=(i,s)=>{let c=[],o=t=>{if(!(!t||typeof t!="object")){if(t.type==="MemberExpression"&&!t.computed&&t.object.type==="Identifier"&&t.object.name===s){let h=t.property.name;c.push({node:t,property:h})}for(let h of Object.keys(t)){if(h==="parent")continue;let p=t[h];Array.isArray(p)?p.forEach(o):p&&typeof p=="object"&&p.type&&o(p)}}};return o(i),c},r=(i,s)=>{let c=[];if(i.type!=="BlockStatement")return c;for(let o of i.body)if(o.type==="VariableDeclaration"){for(let t of o.declarations)if(t.id.type==="ObjectPattern"&&t.init&&t.init.type==="Identifier"&&t.init.name===s){let h=[];for(let p of t.id.properties)if(p.type==="Property"&&p.key.type==="Identifier"){let l=p.key.name,a=p.value.type==="Identifier"?p.value.name:null,u=p.value.type==="AssignmentPattern",T=null;u&&p.value.right&&(T=n.getText(p.value.right)),h.push({default:T,hasAlias:l!==a&&!u,key:l,value:u?p.value.left.name:a})}else p.type==="RestElement"&&p.argument.type==="Identifier"&&h.push({isRest:!0,key:p.argument.name,value:p.argument.name});c.push({declarator:t,props:h,statement:o,statementHasOnlyThisDeclarator:o.declarations.length===1})}}return c},d=i=>{if(!v(i))return;let s=i.params;if(s.length===0)return;let c=s[0];if(c.type==="Identifier"){let o=c.name,t=x(i.body,o),h=r(i.body,o),p=[...new Set(t.map(m=>m.property))],l=[];h.forEach(m=>{m.props.forEach(k=>{l.push(k)})});let a=[],u=(m,k=[])=>{if(!(!m||typeof m!="object")&&!k.includes(m)){m.type==="Identifier"&&m.name===o&&a.push(m);for(let A of Object.keys(m)){if(A==="parent")continue;let w=m[A];Array.isArray(w)?w.forEach(E=>u(E,k)):w&&typeof w=="object"&&w.type&&u(w,k)}}};u(i.body);let T=t.length+h.length,b=(p.length>0||l.length>0)&&a.length===T;e.report({fix:b?m=>{let k=[],A=[];p.forEach(C=>{A.some(g=>g.key===C)||A.push({key:C,simple:!0})}),l.forEach(C=>{A.some(g=>g.key===C.key)||A.push(C)});let E=`{ ${A.map(C=>C.isRest?`...${C.key}`:C.simple?C.key:C.default?`${C.key} = ${C.default}`:C.hasAlias?`${C.key}: ${C.value}`:C.key).join(", ")} }`,L=E;if(c.typeAnnotation){let C=n.getText(c.typeAnnotation);L=`${E}${C}`}return k.push(m.replaceText(c,L)),t.forEach(C=>{k.push(m.replaceText(C.node,C.property))}),h.forEach(C=>{if(C.statementHasOnlyThisDeclarator){let g=C.statement.range[0],f=C.statement.range[1],S=n.getText().slice(f,f+2);S.startsWith(`
`)?f+=1:S.startsWith(`\r
`)&&(f+=2),k.push(m.removeRange([g,f]))}else k.push(m.remove(C.declarator))}),k}:void 0,message:`Component props should be destructured. Use "({ ...props })" instead of "${c.name}"`,node:c})}};return{ArrowFunctionExpression:d,FunctionDeclaration:d,FunctionExpression:d}},meta:{docs:{description:"Enforce that React component props must be destructured in the function parameter"},fixable:"code",schema:[],type:"suggestion"}},Je={create(e){let n=e.sourceCode||e.getSourceCode(),I=d=>{if(!d)return!1;if(d.type==="JSXElement"||d.type==="JSXFragment")return!0;if(d.type==="BlockStatement"){for(let i of d.body)if(i.type==="ReturnStatement"&&i.argument&&I(i.argument))return!0}return d.type==="ConditionalExpression"?I(d.consequent)||I(d.alternate):d.type==="LogicalExpression"?I(d.left)||I(d.right):d.type==="ParenthesizedExpression"?I(d.expression):!1},v=d=>{let i=null;if(d.parent&&(d.parent.type==="VariableDeclarator"&&d.parent.id&&d.parent.id.type==="Identifier"?i=d.parent.id.name:d.id&&d.id.type==="Identifier"&&(i=d.id.name)),i&&/^[A-Z]/.test(i)){let s=d.body;return I(s)}return!1},x=d=>{let i=d.params;if(i.length===0)return;let s=v(d);s||i.forEach(l=>{if(l.type==="Identifier"&&l.typeAnnotation&&l.typeAnnotation.typeAnnotation){let a=l.typeAnnotation.typeAnnotation;a.type==="TSTypeLiteral"&&e.report({message:`Parameter "${l.name}" must use a type reference (interface or type alias), not an inline object type. Define the type separately.`,node:a})}});let c=i[0];if(c.type!=="ObjectPattern")return;if(!c.typeAnnotation||!c.typeAnnotation.typeAnnotation){let l=e.getFilename?e.getFilename():e.filename||"";(l.endsWith(".ts")||l.endsWith(".tsx"))&&s&&e.report({message:'Component props must have a type annotation. Add inline type: "({ prop }: { prop: Type })"',node:c});return}let o=c.typeAnnotation.typeAnnotation,t=n.getFirstToken(c.typeAnnotation),h=t?n.getTokenBefore(t):null,p=n.getFirstToken(o);if(h&&t&&p&&h.value==="}"){let l=n.getText().slice(h.range[1],t.range[0]),a=n.getText().slice(t.range[1],p.range[0]);(l!==""||a!==" ")&&e.report({fix:u=>u.replaceTextRange([h.range[1],p.range[0]],": "),message:'Type annotation must have no space before colon and one space after: "}: TypeName"',node:o})}if(o.type==="TSIntersectionType"&&s){let l=o.types;for(let u=0;u<l.length-1;u+=1){let T=l[u],y=l[u+1],b=n.getTokenAfter(T,m=>m.value==="&");if(b&&b.loc.start.line!==T.loc.end.line&&e.report({fix:m=>m.replaceTextRange([T.range[1],b.range[1]]," &"),message:'"&" must be on same line as previous type',node:b}),y.type==="TSTypeLiteral"&&b){let m=n.getFirstToken(y);m&&m.loc.start.line!==b.loc.end.line&&e.report({fix:k=>k.replaceTextRange([b.range[1],m.range[0]]," "),message:'Opening brace must be on same line as "&"',node:m})}}let a=l.find(u=>u.type==="TSTypeLiteral");if(a){let u=a.members,y=n.lines[d.loc.start.line-1].match(/^\s*/)[0],b=y+"    ",m=n.getFirstToken(a),k=n.getLastToken(a);if(u.length>1&&u[0]){let A=u[0];A.loc.start.line===m.loc.end.line&&e.report({fix:w=>w.replaceTextRange([m.range[1],A.range[0]],`
`+b),message:"First props type property must be on a new line when there are multiple properties",node:A})}if(u.length>1&&k){let A=u[u.length-1];k.loc.start.line===A.loc.end.line&&e.report({fix:w=>w.replaceTextRange([A.range[1],k.range[0]],`
`+y),message:"Closing brace must be on its own line when there are multiple properties",node:k})}if(u.length===1&&m&&k){let A=u[0];if(m.loc.end.line!==k.loc.start.line){let w=n.getText(A);w=w.replace(/[,;]\s*$/,""),e.report({fix:E=>E.replaceTextRange([m.range[0],k.range[1]],`{ ${w} }`),message:"Single props type property should be on a single line",node:a})}}if(u.forEach((A,w)=>{let E=n.getText(A);if(E.trimEnd().endsWith(";")&&e.report({fix:L=>{let C=E.lastIndexOf(";"),g=A.range[0]+C;return L.replaceTextRange([g,g+1],",")},message:"Props type properties must end with comma (,) not semicolon (;)",node:A}),u.length>1&&w>0){let L=u[w-1];A.loc.start.line===L.loc.end.line&&e.report({fix:C=>{let g=n.getTokenAfter(L);for(;g&&g.value!==","&&g.range[0]<A.range[0];)g=n.getTokenAfter(g);let f=g&&g.value===","?g.range[1]:L.range[1];return C.replaceTextRange([f,A.range[0]],`
`+b)},message:"Each props type property must be on its own line when there are multiple properties",node:A}),A.loc.start.line-L.loc.end.line>1&&e.report({fix:C=>{let f=n.getText().slice(L.range[1],A.range[0]).replace(/\n\s*\n/g,`
`);return C.replaceTextRange([L.range[1],A.range[0]],f)},message:"No empty lines allowed between props type properties",node:A})}}),u.length>1){let A=u[u.length-1];n.getText(A).trimEnd().endsWith(",")||e.report({fix:E=>E.insertTextAfter(A,","),message:"Last props type property must have trailing comma",node:A})}if(u.length===1){let A=u[0],w=n.getText(A);w.trimEnd().endsWith(",")&&e.report({fix:E=>{let L=w.lastIndexOf(","),C=A.range[0]+L;return E.removeRange([C,C+1])},message:"Single props type property should not have trailing comma",node:A})}if(u.length>0&&k){let A=u[u.length-1];k.loc.start.line-A.loc.end.line>1&&e.report({fix:w=>w.replaceTextRange([A.range[1],k.range[0]],`
`+y),message:"No empty line before closing brace in props type",node:k})}}return}if(o.type==="TSTypeReference"){if(s){let l=o.typeName&&o.typeName.name?o.typeName.name:n.getText(o.typeName);if(o.typeName&&o.typeName.type==="TSQualifiedName")return;e.report({message:`Component props should use inline type annotation instead of referencing "${l}". Define the type inline as "{ prop: type, ... }"`,node:o})}return}if(o.type==="TSTypeLiteral"&&s){let l=o.members,u=n.lines[d.loc.start.line-1].match(/^\s*/)[0],T=u+"    ",y=n.getFirstToken(o),b=c.properties.filter(E=>E.type==="Property"||E.type==="RestElement").map(E=>E.type==="RestElement"?null:E.key&&E.key.name?E.key.name:null).filter(Boolean).sort(),m=l.filter(E=>E.type==="TSPropertySignature").map(E=>E.key&&E.key.name?E.key.name:null).filter(Boolean).sort(),k=b.filter(E=>!m.includes(E)),A=m.filter(E=>!b.includes(E));k.length>0&&e.report({message:`Props type is missing properties that are destructured: ${k.join(", ")}`,node:o}),A.length>0&&e.report({message:`Props type has extra properties not in destructured props: ${A.join(", ")}`,node:o});let w=n.getLastToken(o);if(l.length>0){let E=l[0];E.loc.start.line-y.loc.end.line>1&&e.report({fix:L=>L.replaceTextRange([y.range[1],E.range[0]],`
`+T),message:"No empty line after opening brace in props type",node:E})}if(l.length>0&&w){let E=l[l.length-1];w.loc.start.line-E.loc.end.line>1&&e.report({fix:L=>L.replaceTextRange([E.range[1],w.range[0]],`
`+u),message:"No empty line before closing brace in props type",node:E})}if(l.length>1&&l[0]){let E=l[0];E.loc.start.line===y.loc.end.line&&e.report({fix:L=>L.replaceTextRange([y.range[1],E.range[0]],`
`+T),message:"First props type property must be on a new line when there are multiple properties",node:E})}if(l.length>1&&w){let E=l[l.length-1];w.loc.start.line===E.loc.end.line&&e.report({fix:L=>L.replaceTextRange([E.range[1],w.range[0]],`
`+u),message:"Closing brace must be on its own line when there are multiple properties",node:w})}if(l.length===1&&y&&w){let E=l[0];if(y.loc.end.line!==w.loc.start.line){let L=n.getText(E);L=L.replace(/[,;]\s*$/,""),e.report({fix:C=>C.replaceTextRange([y.range[0],w.range[1]],`{ ${L} }`),message:"Single props type property should be on a single line",node:o})}}if(l.forEach((E,L)=>{let C=n.getText(E);if(E.type==="TSPropertySignature"&&E.optional){let g=n.getFirstToken(E),f=n.getTokenAfter(g);f&&f.value==="?"&&n.getText().slice(g.range[1],f.range[0])!==""&&e.report({fix:$=>$.replaceTextRange([g.range[1],f.range[0]],""),message:'No space allowed before "?" in optional property',node:E})}if(C.trimEnd().endsWith(";")&&e.report({fix:g=>{let f=C.lastIndexOf(";"),S=E.range[0]+f;return g.replaceTextRange([S,S+1],",")},message:"Props type properties must end with comma (,) not semicolon (;)",node:E}),l.length>1&&L>0){let g=l[L-1];E.loc.start.line===g.loc.end.line&&e.report({fix:f=>{let S=n.getTokenAfter(g);for(;S&&S.value!==","&&S.range[0]<E.range[0];)S=n.getTokenAfter(S);let $=S&&S.value===","?S.range[1]:g.range[1];return f.replaceTextRange([$,E.range[0]],`
`+T)},message:"Each props type property must be on its own line when there are multiple properties",node:E}),E.loc.start.line-g.loc.end.line>1&&e.report({fix:f=>{let $=n.getText().slice(g.range[1],E.range[0]).replace(/\n\s*\n/g,`
`);return f.replaceTextRange([g.range[1],E.range[0]],$)},message:"No empty lines allowed between props type properties",node:E})}}),l.length>1){let E=l[l.length-1];n.getText(E).trimEnd().endsWith(",")||e.report({fix:C=>C.insertTextAfter(E,","),message:"Last props type property must have trailing comma",node:E})}if(l.length===1){let E=l[0],L=n.getText(E);L.trimEnd().endsWith(",")&&e.report({fix:C=>{let g=L.lastIndexOf(","),f=E.range[0]+g;return C.removeRange([f,f+1])},message:"Single props type property should not have trailing comma",node:E})}}},r=d=>{if(!d.returnType||!d.returnType.typeAnnotation)return;let i=d.returnType,s=i.typeAnnotation;if(!v(d)&&s.type==="TSTypeLiteral"){e.report({message:"Function return type must be a type reference (interface, type, or built-in type), not an inline object type. Define the return type separately.",node:s});return}let o;if(d.params.length>0){let a=d.params[d.params.length-1];o=n.getTokenAfter(a,u=>u.value===")")}else{let u=n.getFirstToken(d);for(;u&&u.value!=="(";)u=n.getTokenAfter(u);u&&(o=n.getTokenAfter(u,T=>T.value===")"))}if(!o)return;let t=n.getFirstToken(i);if(!t||t.value!==":")return;let h=n.getFirstToken(s);if(!h)return;let p=n.getText().slice(o.range[1],t.range[0]),l=n.getText().slice(t.range[1],h.range[0]);(p!==""||l!==" ")&&e.report({fix:a=>a.replaceTextRange([o.range[1],h.range[0]],": "),message:'Return type annotation must have no space before colon and one space after: "): TypeName"',node:i})};return{ArrowFunctionExpression(d){x(d),r(d)},FunctionDeclaration(d){x(d),r(d)},FunctionExpression(d){x(d),r(d)}}},meta:{docs:{description:"Enforce inline type annotation for React component props and return types with proper formatting"},fixable:"code",schema:[],type:"suggestion"}},Xe={create(e){let n=d=>d.parent&&d.parent.type==="VariableDeclarator"&&d.parent.id&&d.parent.id.type==="Identifier"?d.parent.id.name:d.id&&d.id.type==="Identifier"?d.id.name:null,I=d=>d&&/^[A-Z]/.test(d),v=d=>d&&d.endsWith("Icon"),x=d=>{let i=d.body;if(!i)return!1;if(i.type==="JSXElement")return i.openingElement&&i.openingElement.name&&i.openingElement.name.name==="svg";if(i.type==="ParenthesizedExpression"&&i.expression&&i.expression.type==="JSXElement")return i.expression.openingElement&&i.expression.openingElement.name&&i.expression.openingElement.name.name==="svg";if(i.type==="BlockStatement"){let s=i.body.filter(c=>c.type==="ReturnStatement"&&c.argument);if(s.length===1){let c=s[0].argument;if(c.type==="JSXElement")return c.openingElement&&c.openingElement.name&&c.openingElement.name.name==="svg";if(c.type==="ParenthesizedExpression"&&c.expression&&c.expression.type==="JSXElement")return c.expression.openingElement&&c.expression.openingElement.name&&c.expression.openingElement.name.name==="svg"}}return!1},r=d=>{let i=n(d);if(!I(i))return;let s=x(d),c=v(i);s&&!c&&e.report({message:`Component "${i}" returns an SVG element and should end with "Icon" suffix (e.g., "${i}Icon")`,node:d.parent&&d.parent.type==="VariableDeclarator"?d.parent.id:d.id||d}),c&&!s&&e.report({message:`Component "${i}" has "Icon" suffix but doesn't return an SVG element. Either rename it or make it return an SVG.`,node:d.parent&&d.parent.type==="VariableDeclarator"?d.parent.id:d.id||d})};return{ArrowFunctionExpression:r,FunctionDeclaration:r,FunctionExpression:r}},meta:{docs:{description:"Enforce SVG components to have 'Icon' suffix and vice versa"},fixable:null,schema:[],type:"suggestion"}},ze={create(e){let I=(e.filename||e.getFilename()).replace(/\\/g,"/"),v=e.options[0]||{},x=v.chainOrder||"child-parent",r=v.files||[],i=(()=>{for(let f of r)if(f.paths.some(S=>I.includes(S)))return f.chainOrder;return x})(),s={atoms:"",components:"",constants:"Constants",contexts:"Context",data:"Data",layouts:"Layout",pages:"Page",providers:"Provider",reducers:"Reducer",schemas:"Schema",services:"Service",strings:"Strings",theme:"Theme",themes:"Theme",views:"View"},c=new Set(["atoms","components","layouts","pages","views"]),o=new Set(["constants","data","reducers","schemas","services","strings"]),t=f=>f.split("-").map(S=>S.charAt(0).toUpperCase()+S.slice(1)).join(""),h=f=>f.charAt(0).toLowerCase()+f.slice(1),p=Object.keys(s).join("|"),l=()=>{let f=new RegExp(`\\/(${p})\\/(.+)\\.(jsx?|tsx?)$`),S=I.match(f);if(!S)return null;let $=S[1],P=s[$],F=S[2].split("/"),B=F[F.length-1],j=F.slice(0,-1);return{fileName:B,folder:$,intermediateFolders:j,suffix:P}},a=new Set(["shared","common","ui","base","general","core"]),u=f=>{let{fileName:S,folder:$,intermediateFolders:P,suffix:R}=f;if(S==="index"&&P.length===0)return null;let F=P.filter(H=>!a.has(H)),B;if(S==="index"){if(B=i==="parent-child"?[...F]:[...F].reverse(),B.length===0)return null}else{let H=F.map(Ee);B=i==="parent-child"?[...H,S]:[S,...[...H].reverse()]}let j=B.map(t).join("")+R;return o.has($)?h(j):j},T=f=>f.parent&&f.parent.type==="VariableDeclarator"&&f.parent.id&&f.parent.id.type==="Identifier"?{name:f.parent.id.name,identifierNode:f.parent.id}:f.id&&f.id.type==="Identifier"?{name:f.id.name,identifierNode:f.id}:null,y=f=>f&&/^[A-Z]/.test(f),b=f=>{let S=f.body;return S?S.type==="JSXElement"||S.type==="JSXFragment"||S.type==="ParenthesizedExpression"&&S.expression&&(S.expression.type==="JSXElement"||S.expression.type==="JSXFragment")?!0:S.type==="BlockStatement"?S.body.some(P=>{if(P.type==="ReturnStatement"&&P.argument){let R=P.argument;return R.type==="JSXElement"||R.type==="JSXFragment"||R.type==="ParenthesizedExpression"&&R.expression&&(R.expression.type==="JSXElement"||R.expression.type==="JSXFragment")}return!1}):!1:!1},m=(f,S,$,P)=>R=>{let F=e.sourceCode?e.sourceCode.getScope(f):e.getScope(),B=(D,J)=>{let _=D.variables.find(W=>W.name===J);return _||(D.upper?B(D.upper,J):null)},j=B(F,S);if(!j)return R.replaceText(P,$);let H=[],M=new Set;return j.defs.forEach(D=>{let J=`${D.name.range[0]}-${D.name.range[1]}`;M.has(J)||(M.add(J),H.push(R.replaceText(D.name,$)))}),j.references.forEach(D=>{let J=`${D.identifier.range[0]}-${D.identifier.range[1]}`;M.has(J)||(M.add(J),H.push(R.replaceText(D.identifier,$)))}),H},k=(f,S,$,P)=>$?`"${f}" in "${S}" folder must be named "${P}" (expected "${$}" suffix with chained folder names)`:`"${f}" in "${S}" folder must be named "${P}" (expected chained folder names)`,A=(f,S)=>{let $=Object.entries(s).filter(([P,R])=>P!==S&&R&&f.endsWith(R)).sort((P,R)=>R[1].length-P[1].length)[0];return $?$[0]:null},w=f=>f&&/^[a-z]/.test(f),E=(f,S)=>{let $=f.length,P=S.length;if(Math.abs($-P)>2)return 3;let R=Array.from({length:$+1},()=>Array(P+1).fill(0));for(let F=0;F<=$;F++)R[F][0]=F;for(let F=0;F<=P;F++)R[0][F]=F;for(let F=1;F<=$;F++)for(let B=1;B<=P;B++)R[F][B]=f[F-1]===S[B-1]?R[F-1][B-1]:1+Math.min(R[F-1][B-1],R[F-1][B],R[F][B-1]);return R[$][P]},L=(f,S,$,P,R,F)=>{let B=F.fileName==="index",j=B?"":t(F.fileName),H=F.intermediateFolders.filter(V=>!a.has(V)),M=B?H:H.map(Ee),J=(i==="parent-child"?[...M]:[...M].reverse()).map(t).join(""),_=i==="parent-child"?J+j:j+J,W=_+$,K=h(W);if(f.endsWith(W)||f===K)return;let ee,X=f.endsWith($)?f.slice(0,-$.length):f,q=X.charAt(0).toUpperCase()+X.slice(1);_.startsWith(q)||E(X,h(j))<=2?ee=K:ee=X+W,e.report({fix:m(R,f,ee,P),message:`"${f}" in "${S}" folder must end with "${W}" (should be "${ee}")`,node:P})},C=f=>{let S=l();if(!S)return;let $=T(f);if(!$)return;let{name:P,identifierNode:R}=$,{folder:F,suffix:B}=S;if(o.has(F)){if(!B)return;if(w(P))L(P,F,B,R,f,S);else if(y(P)){let H=h(P);e.report({fix:m(f,P,H,R),message:`"${P}" in "${F}" folder should be camelCase. Rename to "${H}"`,node:R})}return}if(!y(P)){let H=f.parent&&f.parent.type==="VariableDeclarator"&&f.parent.parent;if(H&&H.parent&&H.parent.type==="ExportNamedDeclaration"&&w(P)){let D=u(S);D&&e.report({fix:m(f,P,D,R),message:`"${P}" in "${F}" folder should be PascalCase. Rename to "${D}"`,node:R})}return}if(c.has(F)&&!b(f))return;let j=u(S);if(j&&P!==j){let H=A(P,F);if(H){e.report({message:`"${P}" belongs in "${H}/" folder, not "${F}/". Move it to the correct folder.`,node:R});return}e.report({fix:m(f,P,j,R),message:k(P,F,B,j),node:R})}};return{ArrowFunctionExpression:C,FunctionDeclaration:C,FunctionExpression:C,VariableDeclarator:f=>{if(!f.id||f.id.type!=="Identifier"||f.init&&(f.init.type==="ArrowFunctionExpression"||f.init.type==="FunctionExpression"))return;let S=l();if(!S)return;let{folder:$,suffix:P}=S;if(c.has($))return;let R=f.id.name;if(o.has($)){if(!P)return;if(w(R))L(R,$,P,f.id,f,S);else if(y(R)){let B=h(R);e.report({fix:m(f,R,B,f.id),message:`"${R}" in "${$}" folder should be camelCase. Rename to "${B}"`,node:f.id})}return}if(!y(R)){if(f.parent&&f.parent.parent&&f.parent.parent.type==="ExportNamedDeclaration"&&w(R)){let j=u(S);j&&e.report({fix:m(f,R,j,f.id),message:`"${R}" in "${$}" folder should be PascalCase. Rename to "${j}"`,node:f.id})}return}let F=u(S);if(F&&R!==F){let B=A(R,$);if(B){e.report({message:`"${R}" belongs in "${B}/" folder, not "${$}/". Move it to the correct folder.`,node:f.id});return}e.report({fix:m(f,R,F,f.id),message:k(R,$,P,F),node:f.id})}}}},meta:{docs:{description:"Enforce naming conventions based on folder location \u2014 suffix for views/layouts/pages/providers/reducers/contexts/themes, chained folder names for nested files"},fixable:"code",schema:[{additionalProperties:!1,properties:{chainOrder:{default:"child-parent",description:"Order of folder chain in names: child-parent (LoginAuth) or parent-child (AuthLogin)",enum:["child-parent","parent-child"],type:"string"},files:{description:"Per-path chainOrder overrides",items:{additionalProperties:!1,properties:{chainOrder:{enum:["child-parent","parent-child"],type:"string"},paths:{items:{type:"string"},type:"array"}},required:["chainOrder","paths"],type:"object"},type:"array"}},type:"object"}],type:"suggestion"}},We={create(e){let I=(e.filename||e.getFilename()).replace(/\\/g,"/"),v=e.options[0]||{},x=["actions","apis","assets","atoms","components","config","configs","constants","contexts","data","enums","helpers","hooks","interfaces","layouts","lib","middlewares","molecules","organisms","pages","providers","reducers","redux","requests","routes","schemas","sections","services","store","strings","styles","theme","thunks","types","ui","utils","utilities","views","widgets"],r=v.moduleFolders||[...x,...v.extraModuleFolders||[]],i=(()=>{for(let w of r){let E=new RegExp(`(.*/${w})/`),L=I.match(E);if(L)return{folder:w,fullPath:L[1]}}return null})();if(!i){let w=I.replace(/.*\//,"").replace(/\.(jsx?|tsx?)$/,"");return r.includes(w)?{Program(E){e.report({message:`"${w}" should be a folder, not a standalone file. Use "${w}/" folder with an index file instead.`,node:E})}}:{}}let s=/\.(tsx?|jsx?)$/,c=(w,E)=>{let L;try{L=Se.readdirSync(w,{withFileTypes:!0})}catch{return null}let C=L.filter(F=>F.isFile()&&s.test(F.name)&&!F.name.startsWith("index.")),g=L.filter(F=>F.isDirectory());if(C.length===0&&g.length===0||C.length<=1&&g.length===0)return null;let f=()=>{for(let F of g)try{let B=`${w}/${F.name}`,j=Se.readdirSync(B,{withFileTypes:!0}),H=j.filter(D=>D.isFile()&&s.test(D.name));if(H.length>=2||H.some(D=>D.name.startsWith("index."))||j.filter(D=>D.isDirectory()).length>0)return!0}catch{}return!1},S=C.length>0,$=g.length>0,P=S&&$,R=$?f():!1;return{folderLabel:E,hasDirectFiles:S,hasSubdirectories:$,isMixed:P,wrappedJustified:R}},{fullPath:o}=i,t=I.split("/"),h=t.slice(0,-1).join("/"),p=t[t.length-2],l=h,a=p,u=c(l,a),T=[],y=h;for(;y.length>o.length;){let w=y.slice(0,y.lastIndexOf("/"));if(w.length<o.length)break;try{let E=Se.readdirSync(w,{withFileTypes:!0}),L=E.filter(g=>g.isDirectory()),C=E.filter(g=>g.isFile()&&s.test(g.name)&&!g.name.startsWith("index."));if(L.length===1&&C.length===0){let g=w.split("/").pop(),f=L[0].name,S=["shared","common"],$=w===o,P=S.includes(g)||S.includes(f);!$&&!P&&T.push({folderName:g,subfolderName:f,suggestedName:`${g}-${f}`})}}catch{}y=w}if(!u&&T.length===0)return{};let{hasDirectFiles:b,hasSubdirectories:m,isMixed:k,wrappedJustified:A}=u||{};return{Program(w){if(u){if(!b&&m&&!A){e.report({message:`Unnecessary wrapper folders in "${a}/". Each item has only one file, use direct files instead (e.g., ${a}/component.tsx).`,node:w});return}if(k&&A){!I.slice(l.length+1).includes("/")&&e.report({message:`Since some items in "${a}/" contain multiple files or subfolders, all items should be wrapped in folders.`,node:w});return}k&&!A&&I.slice(l.length+1).includes("/")&&e.report({message:`Unnecessary wrapper folder. Each item in "${a}/" has only one file, use direct files instead.`,node:w})}for(let E of T)e.report({message:`"${E.folderName}/" has only one subfolder "${E.subfolderName}/". Flatten to "${E.suggestedName}/" to reduce nesting.`,node:w})}}},meta:{docs:{description:"Enforce consistent folder structure (flat vs wrapped) in module folders like atoms, components, hooks, enums, views, layouts, and pages"},fixable:null,schema:[{additionalProperties:!1,properties:{extraModuleFolders:{items:{type:"string"},type:"array"},moduleFolders:{items:{type:"string"},type:"array"}},type:"object"}],type:"suggestion"}},Ve={create(e){let v=(e.filename||e.getFilename()).replace(/\\/g,"/").split("/"),x=v[v.length-1],r=x.replace(/\.(jsx?|tsx?)$/,""),d=v.indexOf("src");if(d===-1)return{};let i=v.slice(d+1,v.length-1);if(i.length===0)return{};let s=[];for(let t=1;t<i.length;t++){let h=i[t];for(let p=0;p<t;p++){let l=i[p],a=Ee(l),u=`-${l}`,T=`-${a}`,y=h.endsWith(u)?u:l!==a&&h.endsWith(T)?T:null;y&&s.push({ancestorFolder:l,folderName:h,singular:a,suffix:y,suggestedName:h.slice(0,-y.length)})}}let c=null;if(r!=="index"&&i.length>=2){let t=i[i.length-1];r===t&&(c=t)}let o=null;if(r!=="index"&&!c&&!(r.startsWith("use-")&&i.includes("hooks")))for(let t of i){let h=Ee(t),p=`-${t}`,l=`-${h}`;if(r.endsWith(p)){o={folder:t,singular:h,suffix:p};break}if(t!==h&&r.endsWith(l)){o={folder:t,singular:h,suffix:l};break}}return s.length===0&&!o&&!c?{}:{Program(t){for(let h of s)e.report({message:`Folder name "${h.folderName}" has redundant suffix "${h.suffix}" \u2014 the "${h.ancestorFolder}/" ancestor folder already provides this context. Rename to "${h.suggestedName}".`,node:t});c&&e.report({message:`File name "${r}" is the same as its parent folder "${c}/". Use "index" instead (e.g., "${c}/index${x.match(/\.\w+$/)[0]}").`,node:t}),o&&e.report({message:`File name "${r}" has redundant suffix "${o.suffix}" \u2014 the "${o.folder}/" folder already provides this context. Rename to "${r.slice(0,-o.suffix.length)}".`,node:t})}}},meta:{docs:{description:"Disallow file and folder names that redundantly include the parent or ancestor folder name as a suffix"},fixable:null,schema:[],type:"suggestion"}};var Ue={create(e){let n=e.sourceCode||e.getSourceCode();return{BlockStatement:v=>{let{body:x}=v;if(x.length===0)return;let r=n.getFirstToken(v),d=n.getLastToken(v),i=x[0],s=x[x.length-1],c=" ".repeat(i.loc.start.column),o=" ".repeat(r.loc.start.column);r.loc.end.line===i.loc.start.line&&e.report({fix:t=>t.replaceTextRange([r.range[1],i.range[0]],`
`+c),message:"Statement should be on its own line after opening brace",node:i}),d.loc.start.line===s.loc.end.line&&e.report({fix:t=>t.replaceTextRange([s.range[1],d.range[0]],`
`+o),message:"Closing brace should be on its own line",node:d})}}},meta:{docs:{description:"Enforce newlines after opening brace and before closing brace in blocks"},fixable:"whitespace",schema:[],type:"layout"}},_e={create(e){let n=e.sourceCode||e.getSourceCode(),I=(x,r)=>["Identifier","MemberExpression","UnaryExpression","Literal"].includes(x.type)||x.type==="CallExpression"&&x.arguments.length===0?!0:x.type==="LogicalExpression"?/\n\s*(\|\||&&)/.test(r)?!1:r.replace(/\s+/g," ").trim().length<=80:!1;return{IfStatement:x=>{let{consequent:r,test:d}=x,i=r.type==="BlockStatement",s=n.getFirstToken(x),c=n.getTokenAfter(s,l=>l.value==="("),o=n.getTokenAfter(d,l=>l.value===")");if(!c||!o)return;let t=i?n.getFirstToken(r):null;if(s.loc.end.line!==c.loc.start.line){e.report({fix:l=>l.replaceTextRange([s.range[1],c.range[0]]," "),message:"Opening parenthesis should be on the same line as 'if'",node:c});return}let h=c.loc.end.line!==o.loc.start.line,p=n.getText(d);if(h&&I(d,p)){let l=p.replace(/\s+/g," ").trim();e.report({fix:a=>a.replaceTextRange([c.range[1],o.range[0]],l),message:"If condition should be on a single line",node:d});return}t&&o.loc.end.line!==t.loc.start.line&&e.report({fix:l=>l.replaceTextRange([o.range[1],t.range[0]]," "),message:"Opening brace should be on the same line as closing parenthesis",node:t})}}},meta:{docs:{description:"Ensure if statement has proper formatting: if (...) {"},fixable:"whitespace",schema:[],type:"layout"}},qe={create(e){let n=e.sourceCode||e.getSourceCode(),I=r=>{if(r.type!=="IfStatement")return!1;let{consequent:d}=r;return d.type!=="BlockStatement"?!0:d.loc.start.line===d.loc.end.line},v=r=>{let{alternate:d}=r;if(!d||!I(r))return;let{consequent:i}=r,s=(i.type==="BlockStatement",n.getLastToken(i)),c=n.getTokenAfter(s,t=>t.value==="else");if(!c)return;c.loc.start.line-s.loc.end.line>1&&e.report({fix:t=>t.replaceTextRange([s.range[1],c.range[0]],`
`+" ".repeat(c.loc.start.column)),message:"No empty line allowed between single-line if and else",node:c})},x=r=>{let{body:d}=r;if(!(!d||!Array.isArray(d)))for(let i=0;i<d.length-1;i+=1){let s=d[i],c=d[i+1];if(s.type!=="IfStatement"||c.type!=="IfStatement")continue;let o=s;for(;o.alternate&&o.alternate.type==="IfStatement";)o=o.alternate;let t=o.alternate||o.consequent,h=t.type==="BlockStatement",p=c.consequent.type==="BlockStatement";(h||p)&&c.loc.start.line-t.loc.end.line===1&&e.report({fix:a=>a.insertTextAfter(t,`
`),message:"Expected empty line between consecutive if statements with block bodies",node:c})}};return{BlockStatement:x,IfStatement:v,Program:x}},meta:{docs:{description:"Enforce proper spacing between if statements and if-else chains"},fixable:"whitespace",schema:[],type:"layout"}},Ze={create(e){let n=e.sourceCode||e.getSourceCode(),I=e.options[0]||{},v=I.maxOperands!==void 0?I.maxOperands:3,x=2,r=l=>{let a=n.getTokenBefore(l),u=n.getTokenAfter(l);if(!a||!u)return!1;if(a.value==="("&&u.value===")"){if(l.parent.type==="IfStatement"&&l.parent.test===l){let T=n.getTokenBefore(a);if(T&&T.value==="if")return!1}return!0}return!1},d=l=>{let a=l.range[0],u=l.range[1],T=n.getTokenBefore(l),y=n.getTokenAfter(l);for(;T&&T.value==="("&&y&&y.value===")";){if(l.parent.type==="IfStatement"&&l.parent.test===l){let b=n.getTokenBefore(T);if(b&&b.value==="if")break}a=T.range[0],u=y.range[1],T=n.getTokenBefore(T),y=n.getTokenAfter(y)}return n.text.slice(a,u)},i=l=>{let a=[],u=T=>{T.type==="LogicalExpression"&&!r(T)?(u(T.left),u(T.right)):a.push(T)};return u(l),a},s=(l,a=0)=>{if(l.type!=="LogicalExpression")return a;let u=a;if(l.left.type==="LogicalExpression"){let T=r(l.left)?s(l.left,a+1):s(l.left,a);u=Math.max(u,T)}if(l.right.type==="LogicalExpression"){let T=r(l.right)?s(l.right,a+1):s(l.right,a);u=Math.max(u,T)}return u},c=(l,a=0,u=null)=>{if(l.type!=="LogicalExpression")return null;let T=null;if(l.left.type==="LogicalExpression"){let y=r(l.left),b=y?a+1:a;y&&b>x&&(T={node:l.left,depth:b,parent:l,side:"left"});let m=c(l.left,b,{node:l,side:"left"});m&&(!T||m.depth>T.depth)&&(T=m)}if(l.right.type==="LogicalExpression"){let y=r(l.right),b=y?a+1:a;if(y&&b>x){let k={node:l.right,depth:b,parent:l,side:"right"};(!T||k.depth>T.depth)&&(T=k)}let m=c(l.right,b,{node:l,side:"right"});m&&(!T||m.depth>T.depth)&&(T=m)}return T},o=l=>{if(l.type!=="LogicalExpression")return 1;let a=0,u=T=>{T.type==="LogicalExpression"&&!r(T)?(u(T.left),u(T.right)):a+=1};return u(l.left),u(l.right),a},t=l=>{if(l.type!=="LogicalExpression")return null;if(r(l)&&o(l)>v)return l;if(l.left.type==="LogicalExpression"){let a=t(l.left);if(a)return a}if(l.right.type==="LogicalExpression"){let a=t(l.right);if(a)return a}return null};return{IfStatement:l=>{let{test:a}=l;if(a.type!=="LogicalExpression")return;let u=i(a),T=n.getTokenBefore(a),y=n.getTokenAfter(a);if(!T||!y)return;let b=s(a);if(b>x){let C=c(a);if(C){let g=d(C.node),f=$=>{if($.type==="LogicalExpression"){let P=f($.left),R=f($.right),F=$.operator==="&&"?"And":"Or";return`${P}${F}${R}`}return $.type==="Identifier"?$.name.charAt(0).toUpperCase()+$.name.slice(1):$.type==="BinaryExpression"||$.type==="CallExpression"||$.type==="MemberExpression"?"Expr":"Cond"},S=`is${f(C.node)}`;S.length>30&&(S="isNestedCondition"),e.report({fix:$=>{let P=[],R=l.loc.start.line,F=n.getIndexFromLoc({line:R,column:0}),j=n.lines[R-1].match(/^\s*/)[0];P.push($.insertTextBeforeRange([F,F],`const ${S} = ${g};
${j}`));let H=n.getTokenBefore(C.node),M=n.getTokenAfter(C.node);return H&&M&&H.value==="("&&M.value===")"?P.push($.replaceTextRange([H.range[0],M.range[1]],S)):P.push($.replaceText(C.node,S)),P},message:`Condition nesting depth (${b}) exceeds maximum (${x}). Extract deeply nested condition to a variable.`,node:C.node});return}}let m=T.loc.start.line!==y.loc.end.line,k=C=>{if(C.type!=="BinaryExpression")return!1;let{left:g,right:f}=C;return!!(g.loc.end.line!==f.loc.start.line||k(g)||k(f))},A=C=>{if(C.type==="BinaryExpression"){let g=A(C.left),f=A(C.right);return`${g} ${C.operator} ${f}`}return n.getText(C)},w=t(a);if(w){let g=n.lines[l.loc.start.line-1].match(/^\s*/)[0],f=g+"    ",S=(B,j=!1,H=f)=>{if(B.type==="LogicalExpression"&&(j||!r(B))){let M=S(B.left,!1,H),D=S(B.right,!1,H);return`${M}
${H}${B.operator} ${D}`}if(B.type==="LogicalExpression"&&r(B)&&o(B)>v){let D=H+"    ",J=K=>{if(K.type==="LogicalExpression"&&!r(K)){let ee=J(K.left),X=J(K.right);return`${ee}
${D}${K.operator} ${X}`}return d(K)},_=J(B.left),W=J(B.right);return`(
${D}${_}
${D}${B.operator} ${W}
${H})`}return d(B)},$=(B,j)=>{if(B===j){let H=S(B,!0);return`(
${f}${H}
${g})`}if(B.type==="LogicalExpression"&&!r(B)){let H=$(B.left,j),M=$(B.right,j);return`${H} ${B.operator} ${M}`}if(B.type==="LogicalExpression"&&r(B)){let H=(M,D)=>M===D?!0:M.type==="LogicalExpression"?H(M.left,D)||H(M.right,D):!1;if(H(B,j))return`(${$(B,j)})`}return d(B)},R=(B=>{let j=[],H=M=>{M.type==="LogicalExpression"&&!r(M)?(H(M.left),H(M.right)):j.push(M)};return B.type==="LogicalExpression"&&(H(B.left),H(B.right)),j})(w);if(!R.every((B,j)=>j===0?!0:B.loc.start.line!==R[j-1].loc.start.line)){e.report({fix:B=>{let j=$(a,w);return B.replaceTextRange([T.range[1],y.range[0]],j)},message:`Nested condition with >${v} operands should be formatted multiline`,node:w});return}}if(u.length<=v){if(t(a))return;let g=u[0].loc.start.line,f=u.every($=>$.loc.start.line===g),S=u.some($=>k($));(!f||S)&&e.report({fix:$=>{let P=R=>{if(R.type==="LogicalExpression"&&!r(R)){let F=P(R.left),B=P(R.right);return`${F} ${R.operator} ${B}`}return R.type==="BinaryExpression"&&k(R)?A(R):d(R)};return $.replaceTextRange([T.range[0],y.range[1]],`(${P(a)})`)},message:`If conditions with \u2264${v} operands should be single line: if (a && b && c). Multi-line only for >${v} operands`,node:a});return}let E=C=>{if(C.type!=="LogicalExpression")return!1;let g=n.getTokenAfter(C.left,f=>f.value==="||"||f.value==="&&");if(g){let f=n.getTokenAfter(g);if(f&&g.loc.end.line<f.loc.start.line)return!0}return!!(E(C.left)||E(C.right))},L=!m;if(m){for(let C=0;C<u.length-1;C+=1)if(u[C].loc.end.line===u[C+1].loc.start.line){L=!0;break}T.loc.end.line===u[0].loc.start.line&&(L=!0),!L&&E(a)&&(L=!0)}L&&e.report({fix:C=>{let f=n.lines[l.loc.start.line-1].match(/^\s*/)[0],S=f+"    ",$=S+"    ",P=(R,F)=>{if(R.type==="LogicalExpression"&&!r(R)){let B=P(R.left,F),j=P(R.right,F);return`${B}
${F}${R.operator} ${j}`}if(R.type==="LogicalExpression"&&r(R)&&o(R)>v){let j=F+"    ",H=J=>{if(J.type==="LogicalExpression"&&!r(J)){let _=H(J.left),W=H(J.right);return`${_}
${j}${J.operator} ${W}`}return d(J)},M=H(R.left),D=H(R.right);return`(
${j}${M}
${j}${R.operator} ${D}
${F})`}return d(R)};return C.replaceTextRange([T.range[0],y.range[1]],`(
${S}${P(a,S)}
${f})`)},message:`If conditions with more than ${v} operands should be multiline, with each operand on its own line`,node:a})},Property:l=>{let{value:a}=l;if(!a||a.type!=="LogicalExpression")return;let u=i(a);if(u.length<2)return;let T=a.loc.start.line,y=a.loc.end.line,b=T!==y,m=E=>{if(E.type!=="BinaryExpression")return!1;let{left:L,right:C}=E;return!!(L.loc.end.line!==C.loc.start.line||m(L)||m(C))},k=E=>{if(E.type==="BinaryExpression"){let L=k(E.left),C=k(E.right);return`${L} ${E.operator} ${C}`}return n.getText(E)},A=t(a);if(u.length<=v&&!A){let E=u[0].loc.start.line,L=u.every(g=>g.loc.start.line===E),C=u.some(g=>m(g));(!L||C)&&e.report({fix:g=>{let f=S=>{if(S.type==="LogicalExpression"&&!r(S)){let $=f(S.left),P=f(S.right);return`${$} ${S.operator} ${P}`}return S.type==="BinaryExpression"&&m(S)?k(S):d(S)};return g.replaceText(a,f(a))},message:`Property conditions with \u2264${v} operands should be single line: condition: a && b && c. Multi-line only for >${v} operands`,node:a});return}let w=!b;if(b){for(let E=0;E<u.length-1;E+=1)if(u[E].loc.end.line===u[E+1].loc.start.line){w=!0;break}}w&&e.report({fix:E=>{let g=n.lines[l.loc.start.line-1].match(/^\s*/)[0]+"    ",f=S=>{if(S.type==="LogicalExpression"&&!r(S)){let $=f(S.left),P=f(S.right);return`${$}
${g}${S.operator} ${P}`}return d(S)};return E.replaceText(a,f(a))},message:`Property conditions with more than ${v} operands should be multiline, with each operand on its own line`,node:a})}}},meta:{docs:{description:"Enforce multiline if/property conditions when exceeding threshold (default: >3 operands)"},fixable:"whitespace",schema:[{additionalProperties:!1,properties:{maxOperands:{default:3,description:"Maximum operands to keep on single line (default: 3). Also applies to nested groups.",minimum:1,type:"integer"}},type:"object"}],type:"layout"}},Ke={create(e){let n=e.sourceCode||e.getSourceCode(),v=(e.options[0]||{}).maxOperands??3,x=2,r=g=>{let f=n.getTokenBefore(g),S=n.getTokenAfter(g);return!f||!S?!1:f.value==="("&&S.value===")"},d=g=>{let f=g.range[0],S=g.range[1],$=n.getTokenBefore(g),P=n.getTokenAfter(g);for(;$&&$.value==="("&&P&&P.value===")";)f=$.range[0],S=P.range[1],$=n.getTokenBefore($),P=n.getTokenAfter(P);return n.text.slice(f,S)},i=g=>{let f=[],S=$=>{$.type==="LogicalExpression"&&!r($)?(S($.left),S($.right)):f.push($)};return S(g),f},s=(g,f=0)=>{if(g.type!=="LogicalExpression")return f;let S=f;if(g.left.type==="LogicalExpression"){let $=r(g.left)?s(g.left,f+1):s(g.left,f);S=Math.max(S,$)}if(g.right.type==="LogicalExpression"){let $=r(g.right)?s(g.right,f+1):s(g.right,f);S=Math.max(S,$)}return S},c=(g,f=0)=>{if(g.type!=="LogicalExpression")return null;let S=null;if(g.left.type==="LogicalExpression"){let $=r(g.left),P=$?f+1:f;$&&P>x&&(S={node:g.left,depth:P,parent:g,side:"left"});let R=c(g.left,P);R&&(!S||R.depth>S.depth)&&(S=R)}if(g.right.type==="LogicalExpression"){let $=r(g.right),P=$?f+1:f;if($&&P>x){let F={node:g.right,depth:P,parent:g,side:"right"};(!S||F.depth>S.depth)&&(S=F)}let R=c(g.right,P);R&&(!S||R.depth>S.depth)&&(S=R)}return S},o=g=>{if(g.type==="LogicalExpression"){let f=o(g.left),S=o(g.right),$=g.operator==="&&"?"And":"Or";return`${f}${$}${S}`}return g.type==="Identifier"?g.name.charAt(0).toUpperCase()+g.name.slice(1):g.type==="BinaryExpression"||g.type==="CallExpression"||g.type==="MemberExpression"?"Expr":"Cond"},t=g=>{if(g.type!=="LogicalExpression")return 1;let f=0,S=$=>{$.type==="LogicalExpression"&&!r($)?(S($.left),S($.right)):f+=1};return S(g.left),S(g.right),f},h=g=>{if(g.type!=="LogicalExpression")return null;if(r(g)&&t(g)>v)return g;if(g.left.type==="LogicalExpression"){let f=h(g.left);if(f)return f}if(g.right.type==="LogicalExpression"){let f=h(g.right);if(f)return f}return null},p=g=>{if(g.type!=="BinaryExpression")return!1;let{left:f,right:S}=g;return!!(f.loc.end.line!==S.loc.start.line||p(f)||p(S))},l=g=>{if(g.type==="BinaryExpression"){let f=l(g.left),S=l(g.right);return`${f} ${g.operator} ${S}`}return n.getText(g)},a=g=>{if(g.type!=="LogicalExpression")return!1;let f=n.getTokenAfter(g.left,S=>S.value==="||"||S.value==="&&");if(f){let S=n.getTokenAfter(f);if(S&&f.loc.end.line<S.loc.start.line)return!0}return!!(a(g.left)||a(g.right))},u=g=>{if(g.type==="Identifier"||g.type==="MemberExpression"||g.type==="UnaryExpression"||g.type==="BinaryExpression"||g.type==="CallExpression")return!0;if(g.type==="LogicalExpression"){let f=i(g).length,S=h(g);return f<=v&&!S}return!1},T=g=>{let f=n.getText(g.test).replace(/\s+/g," ").trim(),S=d(g.consequent).replace(/\s+/g," ").trim(),$=d(g.alternate).replace(/\s+/g," ").trim();return`${f} ? ${S} : ${$}`},y=g=>n.lines[g.loc.start.line-1].match(/^\s*/)[0].length,b=g=>g?g.type==="JSXElement"||g.type==="JSXFragment"?!0:g.type==="ParenthesizedExpression"?b(g.expression):g.type==="ConditionalExpression"?b(g.consequent)||b(g.alternate):g.type==="LogicalExpression"?b(g.left)||b(g.right):!1:!1,m=g=>g.type==="ObjectExpression"&&g.properties.length>=2||g.type==="ArrayExpression"&&g.elements.length>=3,k=g=>b(g.consequent)||b(g.alternate),A=g=>{let f=S=>S.type==="ConditionalExpression"&&r(S)?i(S.test).length>v:!1;return f(g.consequent)||f(g.alternate)},w=g=>{let f=n.getTokenAfter(g.test,$=>$.value==="?"),S=n.getTokenAfter(g.consequent,$=>$.value===":");return!!(f&&g.consequent.loc.start.line!==f.loc.start.line||S&&g.alternate.loc.start.line!==S.loc.start.line)},E=g=>{let f=g.loc.start.line===g.loc.end.line,S=w(g);if(g.consequent.type==="ConditionalExpression"&&!r(g.consequent)||g.alternate.type==="ConditionalExpression"&&!r(g.alternate)||m(g.consequent)||m(g.alternate)||k(g)||A(g)||f&&!S)return!1;let P=T(g);return e.report({fix:R=>R.replaceText(g,P),message:`Ternary with \u2264${v} operands should be on a single line`,node:g}),!0},L=g=>{let{test:f}=g,S=i(f),$=f.loc.start.line,P=f.loc.end.line,R=$!==P,F=h(f);if(F){let H=g.parent,M="";H&&H.loc&&(M=n.lines[H.loc.start.line-1].match(/^\s*/)[0]);let D=M+"    ",J=(X,q=!1,V=D)=>{if(X.type==="LogicalExpression"&&(q||!r(X))){let U=J(X.left,!1,V),Y=J(X.right,!1,V);return`${U}
${V}${X.operator} ${Y}`}if(X.type==="LogicalExpression"&&r(X)&&t(X)>v){let Y=V+"    ",le=z=>{if(z.type==="LogicalExpression"&&!r(z)){let Z=le(z.left),Q=le(z.right);return`${Z}
${Y}${z.operator} ${Q}`}return d(z)},O=le(X.left),N=le(X.right);return`(
${Y}${O}
${Y}${X.operator} ${N}
${V})`}return d(X)},_=(X,q)=>{if(X===q){let V=J(X,!0);return`(
${D}${V}
${M})`}if(X.type==="LogicalExpression"&&!r(X)){let V=_(X.left,q),U=_(X.right,q);return`${V} ${X.operator} ${U}`}if(X.type==="LogicalExpression"&&r(X)){let V=(U,Y)=>U===Y?!0:U.type==="LogicalExpression"?V(U.left,Y)||V(U.right,Y):!1;if(V(X,q))return`(${_(X,q)})`}return d(X)},K=(X=>{let q=[],V=U=>{U.type==="LogicalExpression"&&!r(U)?(V(U.left),V(U.right)):q.push(U)};return X.type==="LogicalExpression"&&(V(X.left),V(X.right)),q})(F);if(!K.every((X,q)=>q===0?!0:X.loc.start.line!==K[q-1].loc.start.line)){let X=_(f,F),q=d(g.consequent).replace(/\s+/g," ").trim(),V=d(g.alternate).replace(/\s+/g," ").trim();e.report({fix:U=>U.replaceText(g,`${X} ? ${q} : ${V}`),message:`Nested condition with >${v} operands should be formatted multiline`,node:F});return}}if(S.length<=v){if(h(f))return;let M=m(g.consequent)||m(g.alternate);if(k(g))return;let D=g.consequent.type==="ConditionalExpression"&&!r(g.consequent)||g.alternate.type==="ConditionalExpression"&&!r(g.alternate);if(M||D||A(g))return;let J=g.loc.start.line===g.loc.end.line,_=w(g);if(J&&!_)return;let W=T(g);e.report({fix:K=>K.replaceText(g,W),message:`Ternary with \u2264${v} operands should be on a single line`,node:g});return}let B=!R,j=g.parent;if(R){for(let H=0;H<S.length-1;H+=1)if(S[H].loc.end.line===S[H+1].loc.start.line){B=!0;break}if(!B&&a(f)&&(B=!0),!B){let H=n.getTokenAfter(f,M=>M.value==="?");H&&H.loc.start.line===f.loc.end.line&&(B=!0)}if(!B){let H=n.getTokenAfter(f,M=>M.value==="?");H&&H.loc.start.line>f.loc.end.line+1&&(B=!0)}if(!B){let H=n.getTokenAfter(g.consequent,M=>M.value===":");H&&H.loc.start.line>g.consequent.loc.end.line+1&&(B=!0)}if(!B&&w(g)&&(B=!0),!B){let H=n.getTokenAfter(f,D=>D.value==="?"),M=n.getTokenAfter(g.consequent,D=>D.value===":");H&&M&&H.loc.start.line===M.loc.start.line&&(B=!0)}if(!B&&j&&j.type==="Property"&&j.value===g){let H=j.key.loc.end.line;S[0].loc.start.line!==H&&(B=!0)}}B&&e.report({fix:H=>{let M,D=!1,J="";if(j&&j.type==="Property"&&j.value===g){let V=j.key.loc.end.line;S[0].loc.start.line!==V&&(D=!0,J=n.getText(j.key)+": ",M=n.lines[j.loc.start.line-1].match(/^\s*/)[0])}M||(M=n.lines[g.loc.start.line-1].match(/^\s*/)[0]);let _=M+"    ",W=V=>{if(V.type==="LogicalExpression"&&!r(V)){let U=W(V.left),Y=W(V.right);return`${U}
${_}${V.operator} ${Y}`}return d(V)},K=n.getText(g.consequent),ee=n.getText(g.alternate),q=`${W(f)}
${_}? ${K}
${_}: ${ee}`;return D?H.replaceTextRange([j.key.range[0],g.range[1]],`${J}${q}`):H.replaceText(g,q)},message:`Ternary conditions with more than ${v} operands should be multiline, with each operand on its own line`,node:f})},C=g=>{let f=g.parent;for(;f&&f.type==="ParenthesizedExpression";)f=f.parent;return f&&f.type==="ConditionalExpression"?f.consequent===g||f.alternate===g||g.parent.type==="ParenthesizedExpression"&&(f.consequent===g.parent||f.alternate===g.parent):!1};return{ConditionalExpression(g){let{test:f}=g;if(!C(g)){if(f.type==="LogicalExpression"){let S=s(f);if(S>x){let $=c(f);if($){let P=d($.node),R=`is${o($.node)}`;R.length>30&&(R="isNestedCondition"),e.report({fix:F=>{let B=[],j=g;for(;j.parent&&j.parent.type!=="Program"&&j.parent.type!=="BlockStatement";)j=j.parent;let H=j.loc.start.line,M=n.getIndexFromLoc({line:H,column:0}),J=n.lines[H-1].match(/^\s*/)[0];B.push(F.insertTextBeforeRange([M,M],`const ${R} = ${P};
${J}`));let _=n.getTokenBefore($.node),W=n.getTokenAfter($.node);return _&&W&&_.value==="("&&W.value===")"?B.push(F.replaceTextRange([_.range[0],W.range[1]],R)):B.push(F.replaceText($.node,R)),B},message:`Ternary condition nesting depth (${S}) exceeds maximum (${x}). Extract deeply nested condition to a variable.`,node:$.node});return}}}u(f)&&E(g)||f.type==="LogicalExpression"&&L(g)}}}},meta:{docs:{description:"Enforce consistent ternary formatting based on condition operand count: \u2264maxOperands collapses to single line, >maxOperands expands to multiline"},fixable:"code",schema:[{additionalProperties:!1,properties:{maxOperands:{default:3,description:"Maximum condition operands to keep ternary on single line (default: 3). Also applies to nested groups.",minimum:1,type:"integer"}},type:"object"}],type:"layout"}},Ge={create(e){let n=e.sourceCode||e.getSourceCode(),I=e.options[0]||{},v=I.maxOperands!==void 0?I.maxOperands:3,x=o=>{let t=n.getTokenBefore(o),h=n.getTokenAfter(o);return!t||!h?!1:t.value==="("&&h.value===")"},r=o=>{let t=[],h=p=>{p.type==="LogicalExpression"&&!x(p)?(h(p.left),h(p.right)):t.push(p)};return h(o),t},d=(o,t)=>{let p=n.getTokensBetween(o,t).find(l=>l.value==="||"||l.value==="&&"||l.value==="??"||l.value==="|"||l.value==="&");return p?p.value:"||"},i=o=>o.loc.start.line!==o.loc.end.line,s=o=>{let t=o.parent;for(;t;){if(t.type==="IfStatement"&&t.test===o||t.type==="ConditionalExpression"&&t.test===o)return!0;if(t.type.includes("Statement")||t.type.includes("Declaration"))return!1;t=t.parent}return!1};return{LogicalExpression:o=>{if(o.parent.type==="LogicalExpression"&&!x(o)||s(o))return;let t=r(o);if(t.length<=v){if(i(o)){if(t.some(p=>p.loc.start.line!==p.loc.end.line))return;e.report({fix(p){let l=[n.getText(t[0])];for(let a=1;a<t.length;a++){let u=d(t[a-1],t[a]);l.push(` ${u} ${n.getText(t[a])}`)}return p.replaceText(o,l.join(""))},message:`Logical expression with ${t.length} operands should be on a single line (max for multiline: ${v})`,node:o})}return}if(i(o)){let h=!0;for(let p=1;p<t.length;p++)if(t[p].loc.start.line===t[p-1].loc.end.line){h=!1;break}if(h)return}e.report({fix(h){let p=n.getText(t[0]),l=n.getFirstToken(t[0]),a=n.text.lastIndexOf(`
`,l.range[0])+1,T=n.text.slice(a,l.range[0]).match(/^(\s*)/),y=T?T[1]:"",b=[p];for(let k=1;k<t.length;k++){let A=d(t[k-1],t[k]),w=n.getText(t[k]);b.push(`${y}    ${A} ${w}`)}let m=b.join(`
`);return h.replaceText(o,m)},message:`Logical expression with ${t.length} operands should be on multiple lines (max: ${v})`,node:o})}}},meta:{docs:{description:"Enforce single line for \u2264maxOperands, multiline for >maxOperands logical expressions"},fixable:"code",schema:[{additionalProperties:!1,properties:{maxOperands:{default:3,description:"Maximum operands to keep on single line (default: 3)",minimum:1,type:"integer"}},type:"object"}],type:"layout"}},Ye={create(e){let n=e.sourceCode||e.getSourceCode(),I=x=>["IfStatement","ForStatement","ForInStatement","ForOfStatement","WhileStatement","DoWhileStatement","TryStatement","SwitchStatement","WithStatement"].includes(x.type),v=x=>{if(x.type==="IfStatement"&&x.alternate)return v(x.alternate);if(x.type==="TryStatement"){if(x.finalizer)return x.finalizer.loc.end.line;if(x.handler)return x.handler.loc.end.line}return x.loc.end.line};return{"BlockStatement:exit"(x){let r=x.parent;if(!r||!I(r)||r.type==="IfStatement"&&r.consequent===x&&r.alternate||r.type==="TryStatement"&&(r.block===x||r.handler?.body===x)&&(r.handler||r.finalizer)&&(r.block===x&&(r.handler||r.finalizer)||r.handler?.body===x&&r.finalizer))return;let d=r.parent;if(!d||d.type!=="BlockStatement")return;let i=d.body.indexOf(r);if(i===-1||i===d.body.length-1)return;let s=d.body[i+1];if(r.type==="IfStatement"&&s.type==="IfStatement")return;let c=v(r);s.loc.start.line-c<2&&e.report({fix:t=>{let h=n.getLastToken(r);return t.insertTextAfter(h,`
`)},message:"Expected empty line after block statement",node:s})}}},meta:{docs:{description:"Require empty line between block statement closing brace and next statement"},fixable:"whitespace",schema:[],type:"layout"}},Qe={create(e){let n=e.sourceCode||e.getSourceCode();return{SwitchCase:x=>{let{consequent:r,test:d}=x,i=n.getTokenAfter(d||n.getFirstToken(x),s=>s.value===":");if(r.length>0){let s=r[0];n.getTokensBetween(i,s,{includeComments:!0}).length===0&&s.loc.start.line-i.loc.end.line>1&&e.report({fix(o){return o.replaceTextRange([i.range[1],s.range[0]],`
${" ".repeat(s.loc.start.column)}`)},message:"Empty line not allowed at the beginning of case logic",node:s})}},SwitchStatement:x=>{let{cases:r}=x;for(let d=0;d<r.length-1;d+=1){let i=r[d],s=r[d+1];if(i.consequent.length===0){let c=n.getTokenAfter(i.test||n.getFirstToken(i),t=>t.value===":");n.getTokensBetween(c,s,{includeComments:!0}).length===0&&s.loc.start.line-c.loc.end.line>1&&e.report({fix(t){return t.replaceTextRange([c.range[1],s.range[0]],`
${" ".repeat(s.loc.start.column)}`)},message:"Empty line not allowed between cases",node:s})}}}}},meta:{docs:{description:"Prevent empty lines at the beginning of switch case logic or between cases"},fixable:"whitespace",schema:[],type:"layout"}};var et={create(e){let n=e.sourceCode||e.getSourceCode(),I=(v,x)=>{let r=n.getLastToken(x);if(v.typeArguments||v.typeParameters){let s=v.typeArguments||v.typeParameters,c=n.getFirstToken(s);if(c&&c.value==="<"){let h=n.text.slice(r.range[1],c.range[0]);/\s/.test(h)&&e.report({fix:p=>p.replaceTextRange([r.range[1],c.range[0]],""),message:"No space between function name and generic type arguments",node:c})}let o=n.getLastToken(s),t=n.getTokenAfter(s);if(t&&t.value==="("){let h=n.text.slice(o.range[1],t.range[0]);/\s/.test(h)&&e.report({fix:p=>p.replaceTextRange([o.range[1],t.range[0]],""),message:"No space between generic type arguments and opening parenthesis",node:t})}return}let d=n.getTokenAfter(x);if(!d||d.value!=="(")return;n.text.slice(r.range[1],d.range[0]).length>0&&e.report({fix:s=>s.replaceTextRange([r.range[1],d.range[0]],""),message:"No space between function name and opening parenthesis",node:d})};return{CallExpression(v){I(v,v.callee)},NewExpression(v){I(v,v.callee)}}},meta:{docs:{description:"Enforce no space between function name and opening parenthesis"},fixable:"code",schema:[],type:"layout"}},tt={create(e){let n=e.sourceCode||e.getSourceCode();return{FunctionDeclaration(I){if(!I.id)return;let v=I.id.name,x=I.params.map(p=>n.getText(p)).join(", "),r="";I.returnType&&(r=n.getText(I.returnType));let d="";if(I.typeParameters){let p=n.getText(I.typeParameters);if(I.typeParameters.params&&I.typeParameters.params.length===1){let l=p.slice(1,-1).trim();l.endsWith(",")?d=p:d=`<${l},>`}else d=p}let s=I.async?"async ":"",c=n.getText(I.body),o=I.parent,t=o&&o.type==="ExportNamedDeclaration",h=t?"export ":"";e.report({fix(p){let l=t?o:I,a=`${h}const ${v} = ${d}${s}(${x})${r} => ${c};`;return p.replaceText(l,a)},message:`Expected a function expression. Use \`const ${v} = ${d}${s}(${x})${r} => ...\` instead.`,node:I.id})}}},meta:{docs:{description:"Enforce arrow function expressions instead of function declarations"},fixable:"code",schema:[],type:"suggestion"}},nt={create(e){let n=/^[A-Z][a-zA-Z0-9]*$/,I=/Handler$/,v=/^use[A-Z]/,x=["get","set","fetch","load","save","create","update","delete","remove","add","insert","append","prepend","push","pop","shift","unshift","put","patch","is","has","can","should","will","did","was","were","does","do","check","validate","verify","confirm","ensure","assert","test","match","find","search","filter","sort","map","reduce","merge","split","join","query","lookup","locate","detect","identify","discover","scan","probe","parse","format","convert","transform","normalize","serialize","deserialize","encode","decode","encrypt","decrypt","hash","sign","compress","decompress","stringify","objectify","flatten","unflatten","transpose","invert","strip","trim","pad","wrap","unwrap","sanitize","escape","unescape","capitalize","lowercase","uppercase","camel","snake","kebab","truncate","replace","substitute","interpolate","template","render","display","show","hide","toggle","enable","disable","activate","deactivate","highlight","focus","blur","select","deselect","expand","collapse","resize","animate","transition","fade","slide","zoom","rotate","scale","open","close","start","stop","init","setup","reset","clear","destroy","mount","unmount","attach","detach","bind","unbind","dispose","cleanup","register","unregister","install","uninstall","configure","reconfigure","connect","disconnect","subscribe","unsubscribe","listen","emit","broadcast","send","receive","request","respond","submit","cancel","abort","poll","download","upload","import","export","sync","stream","pipe","read","write","copy","move","clone","extract","archive","restore","backup","build","make","generate","compute","calculate","process","execute","run","evaluate","analyze","measure","benchmark","profile","optimize","count","sum","avg","min","max","clamp","round","floor","ceil","abs","increment","decrement","multiply","divide","mod","negate","apply","call","invoke","trigger","fire","dispatch","emit","raise","signal","login","logout","authenticate","authorize","grant","revoke","permit","deny","navigate","redirect","route","scroll","jump","go","back","forward","refresh","reload","restore","log","warn","error","debug","trace","print","dump","inspect","throw","catch","resolve","reject","retry","await","recover","fallback","forgot","debounce","throttle","memoize","cache","batch","queue","defer","delay","schedule","preload","prefetch","lazy","on","click","change","input","press","drag","drop","hover","enter","leave","touch","swipe","pinch","tap","compare","diff","equal","differ","overlap","intersect","union","exclude","group","ungroup","partition","chunk","segment","categorize","classify","order","reorder","arrange","reverse","shuffle","randomize","pick","sample","lock","unlock","freeze","unfreeze","seal","mark","unmark","flag","unflag","use","require","need","want","try","attempt","ensure","guarantee","prepare","finalize","complete","finish","end","begin","continue","resume","pause","suspend","interrupt","break","skip","ignore","include","exclude","accept","decline","approve","reject","confirm","dismiss","acknowledge","assign","allocate","distribute","collect","gather","aggregate","accumulate","populate","fill","empty","drain","flush","purge","prune","clean","sanitize","compose","decompose","assemble","disassemble","construct","deconstruct"],r=l=>x.some(a=>l.startsWith(a)),d=l=>{let a=l.toLowerCase();return x.some(u=>a.startsWith(u))},i=l=>l[0].toLowerCase()+l.slice(1),s=l=>I.test(l),c=l=>{if(!l)return!1;if(l.type==="JSXElement"||l.type==="JSXFragment")return!0;if(l.type==="BlockStatement"){for(let a of l.body)if(a.type==="ReturnStatement"&&a.argument&&c(a.argument)||a.type==="IfStatement"&&(c(a.consequent)||a.alternate&&c(a.alternate)))return!0}return l.type==="ConditionalExpression"?c(l.consequent)||c(l.alternate):l.type==="LogicalExpression"?c(l.left)||c(l.right):l.type==="ParenthesizedExpression"?c(l.expression):!1},o=(l,a)=>!a||!/^[A-Z]/.test(a)?!1:c(l.body),t=l=>{let a=null,u=null;if(l.type==="FunctionDeclaration"&&l.id)a=l.id.name,u=l.id;else if(l.type==="FunctionExpression"||l.type==="ArrowFunctionExpression"){if(l.parent&&l.parent.type==="VariableDeclarator"&&l.parent.id)a=l.parent.id.name,u=l.parent.id;else if(l.parent&&l.parent.type==="CallExpression"){let m=l.parent,k=m.callee;k&&k.type==="Identifier"&&k.name==="useCallback"&&m.arguments&&m.arguments[0]===l&&m.parent&&m.parent.type==="VariableDeclarator"&&m.parent.id&&(a=m.parent.id.name,u=m.parent.id)}}if(!a||!u||/^use[A-Z]/.test(a)||o(l,a))return;if(/^[A-Z]/.test(a)){if(d(a)){let m=i(a),k=l.id||l.parent.id;e.report({fix(A){let w=e.sourceCode?e.sourceCode.getScope(l):e.getScope(),E=w.variables.find(g=>g.name===a)||w.upper&&w.upper.variables.find(g=>g.name===a);if(!E)return A.replaceText(k,m);let L=[],C=new Set;return E.references.forEach(g=>{let f=`${g.identifier.range[0]}-${g.identifier.range[1]}`;C.has(f)||(C.add(f),L.push(A.replaceText(g.identifier,m)))}),L},message:`Function "${a}" should be camelCase. Use "${m}" instead of "${a}"`,node:l.id||l.parent.id})}return}let T=r(a),y=s(a);if(/^handle[A-Z]/.test(a)&&!y){let m=l.id||l.parent.id,k=a.slice(6),A=k[0].toLowerCase()+k.slice(1)+"Handler";e.report({fix(w){let E=e.sourceCode?e.sourceCode.getScope(l):e.getScope(),L=E.variables.find(S=>S.name===a)||E.upper&&E.upper.variables.find(S=>S.name===a);if(!L)return w.replaceText(m,A);let C=[],g=new Set,f=S=>{let $=`${S.range[0]}-${S.range[1]}`;g.has($)||(g.add($),C.push(w.replaceText(S,A)))};return L.defs.forEach(S=>{f(S.name)}),L.references.forEach(S=>{f(S.identifier)}),C},message:`Function "${a}" should be "${A}" (handleXxx \u2192 xxxHandler to avoid redundant "handleXxxHandler")`,node:m});return}if(!T&&!y)e.report({message:`Function "${a}" should start with a verb (get, set, fetch, etc.) AND end with "Handler" (e.g., getDataHandler, clickHandler)`,node:u});else if(!T)e.report({message:`Function "${a}" should start with a verb (get, set, fetch, handle, click, submit, etc.)`,node:u});else if(!y){let m=`${a}Handler`;e.report({fix(k){let A=e.sourceCode?e.sourceCode.getScope(l):e.getScope(),w=A.variables.find(g=>g.name===a)||A.upper&&A.upper.variables.find(g=>g.name===a);if(!w)return k.replaceText(u,m);let E=[],L=new Set,C=g=>{let f=`${g.range[0]}-${g.range[1]}`;L.has(f)||(L.add(f),E.push(k.replaceText(g,m)))};return w.defs.forEach(g=>{C(g.name)}),w.references.forEach(g=>{C(g.identifier)}),E},message:`Function "${a}" should end with "Handler" suffix (e.g., ${m})`,node:u})}};return{ArrowFunctionExpression:t,FunctionDeclaration:t,FunctionExpression:t,MethodDefinition:l=>{if(l.kind==="constructor"||l.kind==="get"||l.kind==="set")return;let{key:a}=l;if(a.type!=="Identifier")return;let u=a.name;if(/^use[A-Z]/.test(u)||["render","componentDidMount","componentDidUpdate","componentWillUnmount","shouldComponentUpdate","getSnapshotBeforeUpdate","componentDidCatch","getDerivedStateFromProps","getDerivedStateFromError"].includes(u))return;let y=r(u),b=s(u);if(!y&&!b)e.report({message:`Method "${u}" should start with a verb (get, set, fetch, handle, etc.) AND end with "Handler" (e.g., getDataHandler, handleClickHandler)`,node:a});else if(!y)e.report({message:`Method "${u}" should start with a verb (get, set, fetch, handle, click, submit, etc.)`,node:a});else if(!b){let m=`${u}Handler`;e.report({fix(k){let A=[k.replaceText(a,m)],w=l.parent;if(w&&w.type==="ClassBody"){let E=w.parent;if(E){let L=new Set,C=g=>{if(!g||typeof g!="object"||L.has(g))return;L.add(g),g.type==="MemberExpression"&&g.property&&g.property.type==="Identifier"&&g.property.name===u&&g.object&&(g.object.type==="ThisExpression"||g.object.type==="Super")&&g.property!==a&&A.push(k.replaceText(g.property,m));let f=["body","declarations","expression","left","right","callee","arguments","object","property","consequent","alternate","test","init","update","params","elements","properties","value","key","argument","block","handler","finalizer","cases"];for(let S of f){let $=g[S];$&&(Array.isArray($)?$.forEach(P=>C(P)):C($))}};C(E)}}return A},message:`Method "${u}" should end with "Handler" suffix (e.g., ${m})`,node:a})}},VariableDeclarator:l=>{if(!l.init||l.init.type!=="CallExpression"||!l.id||l.id.type!=="ObjectPattern")return;let a=l.init.callee;if(!a||a.type!=="Identifier"||!v.test(a.name))return;let u=["login","logout","authenticate","authorize","signup","signout","signin","submit","reset","clear","refresh","reload","retry","toggle","enable","disable","activate","deactivate","show","hide","open","close","expand","collapse","navigate","redirect","goBack","goForward","increment","decrement","increase","decrease","connect","disconnect","subscribe","unsubscribe","start","stop","pause","resume","cancel","abort","select","deselect","check","uncheck","add","remove","insert","delete","update"];l.id.properties.forEach(T=>{if(T.type!=="Property"||T.key.type!=="Identifier")return;let y=T.key.name,b=T.value||T.key,m=b.type==="Identifier"?b.name:y;if(/^on[A-Z]/.test(m)||/Action$/.test(m)||I.test(m)||["is","has","can","should","will","did","was","were","does"].some(E=>m.startsWith(E)&&m.length>E.length&&/[A-Z]/.test(m[E.length]))||!u.some(E=>m===E||m.startsWith(E)&&m.length>E.length&&/[A-Z]/.test(m[E.length])))return;let w=m+"Handler";e.report({fix(E){let L=[],C=e.sourceCode||e.getSourceCode();T.shorthand?L.push(E.replaceText(T,`${y}: ${w}`)):L.push(E.replaceText(b,w));let g=C.getScope?C.getScope(l):e.getScope(),f=($,P)=>{let R=$.variables.find(F=>F.name===P);return R||($.upper?f($.upper,P):null)},S=f(g,m);if(S){let $=new Set;b.range&&$.add(`${b.range[0]}-${b.range[1]}`),S.references.forEach(P=>{let R=`${P.identifier.range[0]}-${P.identifier.range[1]}`;$.has(R)||($.add(R),L.push(E.replaceText(P.identifier,w)))})}return L},message:`Function "${m}" destructured from hook should end with "Handler" suffix. Use "${w}" instead`,node:b})})}}},meta:{docs:{description:"Enforce function and method names to start with a verb AND end with Handler"},fixable:"code",schema:[],type:"suggestion"}},rt={create(e){let n=e.sourceCode||e.getSourceCode(),I=s=>{if(s.type==="ObjectPattern"){let o=`{ ${s.properties.map(t=>{if(t.type==="RestElement")return`...${I(t.argument)}`;let h=n.getText(t.key),p;return t.value?t.value.type==="ObjectPattern"||t.value.type==="ArrayPattern"||t.value.type==="AssignmentPattern"?p=I(t.value):p=n.getText(t.value).replace(/\s+/g," ").trim():p=h,t.shorthand||t.value&&t.value.type==="Identifier"&&t.value.name===t.key.name?t.value&&t.value.type==="AssignmentPattern"?p:h:`${h}: ${p}`}).join(", ")} }`;if(s.typeAnnotation){let t=n.getText(s.typeAnnotation),h=s.typeAnnotation.typeAnnotation;if(h){let p=null;if(h.type==="TSTypeLiteral")p=h.members;else if(h.type==="TSIntersectionType"){let l=h.types.find(a=>a.type==="TSTypeLiteral");l&&(p=l.members)}p&&p.length===1&&(t=t.replace(/\s+/g," ").trim().replace(/,\s*}/," }").replace(/,\s*&/," &"))}o+=t}return o}if(s.type==="ArrayPattern")return`[${s.elements.map(o=>o===null?"":I(o)).join(", ")}]`;if(s.type==="AssignmentPattern"){let c=I(s.left),o=n.getText(s.right).replace(/\s+/g," ").trim();return`${c} = ${o}`}return s.type==="RestElement"?`...${I(s.argument)}`:n.getText(s).replace(/\s+/g," ").trim()},v=s=>{if(!s)return!1;if(s.type==="AssignmentPattern")return v(s.left);if(s.type==="ObjectPattern"){if(s.properties.length>=2)return!0;if(s.typeAnnotation&&s.typeAnnotation.typeAnnotation){let c=s.typeAnnotation.typeAnnotation;if(c.type==="TSTypeLiteral"&&c.members.length>=2)return!0;if(c.type==="TSIntersectionType"){let o=c.types.find(t=>t.type==="TSTypeLiteral");if(o&&o.members.length>=2)return!0}}for(let c of s.properties)if(c.type==="Property"&&c.value&&v(c.value))return!0}if(s.type==="ArrayPattern"){let c=s.elements.filter(o=>o!==null);if(c.length>=2)return!0;for(let o of c)if(v(o))return!0}return!1},x=s=>s.some(c=>v(c)),r=(s,c)=>{let o=s;if(s.type==="AssignmentPattern"&&(o=s.left),o.type==="ObjectPattern"){let t=o.properties,h=t.some(b=>b.type==="Property"&&b.value?v(b.value):!1),p=t.length>=2||h;for(let b of t)if(b.type==="Property"&&b.value){let m=c+4;r(b.value,m)}if(!p)return;let l=n.getFirstToken(o),a=t[t.length-1],u=n.getTokenAfter(a);for(;u&&u.value!=="}";)u=n.getTokenAfter(u);let T=" ".repeat(c+4),y=" ".repeat(c);if(l.loc.end.line===t[0].loc.start.line&&e.report({fix:b=>b.replaceTextRange([l.range[1],t[0].range[0]],`
`+T),message:"First destructured property should be on its own line when complex destructuring",node:t[0]}),u.loc.start.line===t[t.length-1].loc.end.line){let b=o.typeAnnotation;e.report({fix:m=>b?m.replaceTextRange([t[t.length-1].range[1],u.range[1]],`,
`+y+"}"):m.replaceTextRange([t[t.length-1].range[1],u.range[0]],`,
`+y),message:"Closing brace should be on its own line when complex destructuring",node:u})}for(let b=0;b<t.length-1;b+=1){let m=t[b],k=t[b+1];if(m.loc.end.line===k.loc.start.line){let A=n.getTokenAfter(m,w=>w.value===",");e.report({fix:w=>w.replaceTextRange([A.range[1],k.range[0]],`
`+T),message:"Each destructured property should be on its own line when complex destructuring",node:k})}}}if(o.type==="ArrayPattern"){let t=o.elements.filter(u=>u!==null);for(let u of t)if(u){let T=c+4;r(u,T)}if(t.length<2)return;let h=n.getFirstToken(o),p=n.getLastToken(o),l=" ".repeat(c+4),a=" ".repeat(c);h.loc.end.line===t[0].loc.start.line&&e.report({fix:u=>u.replaceTextRange([h.range[1],t[0].range[0]],`
`+l),message:"First destructured element should be on its own line when 2+ elements",node:t[0]}),p.loc.start.line===t[t.length-1].loc.end.line&&e.report({fix:u=>u.replaceTextRange([t[t.length-1].range[1],p.range[0]],`,
`+a),message:"Closing bracket should be on its own line when 2+ elements",node:p});for(let u=0;u<t.length-1;u+=1){let T=t[u],y=t[u+1];if(T.loc.end.line===y.loc.start.line){let b=n.getTokenAfter(T,m=>m.value===",");e.report({fix:m=>m.replaceTextRange([b.range[1],y.range[0]],`
`+l),message:"Each destructured element should be on its own line when 2+ elements",node:y})}}}},d=s=>{if(s.type!=="ArrowFunctionExpression")return!1;let{parent:c}=s;return c&&c.type==="CallExpression"&&c.arguments.includes(s)},i=s=>{let c=s.params;if(c.length===0)return;let o=d(s),t=n.getFirstToken(s);for(;t&&t.value!=="(";)t=n.getTokenAfter(t);if(!t)return;let h=c[c.length-1],p=n.getTokenAfter(h,k=>k.value===")");if(!p)return;let l=c[0],a=t.loc.end.line!==p.loc.start.line,u=c.map(k=>I(k)).join(", "),T=n.text.slice(t.range[1],p.range[0]);if(o&&c.length>=2){let A=n.lines[t.loc.start.line-1].match(/^(\s*)/)[1].length,w=" ".repeat(A+4),E=" ".repeat(A);t.loc.end.line===l.loc.start.line&&e.report({fix:L=>L.replaceTextRange([t.range[1],l.range[0]],`
`+w),message:"Callback arrow with 2+ params: first param should be on its own line",node:l}),p.loc.start.line===h.loc.end.line&&e.report({fix:L=>L.replaceTextRange([h.range[1],p.range[0]],`,
`+E),message:"Callback arrow with 2+ params: closing paren should be on its own line",node:p});for(let L=0;L<c.length-1;L+=1){let C=c[L],g=c[L+1];if(C.loc.end.line===g.loc.start.line){let f=n.getTokenAfter(C,S=>S.value===",");e.report({fix:S=>S.replaceTextRange([f.range[1],g.range[0]],`
`+w),message:"Callback arrow with 2+ params: each param should be on its own line",node:g})}}for(let L of c){let C=L.loc.start.column;r(L,C)}return}if(o)return;if(c.length<=2&&!x(c)){let k=!a&&c.length>1&&T!==u;(a||k)&&e.report({fix:A=>A.replaceTextRange([t.range[1],p.range[0]],u),message:a?"Function parameters should be on same line when 2 or fewer without complex destructuring":"Missing space after comma between parameters",node:s});return}let y=" ".repeat(l.loc.start.column),b=" ".repeat(t.loc.start.column),m=c.length===1&&(l.type==="ObjectPattern"||l.type==="AssignmentPattern"&&l.left.type==="ObjectPattern");!m&&t.loc.end.line===l.loc.start.line&&e.report({fix:k=>k.replaceTextRange([t.range[1],l.range[0]],`
`+y),message:"First parameter should be on its own line when more than 2 parameters or has destructuring",node:l}),!m&&p.loc.start.line===h.loc.end.line&&e.report({fix:k=>k.replaceTextRange([h.range[1],p.range[0]],`,
`+b),message:"Closing parenthesis should be on its own line when more than 2 parameters or has destructuring",node:p});for(let k=0;k<c.length-1;k+=1){let A=c[k],w=c[k+1];if(A.loc.end.line===w.loc.start.line){let E=n.getTokenAfter(A,L=>L.value===",");e.report({fix:L=>L.replaceTextRange([E.range[1],w.range[0]],`
`+y),message:"Each parameter should be on its own line when more than 2 parameters or has destructuring",node:w})}}for(let k of c){let A=k.loc.start.column;r(k,A)}};return{ArrowFunctionExpression:i,FunctionDeclaration:i,FunctionExpression:i}},meta:{docs:{description:"Enforce function parameters on separate lines when more than 2"},fixable:"whitespace",schema:[],type:"layout"}},st={create(e){let n=e.sourceCode||e.getSourceCode(),I=x=>{let r=x.params;if(r.length===0)return;let d=r[0],i=r[r.length-1],s=n.getTokenBefore(d);if(s&&s.value==="("&&s.range[0]>=x.range[0]){let o=s,t=n.getTokenAfter(i);t&&t.value===")"&&t.range[1]<=(x.body?x.body.range[0]:x.range[1])&&(d.loc.start.line-o.loc.end.line>1&&e.report({fix:h=>h.replaceTextRange([o.range[1],d.range[0]],`
`+" ".repeat(d.loc.start.column)),message:"No empty line after opening parenthesis in function parameters",node:d}),t.loc.start.line-i.loc.end.line>1&&e.report({fix:h=>h.replaceTextRange([i.range[1],t.range[0]],`
`+" ".repeat(t.loc.start.column)),message:"No empty line before closing parenthesis in function parameters",node:i}))}for(let o=0;o<r.length-1;o+=1){let t=r[o],h=r[o+1];if(h.loc.start.line-t.loc.end.line>1){let p=n.getTokenAfter(t,l=>l.value===",");e.report({fix:l=>l.replaceTextRange([p.range[1],h.range[0]],`
`+" ".repeat(h.loc.start.column)),message:"No empty line between function parameters",node:h})}}r.forEach(o=>{if(o.type==="ObjectPattern"&&o.properties.length>0){let t=o.properties[0],h=o.properties[o.properties.length-1],p=n.getFirstToken(o);p&&p.value==="{"&&t.loc.start.line-p.loc.end.line>1&&e.report({fix:a=>a.replaceTextRange([p.range[1],t.range[0]],`
`+" ".repeat(t.loc.start.column)),message:"No empty line after opening brace in destructuring",node:t});let l=n.getTokenAfter(h,a=>a.value==="}");if(l&&l.loc.start.line-h.loc.end.line>1&&e.report({fix:a=>a.replaceTextRange([h.range[1],l.range[0]],`
`+" ".repeat(l.loc.start.column)),message:"No empty line before closing brace in destructuring",node:h}),o.properties.length>1)for(let a=0;a<o.properties.length-1;a+=1){let u=o.properties[a],T=o.properties[a+1];if(T.loc.start.line-u.loc.end.line>1){let y=n.getTokenAfter(u,b=>b.value===",");e.report({fix:b=>b.replaceTextRange([y.range[1],T.range[0]],`
`+" ".repeat(T.loc.start.column)),message:"No empty lines between destructured properties",node:T})}}}})};return{ArrowFunctionExpression:I,FunctionDeclaration:I,FunctionExpression:I,TSTypeLiteral:x=>{if(!x.members||x.members.length===0)return;let r=x.members[0],d=x.members[x.members.length-1],i=n.getFirstToken(x);i&&i.value==="{"&&r.loc.start.line-i.loc.end.line>1&&e.report({fix:c=>c.replaceTextRange([i.range[1],r.range[0]],`
`+" ".repeat(r.loc.start.column)),message:"No empty line after opening brace in type definition",node:r});let s=n.getLastToken(x);s&&s.value==="}"&&s.loc.start.line-d.loc.end.line>1&&e.report({fix:c=>c.replaceTextRange([d.range[1],s.range[0]],`
`+" ".repeat(s.loc.start.column)),message:"No empty line before closing brace in type definition",node:d});for(let c=0;c<x.members.length-1;c+=1){let o=x.members[c],t=x.members[c+1];t.loc.start.line-o.loc.end.line>1&&e.report({fix:h=>h.replaceTextRange([o.range[1],t.range[0]],`
`+" ".repeat(t.loc.start.column)),message:"No empty lines between type members",node:t})}}}},meta:{docs:{description:"Disallow empty lines in function parameters and type definitions"},fixable:"whitespace",schema:[],type:"layout"}},it={create(e){let n=e.sourceCode||e.getSourceCode(),I=new Set,v=["api","apis","config","configs","constants","data","helpers","lib","routes","services","utils","utilities"],x=y=>v.some(b=>y===`@/${b}`||y.endsWith(`/${b}`)||y.includes(`/${b}/`)||new RegExp(`^\\.?\\.?/${b}$`).test(y)),r=y=>{if(!y.source||!y.source.value)return;let b=y.source.value;x(b)&&y.specifiers.forEach(m=>{(m.type==="ImportSpecifier"&&m.local&&m.local.name||m.type==="ImportDefaultSpecifier"&&m.local&&m.local.name)&&I.add(m.local.name)})},d=(y,b,m)=>{let k=[],A=(w,E)=>{if(!(!w||typeof w!="object")&&w!==m){if(w.type==="Identifier"&&w.name===b){let L=E&&E.type==="MemberExpression"&&E.property===w&&!E.computed,C=E&&E.type==="Property"&&E.key===w&&!E.computed,g=E&&E.type==="Property"&&E.shorthand&&E.value===w;!L&&!C&&k.push(w)}for(let L of Object.keys(w)){if(L==="parent"||L==="range"||L==="loc")continue;let C=w[L];Array.isArray(C)?C.forEach(g=>A(g,w)):C&&typeof C=="object"&&C.type&&A(C,w)}}};return A(y,null),k},i=y=>{for(let b of y.declarations)if(b.id.type==="ObjectPattern"&&b.init){let m=null;if(b.init.type==="Identifier"&&(m=b.init.name),b.init.type==="MemberExpression"){let k=b.init;for(;k.type==="MemberExpression";)k=k.object;k.type==="Identifier"&&(m=k.name)}if(m&&I.has(m)){let k=b.id.properties.filter(E=>E.type==="Property"&&E.key&&E.key.name).map(E=>({key:E.key.name,local:E.value&&E.value.type==="Identifier"?E.value.name:E.key.name})),A=n.getText(b.init),w=y.parent;for(;w&&w.type!=="BlockStatement"&&w.type!=="Program";)w=w.parent;e.report({fix:w?E=>{let L=[];if(k.forEach(({key:C,local:g})=>{d(w,g,b).forEach(S=>{L.push(E.replaceText(S,`${A}.${C}`))})}),y.declarations.length===1){let C=n.getTokenBefore(y),g=n.getTokenAfter(y),f=y.range[0],S=y.range[1];if(C){let P=n.text.slice(C.range[1],y.range[0]).lastIndexOf(`
`);P!==-1&&(f=C.range[1]+P)}if(g){let P=n.text.slice(y.range[1],g.range[0]).indexOf(`
`);P!==-1&&(S=y.range[1]+P+1)}L.push(E.removeRange([f,S]))}else L.push(E.remove(b));return L}:void 0,message:`Do not destructure module imports. Use dot notation for searchability: "${A}.${k[0].key}" instead of destructuring`,node:b.id})}}},s=y=>{if(!y)return!1;if(y.type==="JSXElement"||y.type==="JSXFragment")return!0;if(y.type==="BlockStatement"){for(let b of y.body)if(b.type==="ReturnStatement"&&b.argument&&s(b.argument))return!0}return y.type==="ConditionalExpression"?s(y.consequent)||s(y.alternate):y.type==="LogicalExpression"?s(y.left)||s(y.right):y.type==="ParenthesizedExpression"?s(y.expression):!1},c=y=>{let b=null;if(y.parent)if(y.parent.type==="VariableDeclarator"&&y.parent.id&&y.parent.id.type==="Identifier")b=y.parent.id.name;else if(y.parent.type==="CallExpression"){let m=y.parent.parent;m&&m.type==="VariableDeclarator"&&m.id&&m.id.type==="Identifier"&&(b=m.id.name)}else y.id&&y.id.type==="Identifier"&&(b=y.id.name);if(b&&/^[A-Z]/.test(b)){let m=y.body;return s(m)}return!1},o=new Set(["map","filter","reduce","forEach","find","findIndex","some","every","flat","flatMap","sort","reverse","slice","splice","concat","join","includes","indexOf","lastIndexOf","push","pop","shift","unshift","keys","values","entries","toString","toLocaleString","length"]),t=(y,b)=>{let m=[],k=new Set,A=E=>{if(!(!E||typeof E!="object")){E.type==="CallExpression"&&E.callee&&E.callee.type==="MemberExpression"&&k.add(E.callee);for(let L of Object.keys(E)){if(L==="parent")continue;let C=E[L];Array.isArray(C)?C.forEach(A):C&&typeof C=="object"&&C.type&&A(C)}}};A(y);let w=E=>{if(!(!E||typeof E!="object")){if(E.type==="MemberExpression"&&!E.computed&&E.object.type==="Identifier"&&E.object.name===b){let L=E.property.name;if(k.has(E))return;o.has(L)||m.push({node:E,property:L})}for(let L of Object.keys(E)){if(L==="parent")continue;let C=E[L];Array.isArray(C)?C.forEach(w):C&&typeof C=="object"&&C.type&&w(C)}}};return w(y),m},h=(y,b)=>{if(y.type!=="BlockStatement")return null;let m=y.body;if(m.length===0)return null;let k=m[m.length-1];if(k.type!=="ReturnStatement"||!k.argument)return null;let A=[],w=new Set([b]);for(let E=0;E<m.length-1;E+=1){let L=m[E];if(L.type!=="VariableDeclaration")return null;for(let C of L.declarations){if(!C.init)return null;if(C.id.type==="ObjectPattern"){if(C.init.type!=="Identifier"||!w.has(C.init.name))return null;for(let g of C.id.properties)if(g.type==="Property"&&g.key.type==="Identifier"){if(g.value.type==="ObjectPattern"||g.value.type==="ArrayPattern")return null;let f=g.value.type==="Identifier"?g.value.name:g.key.name;w.add(f),C.init.name===b&&A.push(g.key.name)}}else if(C.id.type==="Identifier")if(C.init.type==="MemberExpression"&&!C.init.computed)if(C.init.object.type==="Identifier"&&w.has(C.init.object.name))w.add(C.id.name);else return null;else return null;else return null}}return A.length===0?null:{destructuredProps:A,returnStatement:k}},p=(y,b)=>{if(y.type!=="BlockStatement")return!1;let m=y.body,k=new Set([b]);for(let A of m)if(A.type!=="ReturnStatement")if(A.type==="VariableDeclaration")for(let w of A.declarations){if(!w.init)return!0;if(w.id.type==="ObjectPattern"&&w.init.type==="Identifier"&&k.has(w.init.name)){for(let E of w.id.properties)E.type==="Property"&&E.value.type==="Identifier"?k.add(E.value.name):E.type==="Property"&&E.key.type==="Identifier"&&k.add(E.key.name);continue}if(w.id.type==="Identifier"&&w.init.type==="MemberExpression"&&w.init.object.type==="Identifier"&&k.has(w.init.object.name)){k.add(w.id.name);continue}return!0}else return!0;return!1},l=(y,b,m)=>{let k=[],A=new Set,w=L=>{if(!(!L||typeof L!="object")){L.type==="CallExpression"&&L.callee&&L.callee.type==="MemberExpression"&&A.add(L.callee);for(let C of Object.keys(L)){if(C==="parent")continue;let g=L[C];Array.isArray(g)?g.forEach(w):g&&typeof g=="object"&&g.type&&w(g)}}};w(y);let E=L=>{if(!(!L||typeof L!="object")){if(L.type==="MemberExpression"&&!L.computed&&L.object.type==="Identifier"&&L.object.name===b){let C=L.property.name;if(A.has(L))return;o.has(C)||k.push({node:L,property:C})}for(let C of Object.keys(L)){if(C==="parent")continue;let g=L[C];Array.isArray(g)?g.forEach(E):g&&typeof g=="object"&&g.type&&E(g)}}};return E(y),k},a=(y,b)=>{let m=new Map;if(y.type!=="BlockStatement")return m;for(let k of y.body)if(k.type==="VariableDeclaration")for(let A of k.declarations){if(A.id.type==="ObjectPattern"&&A.init){if(A.init.type==="Identifier"&&A.init.name===b){for(let w of A.id.properties)if(w.type==="Property"&&w.key.type==="Identifier"){let E=w.value.type==="Identifier"?w.value.name:w.key.name;m.set(E,{fromParam:!0,fromVar:null,originalProp:w.key.name})}}if(A.init.type==="Identifier"&&m.has(A.init.name)){for(let w of A.id.properties)if(w.type==="Property"&&w.key.type==="Identifier"){let E=w.value.type==="Identifier"?w.value.name:w.key.name;m.set(E,{fromParam:!1,fromVar:A.init.name,originalProp:w.key.name})}}}if(A.id.type==="Identifier"&&A.init&&A.init.type==="MemberExpression"){let w=A.init;w.object.type==="Identifier"&&m.has(w.object.name)&&!w.computed&&w.property.type==="Identifier"&&m.set(A.id.name,{fromParam:!1,fromVar:w.object.name,originalProp:w.property.name})}}return m},u=(y,b,m)=>{if(y.type!=="BlockStatement")return null;for(let k of y.body)if(k.type==="VariableDeclaration"){for(let A of k.declarations)if(A.id.type==="ObjectPattern"&&A.init&&A.init.type==="Identifier"&&A.init.name===m){for(let w of A.id.properties)if(w.type==="Property"&&w.key.type==="Identifier"&&(w.value.type==="Identifier"?w.value.name:w.key.name)===b)return{declarator:A,property:w,statement:k}}}return null},T=y=>{let b=c(y),m=y.params,k=y.body;if(!(m.length===0||!k)){if(y.type==="ArrowFunctionExpression"&&k.type!=="BlockStatement"){m.forEach(A=>{if(A.type!=="Identifier")return;let w=A.name,E=!1,L=(g,f)=>{if(!(!g||typeof g!="object")){if(g.type==="SpreadElement"&&g.argument&&g.argument.type==="Identifier"&&g.argument.name===w){E=!0;return}for(let S of Object.keys(g)){if(S==="parent")continue;let $=g[S];Array.isArray($)?$.forEach(P=>L(P,g)):$&&typeof $=="object"&&$.type&&L($,g)}}};if(L(k,null),E)return;let C=t(k,w);if(C.length>0){let g=[...new Set(C.map(P=>P.property))],f=[],S=(P,R)=>{if(!(!P||typeof P!="object")){P.type==="Identifier"&&P.name===w&&(R&&R.type==="Property"&&R.key===P&&!R.computed||f.push(P));for(let F of Object.keys(P)){if(F==="parent")continue;let B=P[F];Array.isArray(B)?B.forEach(j=>S(j,P)):B&&typeof B=="object"&&B.type&&S(B,P)}}};S(k,null);let $=f.length===C.length;e.report({fix:$?P=>{let R=[];return R.push(P.replaceText(A,`{ ${g.join(", ")} }`)),C.forEach(F=>{R.push(P.replaceText(F.node,F.property))}),R}:void 0,message:`Parameter "${w}" is accessed via dot notation. For arrow functions with direct returns, destructure in the parameter: "({ ${g.join(", ")} })"`,node:C[0].node})}});return}if(!b){let A=m[0];if(A.type==="ObjectPattern"){let w=y.parent;if(!(w&&w.type==="CallExpression"&&w.callee&&w.callee.type==="MemberExpression"&&w.callee.property&&w.callee.property.type==="Identifier"&&o.has(w.callee.property.name))){e.report({message:'Non-component functions should not destructure parameters in the signature. Use a typed parameter (e.g., "data: InterfaceType") and destructure in the function body instead.',node:A});return}}}if(y.type==="ArrowFunctionExpression"&&k.type==="BlockStatement"){let A=m[0];if(A&&A.type==="Identifier"){let w=h(k,A.name);if(w){let E=k.body[0],L=k.body.length===2&&E.type==="VariableDeclaration"&&E.declarations.length===1&&E.declarations[0].id.type==="ObjectPattern"&&E.declarations[0].init.type==="Identifier"&&E.declarations[0].init.name===A.name&&!E.declarations[0].id.properties.some(C=>C.type==="RestElement")&&!A.typeAnnotation;e.report({fix:L?C=>{let g=[],f=E.declarations[0].id,S=w.returnStatement.argument,$=n.getText(S);g.push(C.replaceText(A,n.getText(f)));let P=S.type==="ObjectExpression"?`(${$})`:$;return g.push(C.replaceText(k,P)),g}:void 0,message:`This function only destructures and returns. Convert to expression body with destructured param: "({ ${w.destructuredProps.join(", ")} }) => ..."`,node:k});return}}}if(k.type==="BlockStatement"){let A=m[0];if(A&&A.type==="Identifier"&&p(k,A.name)){let w=a(k,A.name);for(let[E,L]of w){let C=l(k,E,A.name);if(C.length>0){let g=[...new Set(C.map(S=>S.property))],f=u(k,E,A.name);e.report({fix:f?S=>{let $=[],{property:P}=f,R=`${L.originalProp}: { ${g.join(", ")} }`;return $.push(S.replaceText(P,R)),C.forEach(F=>{$.push(S.replaceText(F.node,F.property))}),$}:void 0,message:`Variable "${E}" is accessed via dot notation (${g.join(", ")}). Use nested destructuring instead: "const { ${L.originalProp}: { ${g.join(", ")} } } = ..."`,node:C[0].node})}}}}if(m.forEach(A=>{if(A.type!=="Identifier")return;let w=A.name,E=t(k,w);if(E.length>0){let L=[...new Set(E.map(C=>C.property))];e.report({fix:C=>{let g=[],f=k.body[0];if(f){let $=n.lines[f.loc.start.line-1].match(/^\s*/)[0],P=`const { ${L.join(", ")} } = ${w};
${$}`;g.push(C.insertTextBefore(f,P))}return E.forEach(S=>{g.push(C.replaceText(S.node,S.property))}),g},message:`Parameter "${w}" is accessed via dot notation. Destructure it at the top of the function body: "const { ${L.join(", ")} } = ${w};"`,node:E[0].node})}}),b&&k.type==="BlockStatement"){let A=m[0];A&&A.type==="ObjectPattern"&&A.properties.filter(E=>E.type==="Property"&&E.key.type==="Identifier").map(E=>E.value.type==="Identifier"?E.value.name:E.key.name).forEach(E=>{let L=t(k,E);if(L.length>0){let C=[...new Set(L.map(g=>g.property))];e.report({fix:g=>{let f=[],S=k.body[0];if(S){let P=n.lines[S.loc.start.line-1].match(/^\s*/)[0],R=`const { ${C.join(", ")} } = ${E};

${P}`;f.push(g.insertTextBefore(S,R))}return L.forEach($=>{f.push(g.replaceText($.node,$.property))}),f},message:`Prop "${E}" is accessed via dot notation. Destructure it at the top of the component: "const { ${C.join(", ")} } = ${E};"`,node:L[0].node})}})}}};return{ArrowFunctionExpression:T,FunctionDeclaration:T,FunctionExpression:T,ImportDeclaration:r,VariableDeclaration:i}},meta:{docs:{description:"Enforce object parameters to be destructured in function body, not accessed via dot notation. Also prevent destructuring of data imports."},fixable:"code",schema:[],type:"suggestion"}};var at={create(e){let n=e.sourceCode||e.getSourceCode(),I=["useEffect","useLayoutEffect","useCallback","useMemo","useImperativeHandle"];return{CallExpression(v){let{callee:x}=v;if(x.type!=="Identifier"||!I.includes(x.name))return;let r=v.arguments;if(r.length===0)return;let d=r[0];if(d.type!=="ArrowFunctionExpression"&&d.type!=="FunctionExpression")return;let i=n.getTokenAfter(x);if(!(!i||i.value!=="(")&&(i.loc.end.line===d.loc.start.line&&e.report({fix:s=>s.replaceTextRange([i.range[1],d.range[0]],`
        `),message:`${x.name} callback should start on a new line after opening parenthesis`,node:d}),r.length>=2)){let s=r[1],c=n.getTokenAfter(d);c&&c.value===","&&c.loc.end.line===s.loc.start.line&&e.report({fix:h=>h.replaceTextRange([c.range[1],s.range[0]],`
        `),message:`${x.name} dependency array should be on a new line`,node:s});let o=r[r.length-1],t=n.getTokenAfter(o);if(t&&t.value===","&&(t=n.getTokenAfter(t)),t&&t.value===")"&&o.loc.end.line===t.loc.start.line){let h=n.getTokenBefore(t);h&&h.value===","?e.report({fix:l=>l.replaceTextRange([h.range[1],t.range[0]],`
    `),message:`${x.name} closing parenthesis should be on a new line`,node:t}):e.report({fix:l=>l.replaceTextRange([o.range[1],t.range[0]],`,
    `),message:`${x.name} closing parenthesis should be on a new line`,node:t})}}}}},meta:{docs:{description:"Enforce consistent formatting for React hooks (useEffect, useCallback, etc.)"},fixable:"whitespace",schema:[],type:"layout"}},ot={create(e){let n=e.sourceCode||e.getSourceCode(),I=e.options[0]||{},v=I.maxDeps!==void 0?I.maxDeps:2,x=["useEffect","useCallback","useMemo","useLayoutEffect","useImperativeHandle"];return{CallExpression:d=>{if(d.callee.type!=="Identifier"||!x.includes(d.callee.name))return;let i=d.arguments[d.arguments.length-1];if(!i||i.type!=="ArrayExpression")return;let s=i.elements.filter(Boolean);if(s.length===0)return;let c=n.getFirstToken(i),o=n.getLastToken(i),t=s[0],h=s[s.length-1];if(s.length<=v){if(c.loc.end.line!==o.loc.start.line){let u=s.map(T=>n.getText(T)).join(", ");e.report({fix:T=>T.replaceTextRange([c.range[1],o.range[0]],u),message:`Hook dependencies with \u2264${v} items should be single line: [dep1, dep2]. Multi-line only for >${v} dependencies`,node:i})}return}let p=" ".repeat(c.loc.start.column+4),l=" ".repeat(c.loc.start.column);c.loc.end.line===t.loc.start.line&&e.report({fix:a=>a.replaceTextRange([c.range[1],t.range[0]],`
`+p),message:`First dependency should be on its own line when more than ${v}`,node:t}),o.loc.start.line===h.loc.end.line&&e.report({fix:a=>a.replaceTextRange([h.range[1],o.range[0]],`,
`+l),message:`Closing bracket should be on its own line when more than ${v} dependencies`,node:o});for(let a=0;a<s.length-1;a+=1){let u=s[a],T=s[a+1];if(u.loc.end.line===T.loc.start.line){let y=n.getTokenAfter(u);e.report({fix:b=>b.replaceTextRange([y.range[1],T.range[0]],`
`+p),message:`Each dependency should be on its own line when more than ${v}`,node:T})}}}}},meta:{docs:{description:"Enforce each hook dependency on its own line when exceeding threshold (default: >2)"},fixable:"whitespace",schema:[{additionalProperties:!1,properties:{maxDeps:{default:2,description:"Maximum dependencies to keep on single line (default: 2)",minimum:1,type:"integer"}},type:"object"}],type:"layout"}},lt={create(e){let n=e.options[0]||{},I=["is","has","with","without"],v=n.booleanPrefixes||[...I,...n.extendBooleanPrefixes||[]],x=n.allowPastVerbBoolean||!1,r=n.allowContinuousVerbBoolean||!1,d=new RegExp(`^(${v.join("|")})[A-Z]`),i=/^[a-z]+ed$/,s=/^[a-z]+ing$/,c=["children","content","data","error","errors","items","permission","permissions","value","values"],o=a=>{let u=a.toLowerCase();return(c.some(y=>u.includes(y))?"has":"is")+a[0].toUpperCase()+a.slice(1)},t=a=>"set"+a[0].toUpperCase()+a.slice(1),h=a=>!!(d.test(a)||x&&i.test(a)||r&&s.test(a)),p=a=>a?a.type==="Literal"&&typeof a.value=="boolean":!1,l=a=>{if(a.typeParameters&&a.typeParameters.params&&a.typeParameters.params.length>0){let u=a.typeParameters.params[0];if(u.type==="TSBooleanKeyword")return!0;if(u.type==="TSUnionType")return u.types.some(T=>T.type==="TSBooleanKeyword")}return!1};return{CallExpression(a){if(a.callee.type!=="Identifier"||a.callee.name!=="useState"||!a.parent||a.parent.type!=="VariableDeclarator"||!a.parent.id||a.parent.id.type!=="ArrayPattern")return;let u=a.parent.id;if(!u.elements||u.elements.length<1)return;let T=u.elements[0],y=u.elements[1];if(!T||T.type!=="Identifier")return;let b=T.name;if(!(a.arguments&&a.arguments.length>0&&p(a.arguments[0])||l(a))||h(b))return;let k=o(b),A=t(k);e.report({fix(w){let E=[],L=e.sourceCode?e.sourceCode.getScope(a):e.getScope(),C=($,P)=>{let R=$.variables.find(F=>F.name===P);return R||($.upper?C($.upper,P):null)},g=C(L,b),f=new Set,S=`${T.range[0]}-${T.range[1]}`;if(f.add(S),E.push(w.replaceText(T,k)),g&&g.references.forEach($=>{let P=`${$.identifier.range[0]}-${$.identifier.range[1]}`;f.has(P)||(f.add(P),E.push(w.replaceText($.identifier,k)))}),y&&y.type==="Identifier"){let $=y.name,P=C(L,$),R=new Set,F=`${y.range[0]}-${y.range[1]}`;R.add(F),E.push(w.replaceText(y,A)),P&&P.references.forEach(B=>{let j=`${B.identifier.range[0]}-${B.identifier.range[1]}`;R.has(j)||(R.add(j),E.push(w.replaceText(B.identifier,A)))})}return E},message:`Boolean state "${b}" should start with a valid prefix (${v.join(", ")}). Use "${k}" instead.`,node:T})}}},meta:{docs:{description:"Enforce boolean useState variables to start with is/has/with/without prefix"},fixable:"code",schema:[{additionalProperties:!1,properties:{allowContinuousVerbBoolean:{default:!1,description:"Allow continuous verb boolean state without prefix (e.g., loading, saving)",type:"boolean"},allowPastVerbBoolean:{default:!1,description:"Allow past verb boolean state without prefix (e.g., disabled, selected)",type:"boolean"},booleanPrefixes:{description:"Replace default boolean prefixes entirely",items:{type:"string"},type:"array"},extendBooleanPrefixes:{default:[],description:"Add additional prefixes to the defaults (is, has, with, without)",items:{type:"string"},type:"array"}},type:"object"}],type:"suggestion"}},ct={create(e){let v=(e.filename||e.getFilename()).replace(/\\/g,"/").split("/"),r=v[v.length-1].replace(/\.(jsx?|tsx?)$/,"");if(r==="index"||!r.startsWith("use-"))return{};let d=v.lastIndexOf("hooks");if(d===-1)return{};let i=v.slice(d+1,v.length-1);if(i.length===0)return{};let s=new Set(["shared","common","ui","base","general","core"]);if(i.length===1&&s.has(i[0]))return{};let c=i[i.length-1];if(s.has(c))return{};let t=i.slice(0,-1).filter(y=>!s.has(y)).join("-"),p=(y=>y.endsWith("ies")?y.slice(0,-3)+"y":y.endsWith("ses")||y.endsWith("xes")||y.endsWith("zes")?y.slice(0,-2):y.endsWith("s")?y.slice(0,-1):y)(c),l=c,a=r.endsWith("-list"),u,T;if(a)u=t?`use-${t}-${l}-list`:`use-${l}-list`,r!==u&&(T=`List hook file "${r}" should be named "${u}". List hooks must follow the pattern: use-{chain}-{module-plural}-list.`);else{let y=t?`-${t}-${p}`:`-${p}`;if(r.endsWith(y)){let b=r.slice(4),m=y.slice(1),k=b.slice(0,b.length-m.length-1);if(!k||k.length===0){let A=t?`use-{verb}-${t}-${p}`:`use-{verb}-${p}`;T=`Hook file "${r}" is missing a verb. Verb hooks must follow the pattern: ${A}.`}}else{let b=t?`use-{verb}-${t}-${p}`:`use-{verb}-${p}`;T=`Hook file "${r}" should end with "${y}". Verb hooks must follow the pattern: ${b}.`}}return T?{Program(y){e.report({message:T,node:y})}}:{}},meta:{docs:{description:"Enforce naming conventions for hook files inside hooks/ module subfolders"},fixable:null,schema:[],type:"suggestion"}},pt={create(e){let v=(e.filename||e.getFilename()).replace(/\\/g,"/").split("/"),r=v[v.length-1].replace(/\.(jsx?|tsx?)$/,"");if(r==="index"||!r.startsWith("use-"))return{};if(v.lastIndexOf("hooks")===-1)return{};let i=r.split("-").map((t,h)=>h===0?t:t.charAt(0).toUpperCase()+t.slice(1)).join(""),s=(t,h,p)=>l=>{let a=e.sourceCode?e.sourceCode.getScope(t):e.getScope(),u=(m,k)=>{let A=m.variables.find(w=>w.name===k);return A||(m.upper?u(m.upper,k):null)},T=u(a,h);if(!T)return l.replaceText(p,i);let y=[],b=new Set;return T.defs.forEach(m=>{let k=`${m.name.range[0]}-${m.name.range[1]}`;b.has(k)||(b.add(k),y.push(l.replaceText(m.name,i)))}),T.references.forEach(m=>{let k=`${m.identifier.range[0]}-${m.identifier.range[1]}`;b.has(k)||(b.add(k),y.push(l.replaceText(m.identifier,i)))}),y},c=t=>/^use[A-Z]/.test(t)||t==="use",o=t=>{let h,p;if(t.parent&&t.parent.type==="VariableDeclarator"&&t.parent.id&&t.parent.id.type==="Identifier"){h=t.parent.id.name,p=t.parent.id;let l=t.parent.parent;if(!(l&&l.parent&&l.parent.type==="ExportNamedDeclaration"))return}else if(t.id&&t.id.type==="Identifier"){if(h=t.id.name,p=t.id,!(t.parent&&t.parent.type==="ExportNamedDeclaration"))return}else return;c(h)&&h!==i&&e.report({fix:s(t,h,p),message:`Hook function "${h}" should be named "${i}" to match file name "${r}".`,node:p})};return{ArrowFunctionExpression:o,FunctionDeclaration:o,FunctionExpression:o}},meta:{docs:{description:"Enforce that exported hook function names match the camelCase of the file name"},fixable:"code",schema:[],type:"suggestion"}};import fe from"fs";import ie from"path";var ft={create(e){let n=e.options[0]||{},I=n.aliasPrefix||"@/",v=["actions","reducers","store","thunks","types"],x=n.reduxSubfolders||[...v,...n.extraReduxSubfolders||[]],r=["@constants","@strings","actions","apis","assets","atoms","components","config","configs","constants","contexts","data","enums","helpers","hooks","interfaces","layouts","lib","middlewares","pages","providers","reducers","redux","requests","routes","schemas","services","store","strings","styles","theme","thunks","types","ui","utils","utilities","views"],d=n.allowedFolders||[...r,...n.extraAllowedFolders||[]],i=["assets"],s=n.deepImportFolders||[...i,...n.extraDeepImportFolders||[]];return{ImportDeclaration(c){let o=c.source.value;if(typeof o!="string")return;let h=(e.filename||e.getFilename()).replace(/\\/g,"/"),p=/\/index\.(js|jsx|ts|tsx)$/.test(h),l=/\/main\.(js|jsx|ts|tsx)$/.test(h),u=(()=>{for(let T of d)if(new RegExp(`/(${T})/`).test(h))return T;return null})();if(o.startsWith("./")||o.startsWith("../")){if(p||l||u)return;e.report({message:`Relative imports are not allowed. Use absolute imports with "${I}" prefix instead.`,node:c.source});return}if(!(!o.startsWith("@")&&!o.startsWith("."))&&!(o.startsWith("@")&&!o.startsWith(I))&&o.startsWith(I)){let y=o.slice(I.length).split("/").filter(m=>m.length>0);if(y.length===0){e.report({message:`Invalid import path "${o}". Specify a folder to import from.`,node:c.source});return}let b=y[0];if(!d.includes(b)){e.report({message:`Unknown folder "${b}" in import path. Allowed folders: ${d.join(", ")}`,node:c.source});return}if(u&&b===u){let m=y.slice(1).join("/");if(m){let k=h.lastIndexOf(`/${u}/`),A=h.slice(k+u.length+2),w=A.substring(0,A.lastIndexOf("/")),E=ie.posix.relative(w,m);E.startsWith(".")||(E=`./${E}`),e.report({message:`Files within "${u}/" should use relative imports (e.g., "${E}") instead of "${o}" to avoid circular dependencies.`,node:c.source,fix:L=>L.replaceText(c.source,`"${E}"`)});return}e.report({message:`Files within "${u}/" should use relative imports instead of "${o}" to avoid circular dependencies through the index file.`,node:c.source});return}if(y.length>1){if(b==="redux"&&y.length===2&&x.includes(y[1]))return;if(b==="redux"&&y.length>2){let A=`${I}redux/${y[1]}`;e.report({message:`Deep imports are not allowed. Import from "${A}" instead of "${o}". Export the module from the folder's index file.`,node:c.source});return}if(s.includes(b))return;let k=`${I}${b}`;e.report({fix:A=>A.replaceText(c.source,`"${k}"`),message:`Deep imports are not allowed. Import from "${k}" instead of "${o}". Export the module from the folder's index file.`,node:c.source})}}}}},meta:{docs:{description:"Enforce absolute imports from index files only for local paths, with relative imports required for files within the same module folder"},fixable:"code",schema:[{additionalProperties:!1,properties:{aliasPrefix:{type:"string"},allowedFolders:{items:{type:"string"},type:"array"},deepImportFolders:{items:{type:"string"},type:"array"},extraAllowedFolders:{items:{type:"string"},type:"array"},extraDeepImportFolders:{items:{type:"string"},type:"array"},extraReduxSubfolders:{items:{type:"string"},type:"array"},reduxSubfolders:{items:{type:"string"},type:"array"}},type:"object"}],type:"problem"}},ut={create(e){let n=e.sourceCode||e.getSourceCode(),I=e.options[0]||{},v=I.maxSpecifiers!==void 0?I.maxSpecifiers:3;return{ExportNamedDeclaration:r=>{let d=n.getFirstToken(r);if(r.declaration){let p=n.getFirstToken(r.declaration);p&&d.loc.end.line!==p.loc.start.line&&e.report({fix:l=>l.replaceTextRange([d.range[1],p.range[0]]," "),message:"Declaration keyword must be on the same line as 'export'",node:p});return}let i=r.specifiers;if(i.length===0)return;let s=n.getTokenAfter(d,p=>p.value==="{"),c=n.getLastToken(r,p=>p.value==="}");if(!s||!c)return;d.loc.end.line!==s.loc.start.line&&e.report({fix:p=>p.replaceTextRange([d.range[1],s.range[0]]," "),message:"Opening brace should be on the same line as 'export'",node:s});let o=s.loc.start.line!==c.loc.end.line,t=i[0],h=i[i.length-1];if(i.length<=v){if(o){let p=i.map(l=>l.exported.name===l.local.name?l.local.name:`${l.local.name} as ${l.exported.name}`).join(", ");e.report({fix:l=>l.replaceTextRange([s.range[0],c.range[1]],`{ ${p} }`),message:`Exports with \u2264${v} specifiers should be single line: export { a, b, c }`,node:r})}}else{let p=" ".repeat(d.loc.start.column),l=p+"    ";s.loc.end.line===t.loc.start.line&&e.report({fix:a=>a.replaceTextRange([s.range[1],t.range[0]],`
`+l),message:`Exports with more than ${v} specifiers should have first specifier on its own line`,node:t}),c.loc.start.line===h.loc.end.line&&e.report({fix:a=>a.replaceTextRange([h.range[1],c.range[0]],`,
`+p),message:`Exports with more than ${v} specifiers should have closing brace on its own line`,node:c});for(let a=0;a<i.length-1;a+=1){let u=i[a],T=i[a+1];if(u.loc.end.line===T.loc.start.line){let y=n.getTokenAfter(u,b=>b.value===",");e.report({fix:b=>b.replaceTextRange([y.range[1],T.range[0]],`
`+l),message:`Each export specifier should be on its own line when more than ${v} specifiers`,node:T})}}}}}},meta:{docs:{description:"Format exports: export { on same line, collapse/expand specifiers based on count threshold"},fixable:"code",schema:[{additionalProperties:!1,properties:{maxSpecifiers:{default:3,description:"Maximum specifiers to keep on single line (default: 3). Exports exceeding this will be expanded to multiline.",minimum:1,type:"integer"}},type:"object"}],type:"layout"}},gt={create(e){let n=e.sourceCode||e.getSourceCode(),I=e.options[0]||{},v=I.maxSpecifiers!==void 0?I.maxSpecifiers:3;return{ImportDeclaration:r=>{let d=n.getFirstToken(r),i=r.specifiers.filter(a=>a.type==="ImportSpecifier"),s=r.specifiers.find(a=>a.type==="ImportDefaultSpecifier");if(s&&i.length===0){if(n.getTokenBefore(r.source,u=>u.value==="from")&&d.loc.start.line!==r.source.loc.end.line){let u=s.local.name,T=r.source.raw;e.report({fix:y=>y.replaceText(r,`import ${u} from ${T};`),message:"Default import should be on a single line",node:r})}return}if(i.length===0)return;let c=n.getTokenAfter(d,a=>a.value==="{"),o=n.getTokenBefore(r.source,a=>a.value==="}"),t=n.getTokenBefore(r.source,a=>a.value==="from");if(!c||!o||!t)return;d.loc.end.line!==c.loc.start.line&&e.report({fix:a=>a.replaceTextRange([d.range[1],c.range[0]]," "),message:"Opening brace should be on the same line as 'import'",node:c}),o.loc.end.line!==t.loc.start.line&&e.report({fix:a=>a.replaceTextRange([o.range[1],t.range[0]]," "),message:"Closing brace should be on the same line as 'from'",node:t});let h=c.loc.start.line!==o.loc.end.line,p=i[0],l=i[i.length-1];if(i.length<=v){if(h){let a=i.map(u=>u.imported.name===u.local.name?u.local.name:`${u.imported.name} as ${u.local.name}`).join(", ");e.report({fix:u=>u.replaceTextRange([c.range[0],o.range[1]],`{ ${a} }`),message:`Imports with \u2264${v} specifiers should be single line: import { a, b, c } from "module"`,node:r})}}else{let a=" ".repeat(d.loc.start.column),u=a+"    ";c.loc.end.line===p.loc.start.line&&e.report({fix:T=>T.replaceTextRange([c.range[1],p.range[0]],`
`+u),message:`Imports with more than ${v} specifiers should have first specifier on its own line`,node:p}),o.loc.start.line===l.loc.end.line&&e.report({fix:T=>T.replaceTextRange([l.range[1],o.range[0]],`,
`+a),message:`Imports with more than ${v} specifiers should have closing brace on its own line`,node:o});for(let T=0;T<i.length-1;T+=1){let y=i[T],b=i[T+1];if(y.loc.end.line===b.loc.start.line){let m=n.getTokenAfter(y,k=>k.value===",");e.report({fix:k=>k.replaceTextRange([m.range[1],b.range[0]],`
`+u),message:`Each import specifier should be on its own line when more than ${v} specifiers`,node:b})}}}}}},meta:{docs:{description:"Format imports: import { on same line, } from on same line, collapse/expand specifiers based on count threshold"},fixable:"code",schema:[{additionalProperties:!1,properties:{maxSpecifiers:{default:3,description:"Maximum specifiers to keep on single line (default: 3). Imports exceeding this will be expanded to multiline.",minimum:1,type:"integer"}},type:"object"}],type:"layout"}},mt={create(e){return{ImportDeclaration(n){let{source:I}=n;if(I.type!=="Literal"||typeof I.value!="string")return;let v=I.value,x=v.trim();v!==x&&x.length>0&&e.report({fix:r=>r.replaceText(I,`"${x}"`),message:`Import path should not have extra spaces inside quotes: "${x}" not "${v}"`,node:I})}}},meta:{docs:{description:"Enforce no extra spaces inside import path quotes"},fixable:"code",schema:[],type:"layout"}},dt={create(e){let n=e.filename||e.getFilename(),I=ie.resolve(n,"../../..").replace(/\\/g,"/"),v=e.options[0]||{},x=["@constants","@strings","actions","apis","assets","atoms","components","config","configs","constants","contexts","data","enums","helpers","hooks","interfaces","layouts","lib","middlewares","pages","providers","reducers","redux","requests","routes","schemas","services","store","strings","styles","theme","thunks","types","ui","utils","utilities","views"],r=v.moduleFolders||[...x,...v.extraModuleFolders||[]],d=["pages","views"],i=v.lazyLoadFolders||[...d,...v.extraLazyLoadFolders||[]],s=["index.js","index.jsx","index.ts","index.tsx",".DS_Store","__tests__","__mocks__","*.test.js","*.test.jsx","*.test.ts","*.test.tsx","*.spec.js","*.spec.jsx","*.spec.ts","*.spec.tsx"],c=v.ignorePatterns||[...s,...v.extraIgnorePatterns||[]],o=l=>c.some(a=>a.includes("*")?new RegExp("^"+a.replace(/\*/g,".*")+"$").test(l):l===a),t=l=>{let a=new Set,u=new Map;return l.type==="Program"&&(l.body.forEach(T=>{if(T.type==="ImportDeclaration"&&T.source){let y=T.source.value;T.specifiers.forEach(b=>{b.local&&b.local.name&&u.set(b.local.name,y)})}}),l.body.forEach(T=>{if(T.type==="ExportNamedDeclaration"){if(T.source){let y=T.source.value;a.add(y)}T.specifiers&&!T.source&&T.specifiers.forEach(y=>{let b=y.local?y.local.name:y.exported.name;u.has(b)&&a.add(u.get(b))})}T.type==="ExportAllDeclaration"&&T.source&&a.add(T.source.value)})),a},h=l=>l.replace(/\.(js|jsx|ts|tsx)$/,""),p=(l,a,u)=>{let T;try{T=fe.readdirSync(a)}catch{return}let y=T.filter(m=>{if(o(m))return!1;let k=ie.join(a,m);try{if(fe.statSync(k).isDirectory()||/\.(js|jsx|ts|tsx)$/.test(m))return!0}catch{return!1}return!1});if(y.length===0)return;let b=t(l);y.forEach(m=>{let k=h(m),A=ie.join(a,m),w=fe.statSync(A).isDirectory();Array.from(b).some(L=>!!(L===`./${m}`||L===`./${k}`||L.startsWith(`./${k}/`)||w&&(L===`./${k}/index`||L===`./${k}/index.js`||L===`./${k}/index.jsx`||L===`./${k}/index.ts`||L===`./${k}/index.tsx`)))||e.report({message:`Module "${m}" in "${u}" folder is not exported from index file. Add: export * from "./${k}"; or export { ... } from "./${k}";`,node:l})})};return{Program(l){let a=n.replace(/\\/g,"/"),u=a.match(/\/src\/([^/]+)\/index\.(js|jsx|ts|tsx)$/);if(u){let b=u[1];if(i.includes(b))return;if(r.includes(b)){let m=ie.dirname(n);p(l,m,b)}}let T=a.match(/\/src\/([^/]+)\/([^/]+)\.(js|jsx|ts|tsx)$/);if(T){let b=T[1],m=T[2];if(r.includes(b)&&m!=="index"){let k=ie.dirname(n),A=ie.join(k,"index.js"),w=ie.join(k,"index.jsx"),E=ie.join(k,"index.ts"),L=ie.join(k,"index.tsx");fe.existsSync(A)||fe.existsSync(w)||fe.existsSync(E)||fe.existsSync(L)||e.report({message:`Module folder "${b}" is missing an index file. Create an index file to export all modules.`,node:l})}}let y=a.match(/\/src\/([^/]+)\/([^/]+)\/index\.(js|jsx|ts|tsx)$/);if(y){let b=y[1],m=y[2];if(i.includes(b))return;if(r.includes(b)){let k=ie.dirname(n);p(l,k,`${b}/${m}`)}}}}},meta:{docs:{description:"Ensure module folders have index files that export all contents"},schema:[{additionalProperties:!1,properties:{extraIgnorePatterns:{items:{type:"string"},type:"array"},extraLazyLoadFolders:{items:{type:"string"},type:"array"},extraModuleFolders:{items:{type:"string"},type:"array"},ignorePatterns:{items:{type:"string"},type:"array"},lazyLoadFolders:{items:{type:"string"},type:"array"},moduleFolders:{items:{type:"string"},type:"array"}},type:"object"}],type:"problem"}},yt={create(e){let I=(e.options[0]||{}).style||"shorthand",v=e.sourceCode||e.getSourceCode(),r=(e.filename||e.getFilename()).replace(/\\/g,"/");return/\/index\.(js|jsx|ts|tsx)$/.test(r)?{Program(i){let s=[],c=[],o=[],t=new Map;if(i.body.forEach(l=>{l.type==="ImportDeclaration"&&l.source&&(s.push(l),l.specifiers.forEach(a=>{a.local&&a.local.name&&t.set(a.local.name,{source:l.source.value,statement:l})})),l.type==="ExportNamedDeclaration"&&(l.source?c.push(l):l.specifiers&&l.specifiers.length>0&&!l.declaration&&o.push(l))}),c.length===0&&o.length===0)return;let h=c.length>0,p=o.length>0&&s.length>0;if(h&&p){e.report({message:`Mixed export styles detected. Use consistent "${I}" style throughout the index file.`,node:i});return}if(I==="shorthand"){if(o.length>0&&s.length>0){let l=[];o.forEach(a=>{a.specifiers.forEach(u=>{let T=u.local?u.local.name:u.exported.name,y=t.get(T);y&&l.push({exportStmt:a,exportedName:T,importInfo:y,localName:u.local?u.local.name:T,spec:u})})}),l.length>0&&e.report({fix(a){let u=[],T=new Map;l.forEach(({exportedName:m,importInfo:k,localName:A})=>{let w=k.source;T.has(w)||T.set(w,[]),m===A?T.get(w).push(m):T.get(w).push(`${A} as ${m}`)});let y=[];T.forEach((m,k)=>{y.push(`export { ${m.join(", ")} } from "${k}";`)}),o.forEach(m=>{u.push(a.remove(m))}),s.forEach(m=>{u.push(a.remove(m))});let b=i.body[0];return b&&u.push(a.insertTextBefore(b,y.join(`
`)+`
`)),u},message:'Use shorthand export style: export { ... } from "source" instead of import then export.',node:i})}for(let l=0;l<c.length-1;l+=1){let a=c[l],u=c[l+1],T=a.loc.end.line;u.loc.start.line-T>1&&e.report({fix(b){let m=v.getText().slice(a.range[1],u.range[0]);return b.replaceTextRange([a.range[1],u.range[0]],`
`)},message:"No empty lines between shorthand exports in index files.",node:u})}}else if(I==="import-export"){c.length>0&&e.report({fix(l){let a=[],u=[],T=[];c.forEach(m=>{let k=m.source.value,A=[];m.specifiers.forEach(w=>{let E=w.local?w.local.name:w.exported.name,L=w.exported.name;A.push(E),T.push(L)}),u.push(`import { ${A.join(", ")} } from "${k}";`),a.push(l.remove(m))}),T.sort((m,k)=>m.localeCompare(k));let y;T.length<=3?y=`export { ${T.join(", ")} };`:y=`export {
    ${T.join(`,
    `)},
};`;let b=i.body[0];if(b){let m=u.join(`
`)+`

`+y+`
`;a.push(l.insertTextBefore(b,m))}return a},message:"Use import-then-export style with a single export statement.",node:i}),o.length>1&&e.report({fix(l){let a=[],u=[];o.forEach(b=>{b.specifiers.forEach(m=>{let k=m.exported.name;u.push(k)}),a.push(l.remove(b))}),u.sort((b,m)=>b.localeCompare(m));let T;u.length<=3?T=`export { ${u.join(", ")} };`:T=`export {
    ${u.join(`,
    `)},
};`;let y=s[s.length-1];return y&&a.push(l.insertTextAfter(y,`

`+T)),a},message:"Combine multiple export statements into a single export statement.",node:i});for(let l=0;l<s.length-1;l+=1){let a=s[l],u=s[l+1],T=a.loc.end.line;u.loc.start.line-T>1&&e.report({fix(b){return b.replaceTextRange([a.range[1],u.range[0]],`
`)},message:"No empty lines between imports in index files.",node:u})}}}}:{Program(i){let s=[];if(i.body.forEach(c=>{(c.type==="ExportNamedDeclaration"||c.type==="ExportDefaultDeclaration")&&s.push(c)}),!(s.length<2))for(let c=0;c<s.length-1;c+=1){let o=s[c],t=s[c+1],h=o.loc.end.line;t.loc.start.line-h<2&&e.report({fix(l){return l.replaceTextRange([o.range[1],t.range[0]],`

`)},message:"Require blank line between exports.",node:t})}}}},meta:{docs:{description:"Enforce export formatting: blank lines in regular files, no blank lines in index files with consistent style: shorthand (default) or import-export"},fixable:"code",schema:[{additionalProperties:!1,properties:{style:{enum:["shorthand","import-export"],type:"string"}},type:"object"}],type:"layout"}},ht={create(e){let I=(e.filename||e.getFilename()).replace(/\\/g,"/");if(!(/\/index\.(js|jsx|ts|tsx)$/.test(I)||/^index\.(js|jsx|ts|tsx)$/.test(I)))return{};let x=["actions","apis","assets","atoms","components","config","configs","constants","contexts","data","enums","helpers","hooks","interfaces","layouts","lib","middlewares","pages","providers","reducers","redux","requests","routes","schemas","services","store","strings","styles","theme","themes","thunks","types","ui","utils","utilities","views"],r=I.split("/"),d=r.length-1,i=!1;for(let t=0;t<d;t++)if(x.includes(r[t])){d-t>=2&&(i=!0);break}let s=t=>{let{type:h}=t;return h==="ImportDeclaration"?!0:h==="ExportNamedDeclaration"?!t.declaration:h==="ExportDefaultDeclaration"?t.declaration&&t.declaration.type==="Identifier":h==="ExportAllDeclaration"},c=t=>{let{type:h}=t;return h==="VariableDeclaration"||h==="FunctionDeclaration"||h==="ClassDeclaration"||h==="ExportNamedDeclaration"&&t.declaration?!0:h==="ExportDefaultDeclaration"?t.declaration&&t.declaration.type!=="Identifier":!1},o=t=>{switch(t.type){case"TSTypeAliasDeclaration":return"Type definition";case"TSInterfaceDeclaration":return"Interface definition";case"TSEnumDeclaration":return"Enum definition";case"VariableDeclaration":return"Variable declaration";case"FunctionDeclaration":return"Function declaration";case"ClassDeclaration":return"Class declaration";case"ExportNamedDeclaration":return t.declaration?o(t.declaration):"Export with inline declaration";case"ExportDefaultDeclaration":return"Default export with inline definition";default:return"Code"}};return{Program(t){if(i){if(!t.body.some(p=>c(p))){let p=r[d-1];e.report({message:`Subfolder index file "${p}/index" should contain component code, not just re-exports. Only the module root index file should be a barrel for imports and re-exports.`,node:t})}return}for(let h of t.body)if(!s(h)){let p=o(h);e.report({message:`${p} should not be in index files. Index files should only contain imports and re-exports. Move this to a separate file.`,node:h})}}}},meta:{docs:{description:"Enforce index files as barrels (re-exports only) at module root, and as component entry points (with code) in subfolders"},schema:[],type:"suggestion"}},xt={create(e){let I=(e.filename||e.getFilename()).replace(/\\/g,"/");if(/\/index\.(js|jsx|ts|tsx)$/.test(I)||/^index\.(js|jsx|ts|tsx)$/.test(I))return{};let x=e.sourceCode||e.getSourceCode();return{Program(r){let d=r.body.filter(s=>s.type==="ExportNamedDeclaration"&&!s.source&&!s.declaration&&s.specifiers.length>0);if(d.length===0)return;let i=new Map;r.body.forEach(s=>{s.type==="VariableDeclaration"?s.declarations.forEach(c=>{c.id&&c.id.type==="Identifier"&&i.set(c.id.name,{declarationNode:s,kind:s.kind})}):s.type==="FunctionDeclaration"&&s.id?i.set(s.id.name,{declarationNode:s,kind:"function"}):s.type==="ClassDeclaration"&&s.id&&i.set(s.id.name,{declarationNode:s,kind:"class"})}),d.forEach(s=>{s.specifiers.some(h=>h.local.name!==h.exported.name)||!s.specifiers.every(h=>i.has(h.local.name))||s.specifiers.some(h=>{let l=i.get(h.local.name).declarationNode,a=l.parent;return a&&a.type==="ExportNamedDeclaration"?!0:x.getText(l).startsWith("export ")})||e.report({fix(h){let p=[];s.specifiers.forEach(a=>{let T=i.get(a.local.name).declarationNode;p.push(h.insertTextBefore(T,"export "))});let l=x.getTokenBefore(s,{includeComments:!0});return l?p.push(h.removeRange([l.range[1],s.range[1]])):p.push(h.remove(s)),p},message:"Use inline export declarations (export const x = ...) instead of grouped export statements (export { x }).",node:s})})}}},meta:{docs:{description:"Enforce inline export declarations instead of grouped export statements in non-index files"},fixable:"code",schema:[],type:"layout"}};var Tt={create(e){let n=e.sourceCode||e.getSourceCode(),I=s=>s?s.type==="Identifier"||s.type==="Literal"?!0:s.type==="MemberExpression"?s.object.type==="Identifier"&&s.property.type==="Identifier":!1:!1,v=s=>{if(!s||s.type==="Identifier"||s.type==="Literal")return!0;if(s.type==="ChainExpression")return v(s.expression);if(s.type==="MemberExpression"){let c=s;for(;c.type==="MemberExpression";){if(c.computed){if(c.property.type!=="Identifier"&&c.property.type!=="Literal")return!1}else if(c.property.type!=="Identifier")return!1;c=c.object}return c.type==="ChainExpression"?v(c.expression):c.type==="Identifier"}if(s.type==="CallExpression"){let{callee:c}=s;return c.type==="Identifier"||c.type==="MemberExpression"&&c.object.type==="Identifier"&&c.property.type==="Identifier"?!!(s.arguments.length===0||s.arguments.length===1&&I(s.arguments[0])):!1}if(s.type==="LogicalExpression"){let c=t=>t.type==="LogicalExpression"?c(t.left)+c(t.right):1;if(c(s)>2)return!1;let o=t=>t.type==="Identifier"||t.type==="Literal"?!0:t.type==="MemberExpression"?v(t):t.type==="ChainExpression"&&t.expression?o(t.expression):!1;return o(s.left)&&o(s.right)}return!1},x=s=>s.type==="JSXText"?!0:s.type==="JSXExpressionContainer"?v(s.expression):!1,r=(s,c,o)=>{let{children:t}=s;if(!o)return;let h=t.filter(m=>m.type==="JSXText"?m.value.trim()!=="":!0);if(h.length===0)return;let p=c.loc.start.line===o.loc.end.line,l=h.every(x);if(p&&l||h.length===1&&x(h[0]))return;let u=h[0],T=h[h.length-1],y=" ".repeat(c.loc.start.column+4),b=" ".repeat(c.loc.start.column);if(c.loc.end.line===u.loc.start.line&&e.report({fix:m=>m.replaceTextRange([c.range[1],u.range[0]],`
`+y),message:"JSX child should be on its own line",node:u}),o.loc.start.line===T.loc.end.line){if(T.type==="JSXText"){let m=T.value,k=m.trimEnd();if(m.slice(k.length).includes(`
`))return}e.report({fix:m=>m.replaceTextRange([T.range[1],o.range[0]],`
`+b),message:"Closing tag should be on its own line",node:o})}};return{JSXElement:s=>{r(s,s.openingElement,s.closingElement)},JSXFragment:s=>{r(s,s.openingFragment,s.closingFragment)}}},meta:{docs:{description:"Enforce JSX children on separate lines from parent tags"},fixable:"whitespace",schema:[],type:"layout"}},bt={create(e){let n=e.sourceCode||e.getSourceCode(),I=v=>{let x=n.getLastToken(v);if(!x||x.value!==">"&&x.value!=="/>")return;let r=n.getTokenBefore(x);if(r&&r.loc.end.line===x.loc.start.line&&x.range[0]-r.range[1]>0){let d=n.text.slice(r.range[1],x.range[0]);/^\s+$/.test(d)&&e.report({fix:i=>i.removeRange([r.range[1],x.range[0]]),message:`No space allowed before '${x.value}' in JSX tag`,node:x})}};return{JSXOpeningElement:I,JSXClosingElement:I}},meta:{docs:{description:"No space before > or /> in JSX tags"},fixable:"whitespace",schema:[],type:"layout"}},kt={create(e){let n=e.sourceCode||e.getSourceCode(),I=r=>r?r.type==="Identifier"||r.type==="Literal"?!0:r.type==="MemberExpression"?r.object.type==="Identifier"&&r.property.type==="Identifier":!1:!1,v=r=>{if(!r||r.type==="Identifier"||r.type==="Literal")return!0;if(r.type==="ChainExpression")return v(r.expression);if(r.type==="MemberExpression"){let d=r;for(;d.type==="MemberExpression";){if(d.computed){if(d.property.type!=="Identifier"&&d.property.type!=="Literal")return!1}else if(d.property.type!=="Identifier")return!1;d=d.object}return d.type==="ChainExpression"?v(d.expression):d.type==="Identifier"}if(r.type==="CallExpression"){let{callee:d}=r;return d.type==="Identifier"||d.type==="MemberExpression"&&d.object.type==="Identifier"&&d.property.type==="Identifier"?!!(r.arguments.length===0||r.arguments.length===1&&I(r.arguments[0])):!1}if(r.type==="LogicalExpression"){let d=s=>s.type==="LogicalExpression"?d(s.left)+d(s.right):1;if(d(r)>2)return!1;let i=s=>s.type==="Identifier"||s.type==="Literal"?!0:s.type==="MemberExpression"?v(s):s.type==="ChainExpression"&&s.expression?i(s.expression):!1;return i(r.left)&&i(r.right)}return!1},x=r=>r.type==="JSXElement"||r.type==="JSXFragment"?!0:r.type==="JSXExpressionContainer"?!v(r.expression):!1;return{JSXElement(r){let d=r.openingElement,i=r.closingElement;if(!i)return;let{children:s}=r,c=s.filter(x);if(c.length===0)return;let o=" ".repeat(d.loc.start.column+4),t=" ".repeat(d.loc.start.column);c.forEach(p=>{d.loc.end.line===p.loc.start.line&&e.report({fix:l=>l.replaceTextRange([d.range[1],p.range[0]],`
`+o),message:"JSX element child should be on its own line",node:p})});let h=c[c.length-1];h&&i.loc.start.line===h.loc.end.line&&e.report({fix:p=>p.replaceTextRange([h.range[1],i.range[0]],`
`+t),message:"Closing tag should be on its own line after JSX children",node:i})}}},meta:{docs:{description:"JSX children that are JSX elements must be on new lines"},fixable:"whitespace",schema:[],type:"layout"}},Et={create(e){let n=e.sourceCode||e.getSourceCode(),I=r=>{let d=n.getTokenBefore(r),i=n.getTokenAfter(r);return d&&i&&d.value==="("&&i.value===")"},v=r=>{let d=n.getText(r);return I(r)?`(${d})`:d};return{LogicalExpression:r=>{if(r.operator!=="&&")return;let{left:d,right:i}=r;if(i.type!=="JSXElement"&&i.type!=="JSXFragment")return;let s=n.lines[r.loc.start.line-1].match(/^\s*/)[0],c=s+"    ",o=i.loc.start.line===i.loc.end.line,t=v(d),h=n.getText(i);if(o&&d.loc.start.line===d.loc.end.line){r.loc.start.line!==r.loc.end.line&&e.report({fix:p=>p.replaceText(r,`${t} && ${h}`),message:"Simple logical expression with single-line JSX should be on one line",node:r});return}if(!o){let p=n.getTokenAfter(d,a=>a.value==="&&");if(!p)return;let l=n.getTokenAfter(p);if(l&&l.value==="("){let a=n.getTokenAfter(l);a&&a.loc.start.line-l.loc.end.line>1&&e.report({fix:T=>T.replaceTextRange([l.range[1],a.range[0]],`
`+c),message:"No empty lines after '(' in logical expression",node:a});let u=n.getTokenAfter(i);u&&u.value===")"&&u.loc.start.line-i.loc.end.line>1&&e.report({fix:T=>T.replaceTextRange([i.range[1],u.range[0]],`
`+s),message:"No empty lines before ')' in logical expression",node:u})}}}}},meta:{docs:{description:"Simplify logical expressions in JSX when right side is single-line, and check formatting for complex JSX"},fixable:"code",schema:[],type:"layout"}},St={create(e){let n=e.sourceCode||e.getSourceCode();return{ArrowFunctionExpression:x=>{if(x.body.type!=="JSXElement"&&x.body.type!=="JSXFragment")return;let r=x.body,d=n.getTokenBefore(x.body,o=>o.value==="=>"),i=n.getTokenAfter(d);if(!i||i.value!=="(")return;let s=i;if(d.loc.end.line!==s.loc.start.line&&e.report({fix:o=>o.replaceTextRange([d.range[1],s.range[1]]," ("),message:"Opening parenthesis should be on the same line as arrow",node:s}),s.loc.end.line===r.loc.start.line){let o=" ".repeat(s.loc.start.column+4);e.report({fix:t=>t.replaceTextRange([s.range[1],r.range[0]],`
`+o),message:"JSX should start on a new line after opening parenthesis",node:r})}else if(r.loc.start.line-s.loc.end.line>1){let o=" ".repeat(r.loc.start.column);e.report({fix:t=>t.replaceTextRange([s.range[1],r.range[0]],`
`+o),message:"No empty line after opening parenthesis",node:r})}let c=n.getTokenAfter(r);if(c&&c.value===")"){if(c.loc.start.line-r.loc.end.line>1){let t=" ".repeat(c.loc.start.column);e.report({fix:h=>h.replaceTextRange([r.range[1],c.range[0]],`
`+t),message:"No empty line before closing parenthesis",node:c})}let o=n.getTokenAfter(c);if(o&&o.value==="}"){let t=n.text.slice(c.range[1],o.range[0]);(t.includes(`
`)||t.includes(" "))&&e.report({fix:h=>h.replaceTextRange([c.range[1],o.range[0]],""),message:"Closing parenthesis and brace should be together",node:o})}}},Property:x=>{if(!x.value||x.value.type!=="JSXElement"&&x.value.type!=="JSXFragment")return;let r=n.getTokenAfter(x.key,o=>o.value===":"),d=n.getTokenAfter(r);if(!d||d.value!=="(")return;let i=d,s=x.value;if(r.loc.end.line!==i.loc.start.line&&e.report({fix:o=>o.replaceTextRange([r.range[1],i.range[1]]," ("),message:"Opening parenthesis should be on the same line as colon with a space",node:i}),i.loc.end.line===s.loc.start.line){let o=" ".repeat(x.key.loc.start.column+4);e.report({fix:t=>t.replaceTextRange([i.range[1],s.range[0]],`
`+o),message:"JSX should start on a new line after opening parenthesis",node:s})}else if(s.loc.start.line-i.loc.end.line>1){let o=" ".repeat(s.loc.start.column);e.report({fix:t=>t.replaceTextRange([i.range[1],s.range[0]],`
`+o),message:"No empty line after opening parenthesis",node:s})}let c=n.getTokenAfter(s);if(c&&c.value===")"&&c.loc.start.line-s.loc.end.line>1){let o=" ".repeat(c.loc.start.column);e.report({fix:t=>t.replaceTextRange([s.range[1],c.range[0]],`
`+o),message:"No empty line before closing parenthesis",node:c})}}}},meta:{docs:{description:"Enforce opening parenthesis position for JSX in arrow functions and object properties"},fixable:"code",schema:[],type:"layout"}},wt={create(e){let n=/^[a-z][a-zA-Z0-9]*$/,I=["Icon","Component","FormComponent","Layout","Wrapper","Container","Provider","Element","Trigger","Content","Header","Footer","Body","Title","Overlay","Portal","Root","Item","Label","Input","Button","Action","Slot"];return{JSXAttribute(v){if(!v.name)return;let x=v.name.type==="JSXIdentifier"?v.name.name:v.name.name?.name;!x||x.startsWith("data-")||x.startsWith("aria-")||I.includes(x)||["Icon","Component","Element","Wrapper","Container","Layout","Provider"].some(d=>x.endsWith(d)&&x!==d)||n.test(x)||e.report({message:`JSX prop "${x}" should be camelCase`,node:v.name})}}},meta:{docs:{description:"Enforce camelCase naming for JSX props, with exceptions for component references"},schema:[],type:"suggestion"}},vt={create(e){let n=e.sourceCode||e.getSourceCode(),I=r=>r?r.type==="Identifier"||r.type==="Literal"?!0:r.type==="MemberExpression"?r.object.type==="Identifier"&&r.property.type==="Identifier":!1:!1,v=r=>{if(!r)return!1;if(r.type==="Identifier"||r.type==="Literal")return!0;if(r.type==="MemberExpression")return r.object.type==="Identifier"&&r.property.type==="Identifier";if(r.type==="CallExpression"){let{callee:d}=r;return d.type==="Identifier"||d.type==="MemberExpression"&&d.object.type==="Identifier"&&d.property.type==="Identifier"?!!(r.arguments.length===0||r.arguments.length===1&&I(r.arguments[0])):!1}return!1},x=r=>r.type==="JSXText"?r.value.trim().length>0:r.type==="JSXExpressionContainer"?v(r.expression):!1;return{JSXElement(r){let d=r.openingElement,i=r.closingElement;if(!i||d.loc.end.line===i.loc.start.line)return;let{children:s}=r,c=s.filter(l=>l.type==="JSXText"?l.value.trim()!=="":!0);if(c.length!==1)return;let o=c[0];if(!x(o)||d.loc.start.line!==d.loc.end.line)return;let t=n.getText(d),h=o.type==="JSXText"?o.value.trim():n.getText(o),p=n.getText(i);e.report({fix:l=>l.replaceText(r,`${t}${h}${p}`),message:"Simple JSX element with single text/expression child should be on one line",node:r})}}},meta:{docs:{description:"Simple JSX elements with only text/expression children should be on one line"},fixable:"whitespace",schema:[],type:"layout"}},Ct={create(e){let n=e.sourceCode||e.getSourceCode(),I=x=>x.quasis.map(r=>r.value.raw).join(" ").trim(),v=(x,r,d)=>{let{expressions:i,quasis:s}=x;if(i.length===0)return;let c=I(x);if(ne(d,c))for(let o=0;o<i.length;o+=1){let t=s[o+1];if(t&&t.value.raw.trim().length>0){e.report({fix:p=>{let l=[],a=[];s.forEach(b=>{let m=b.value.raw.trim();m&&l.push(m)}),i.forEach(b=>{a.push(n.getText(b))});let u=pe(l.join(" ")),T=a.map(b=>`\${${b}}`).join(" "),y=u?`\`${u} ${T}\``:`\`${T}\``;return p.replaceText(x,y)},message:"Dynamic expressions (${...}) must be at the end of class strings. Use: `static-class ${dynamic}` not `${dynamic} static-class`",node:r||i[o]});return}}};return{JSXAttribute(x){!x.name||x.name.name!=="className"||x.value&&x.value.type==="JSXExpressionContainer"&&x.value.expression.type==="TemplateLiteral"&&v(x.value.expression,null,"className")},VariableDeclarator(x){!x.id||x.id.type!=="Identifier"||x.init&&x.init.type==="TemplateLiteral"&&v(x.init,x.init,x.id.name)}}},meta:{docs:{description:"Enforce dynamic expressions in className are placed at the end"},fixable:"code",schema:[],type:"layout"}},At={create(e){let n=e.sourceCode||e.getSourceCode(),I=(x,r,d)=>{if(ne(d,r)&&!/^\n/.test(r)&&/  +/.test(r)){let s=n.getText(x)[0],c=r.replace(/  +/g," ");e.report({fix:o=>o.replaceText(x,`${s}${c}${s}`),message:"Class string should not have multiple consecutive spaces",node:x})}},v=(x,r)=>{let{quasis:d}=x,i=d.map(t=>t.value.raw).join(" ").trim();if(!ne(r,i))return;let s=d[0],c=s&&/^\n/.test(s.value.raw);if(!c&&s&&/^\s+/.test(s.value.raw)){e.report({fix:t=>{let p=n.getText(x).replace(/^`\s+/,"`");return t.replaceText(x,p)},message:"Class string should not have leading whitespace in template literal",node:s});return}let o=d[d.length-1];if(!c&&o&&/\s+$/.test(o.value.raw)){e.report({fix:t=>{let p=n.getText(x).replace(/\s+`$/,"`");return t.replaceText(x,p)},message:"Class string should not have trailing whitespace in template literal",node:o});return}c||d.forEach(t=>{let h=t.value.raw;/  +/.test(h)&&e.report({fix:p=>{let a=n.getText(x).replace(/  +/g," ");return p.replaceText(x,a)},message:"Class string should not have multiple consecutive spaces",node:t})})};return{JSXAttribute(x){!x.name||x.name.name!=="className"||(x.value&&x.value.type==="Literal"&&typeof x.value.value=="string"&&I(x.value,x.value.value,"className"),x.value&&x.value.type==="JSXExpressionContainer"&&x.value.expression.type==="TemplateLiteral"&&v(x.value.expression,"className"))},VariableDeclarator(x){if(!x.id||x.id.type!=="Identifier")return;let r=x.id.name;x.init&&x.init.type==="Literal"&&typeof x.init.value=="string"&&I(x.init,x.init.value,r),x.init&&x.init.type==="TemplateLiteral"&&v(x.init,r),x.init&&x.init.type==="ObjectExpression"&&x.init.properties.forEach(d=>{if(d.type==="Property"){if(d.value&&d.value.type==="Literal"&&typeof d.value.value=="string"){let i=d.value.value;if(!ne(r,i))return;let c=n.getText(d.value)[0];if(/^\s+/.test(i)){let o=i.trimStart();e.report({fix:t=>t.replaceText(d.value,`${c}${o}${c}`),message:"Class string should not have leading whitespace",node:d.value});return}if(/\s+$/.test(i)){let o=i.trimEnd();e.report({fix:t=>t.replaceText(d.value,`${c}${o}${c}`),message:"Class string should not have trailing whitespace",node:d.value});return}if(/  +/.test(i)){let o=i.replace(/  +/g," ");e.report({fix:t=>t.replaceText(d.value,`${c}${o}${c}`),message:"Class string should not have multiple consecutive spaces",node:d.value})}}if(d.value&&d.value.type==="TemplateLiteral"){let i=d.value.quasis.map(s=>s.value.raw).join(" ").trim();ne(r,i)&&v(d.value,r)}}})},ReturnStatement(x){x.argument&&(x.argument.type==="Literal"&&typeof x.argument.value=="string"&&I(x.argument,x.argument.value,"return"),x.argument.type==="TemplateLiteral"&&v(x.argument,"return"))}}},meta:{docs:{description:"Disallow extra/leading/trailing spaces in className values; smart detection for objects with Tailwind values and return statements"},fixable:"code",schema:[],type:"layout"}},$t={create(e){let n=e.sourceCode||e.getSourceCode(),I=(x,r,d)=>{if(!ne(d,r)||!ye(r))return;let i=pe(r),c=n.getText(x)[0];e.report({fix:o=>o.replaceText(x,`${c}${i}${c}`),message:"Tailwind classes should follow recommended order: layout (flex, grid) \u2192 sizing (w, h) \u2192 spacing (p, m) \u2192 typography (text, font) \u2192 colors (bg, text) \u2192 effects (shadow, opacity) \u2192 states (hover, focus)",node:x})},v=(x,r)=>{let{expressions:d,quasis:i}=x,s=i.map(o=>o.value.raw).join(" ").trim();if(!ne(r,s))return;let c=!1;for(let o of i){let t=o.value.raw.trim();if(t&&ye(t)){c=!0;break}}c&&e.report({fix:o=>{let t="`";for(let h=0;h<i.length;h+=1){let l=i[h].value.raw,a=l.match(/^\s*/)[0],u=l.match(/\s*$/)[0],T=l.trim(),y=/\n/.test(T),b;if(y&&T){let m=l.split(`
`),A=[...m.map(f=>f.trim()).filter(Boolean)].sort((f,S)=>{let $=me(f),P=me(S);return $!==P?$-P:f.localeCompare(S)}),w=m.find(f=>f.trim().length>0),E=w?w.match(/^\s*/)[0]:"",C=m[m.length-1].match(/^\s*/),g=C?C[0]:"";t+=`
`+A.map(f=>E+f).join(`
`)+`
`+g}else b=T?pe(T):"",t+=a+b+u;h<d.length&&(t+="${"+n.getText(d[h])+"}")}return t+="`",o.replaceText(x,t)},message:"Tailwind classes should follow recommended order: layout (flex, grid) \u2192 sizing (w, h) \u2192 spacing (p, m) \u2192 typography (text, font) \u2192 colors (bg, text) \u2192 effects (shadow, opacity) \u2192 states (hover, focus)",node:x})};return{VariableDeclarator(x){if(!x.id||x.id.type!=="Identifier")return;let r=x.id.name;x.init&&x.init.type==="Literal"&&typeof x.init.value=="string"&&I(x.init,x.init.value,r),x.init&&x.init.type==="TemplateLiteral"&&v(x.init,r),x.init&&x.init.type==="ObjectExpression"&&x.init.properties.forEach(d=>{if(d.type==="Property"){if(d.value&&d.value.type==="Literal"&&typeof d.value.value=="string"){let i=d.value.value;if(!ne(r,i))return;if(ye(i)){let s=pe(i),o=n.getText(d.value)[0];e.report({fix:t=>t.replaceText(d.value,`${o}${s}${o}`),message:"Tailwind classes should follow recommended order: layout (flex, grid) \u2192 sizing (w, h) \u2192 spacing (p, m) \u2192 typography (text, font) \u2192 colors (bg, text) \u2192 effects (shadow, opacity) \u2192 states (hover, focus)",node:d.value})}}if(d.value&&d.value.type==="TemplateLiteral"){let i=d.value.quasis.map(s=>s.value.raw).join(" ").trim();ne(r,i)&&v(d.value,r)}}})},ReturnStatement(x){if(x.argument){if(x.argument.type==="Literal"&&typeof x.argument.value=="string"){let r=x.argument.value;if(de(r)&&ye(r)){let d=pe(r),s=n.getText(x.argument)[0];e.report({fix:c=>c.replaceText(x.argument,`${s}${d}${s}`),message:"Tailwind classes should follow recommended order: layout (flex, grid) \u2192 sizing (w, h) \u2192 spacing (p, m) \u2192 typography (text, font) \u2192 colors (bg, text) \u2192 effects (shadow, opacity) \u2192 states (hover, focus)",node:x.argument})}}x.argument.type==="TemplateLiteral"&&v(x.argument,"return")}}}},meta:{docs:{description:"Enforce Tailwind CSS class ordering in class strings; smart detection for objects with Tailwind values and return statements"},fixable:"code",schema:[],type:"layout"}},Lt={create(e){let n=e.sourceCode||e.getSourceCode(),I=e.options[0]||{},v=I.maxClassCount??be,x=I.maxLength??ke,r=p=>{let u=n.getText().split(`
`)[p.loc.start.line-1];if(!u)return"";let T=u.match(/^(\s*)/);return T?T[1]:""},d=(p,l,a)=>{let u=a+"    ",T=p.map(y=>`${u}${y}`);return l.forEach(y=>{T.push(`${u}\${${y}}`)}),`\`
${T.join(`
`)}
${a}\``},i=(p,l)=>{let a=l+"    ";return`"
${p.map(T=>`${a}${T}`).join(`
`)}
${l}"`},s=(p,l,a)=>p.length+l>v||a>x,c=(p,l)=>{if(!/\n/.test(p))return!1;let a=l+"    ",u=p.split(`
`);if(u[0].trim()!==""||u[u.length-1]!==l)return!1;for(let T=1;T<u.length-1;T+=1){if(u[T].trim()===""||!u[T].startsWith(a))return!1;let y=u[T].slice(a.length);if(y.includes(" ")&&!y.startsWith("${"))return!1}return!0},o=p=>{let l=p;for(;l;){if(l.type==="JSXAttribute"){let a=r(l);return n.lines[l.loc.start.line-1].slice(0,l.loc.start.column).trim()?" ".repeat(l.loc.start.column):a}if(l.type==="VariableDeclarator"||l.type==="Property"||l.type==="ReturnStatement")return r(l);l=l.parent}return r(p)},t=(p,l,a)=>{if(!ne(a,l))return;let u=l.trim().split(/\s+/).filter(Boolean),T=u.join(" "),y=/\n/.test(l);if(!s(u,0,T.length)){if(y){let k=n.getText(p)[0];e.report({fix:A=>A.replaceText(p,`${k}${T}${k}`),message:"Class string under threshold should be on a single line",node:p})}return}let b=o(p);c(l,b)||e.report({fix:m=>{let k=p.parent;return k&&k.type==="JSXAttribute"?m.replaceText(p,i(u,b)):m.replaceText(p,d(u,[],b))},message:`Class strings with >${v} classes or >${x} chars should be multiline with one class per line. Example: className="\\n    flex\\n    items-center\\n"`,node:p})},h=(p,l)=>{let{expressions:a,quasis:u}=p,T=u.map(C=>C.value.raw).join(" ").trim();if(!ne(l,T))return;let y=T.split(/\s+/).filter(Boolean),b=a.map(C=>n.getText(C)),m=T.length+b.reduce((C,g)=>C+g.length+3,0),k=p.parent,A=k&&k.type==="JSXExpressionContainer"&&k.parent&&k.parent.type==="JSXAttribute";if(!s(y,b.length,m)){let C=u.map((g,f)=>g.value.raw+(f<a.length?`\${${b[f]}}`:"")).join("");if(/\n/.test(C)){let g=y.join(" ");if(A&&b.length===0)e.report({fix:f=>f.replaceText(k,`"${g}"`),message:"Class string under threshold should be on a single line",node:p});else if(b.length===0)e.report({fix:f=>f.replaceText(p,`\`${g}\``),message:"Class string under threshold should be on a single line",node:p});else{let f=[g,...b.map(S=>`\${${S}}`)];e.report({fix:S=>S.replaceText(p,`\`${f.join(" ")}\``),message:"Class string under threshold should be on a single line",node:p})}}return}let w=o(p);if(A&&b.length===0){let C=i(y,w);e.report({fix:g=>g.replaceText(k,C),message:"Use string literal instead of template literal for className with no dynamic expressions",node:p});return}let E=u.map((C,g)=>C.value.raw+(g<a.length?`\${${b[g]}}`:"")).join("");if(c(E,w))return;let L=d(y,b,w);e.report({fix:C=>C.replaceText(p,L),message:`Class strings with >${v} classes or >${x} chars should be multiline with one class per line. Example: className="\\n    flex\\n    items-center\\n"`,node:p})};return{JSXAttribute(p){!p.name||p.name.name!=="className"||(p.value&&p.value.type==="Literal"&&typeof p.value.value=="string"&&t(p.value,p.value.value,"className"),p.value&&p.value.type==="JSXExpressionContainer"&&p.value.expression.type==="TemplateLiteral"&&h(p.value.expression,"className"))},VariableDeclarator(p){if(!p.id||p.id.type!=="Identifier")return;let l=p.id.name;p.init&&p.init.type==="Literal"&&typeof p.init.value=="string"&&t(p.init,p.init.value,l),p.init&&p.init.type==="TemplateLiteral"&&h(p.init,l),p.init&&p.init.type==="ObjectExpression"&&p.init.properties.forEach(a=>{if(a.type==="Property"&&(a.value&&a.value.type==="Literal"&&typeof a.value.value=="string"&&ne(l,a.value.value)&&t(a.value,a.value.value,l),a.value&&a.value.type==="TemplateLiteral")){let u=a.value.quasis.map(T=>T.value.raw).join(" ").trim();ne(l,u)&&h(a.value,l)}})},CallExpression(p){if(!p.callee)return;let l=p.callee.name||p.callee.property&&p.callee.property.name;!l||!new Set(["cn","cva","clsx","twMerge","classnames","cx","tv","twJoin"]).has(l)||p.arguments.forEach(u=>{if(u.type==="Literal"&&typeof u.value=="string"&&t(u,u.value,"className"),u.type==="TemplateLiteral"&&h(u,"className"),u.type==="ObjectExpression"){let T=u.properties.find(y=>y.type==="Property"&&y.key&&(y.key.name==="variants"||y.key.value==="variants"));T&&T.value&&T.value.type==="ObjectExpression"&&T.value.properties.forEach(y=>{y.type!=="Property"||!y.value||y.value.type!=="ObjectExpression"||y.value.properties.forEach(b=>{b.type==="Property"&&(b.value&&b.value.type==="Literal"&&typeof b.value.value=="string"&&t(b.value,b.value.value,"className"),b.value&&b.value.type==="TemplateLiteral"&&h(b.value,"className"))})})}})},ReturnStatement(p){if(p.argument){if(p.argument.type==="Literal"&&typeof p.argument.value=="string"){let l=p.argument.value;de(l)&&t(p.argument,l,"return")}if(p.argument.type==="TemplateLiteral"){let l=p.argument.quasis.map(a=>a.value.raw).join(" ").trim();de(l)&&h(p.argument,"return")}}}}},meta:{docs:{description:"Enforce multiline formatting for long className strings; smart detection for objects with Tailwind values, return statements, and class utility calls (cn, cva, clsx)"},fixable:"code",schema:[{additionalProperties:!1,properties:{maxClassCount:{default:3,minimum:1,type:"integer"},maxLength:{default:80,minimum:1,type:"integer"}},type:"object"}],type:"layout"}},It={create(e){let n=e.sourceCode||e.getSourceCode();return{JSXAttribute:v=>{if(!v.value||v.value.type!=="Literal"||typeof v.value.value!="string")return;let x=v.value.value;if(v.name&&v.name.name==="className"&&/^\n/.test(x))return;let r=x.trim();if(x!==r){let i=n.getText(v.value)[0];e.report({fix:s=>s.replaceText(v.value,`${i}${r}${i}`),message:"JSX string value should not have leading or trailing whitespace",node:v.value})}}}},meta:{docs:{description:"Disallow leading/trailing whitespace in JSX string values"},fixable:"code",schema:[],type:"layout"}},Pt={create(e){let n=e.sourceCode||e.getSourceCode(),I=i=>{let c=n.lines[i.loc.start.line-1].match(/^(\s*)/);return c?c[1]:""},v=i=>i.type!=="JSXElement"&&i.type!=="JSXFragment"?!1:i.loc.start.line===i.loc.end.line,x=i=>{let s=n.getTokenBefore(i),c=n.getTokenAfter(i);return s&&c&&s.value==="("&&c.value===")"},r=i=>{if(i.type==="BinaryExpression"){let s=i.left.loc.end.line,c=i.right.loc.start.line;return s!==c?!0:r(i.left)||r(i.right)}if(i.type==="LogicalExpression"){let s=i.left.loc.end.line,c=i.right.loc.start.line;return s!==c?!0:r(i.left)||r(i.right)}return!1},d=i=>n.getText(i).replace(/\s*\n\s*/g," ").trim();return{ConditionalExpression(i){let s=i.parent,c=s&&s.type==="JSXExpressionContainer",o=s&&s.type==="ReturnStatement",t=s&&s.type==="ArrowFunctionExpression"&&s.body===i;if(!c&&!o&&!t)return;let{alternate:h,consequent:p}=i,l=p.type==="JSXElement"||p.type==="JSXFragment",a=h.type==="JSXElement"||h.type==="JSXFragment";if(!l&&!a)return;let u=v(p),T=v(h),y=I(i),b=y+"    ";if(r(i.test)){let f=d(i.test);e.report({fix:S=>S.replaceText(i.test,f),message:"Ternary condition should not be broken across multiple lines",node:i.test})}if(c){let f=n.getFirstToken(s);f&&f.value==="{"&&f.loc.end.line!==i.test.loc.start.line&&e.report({fix:S=>S.replaceTextRange([f.range[1],i.test.range[0]],""),message:"Ternary condition should be on same line as opening '{'",node:i.test})}let m=n.getTokenAfter(i.test,f=>f.value==="?");if(!m)return;let k=n.getTokenAfter(p,f=>f.value===":");if(!k)return;let A=c?n.getLastToken(s):null;if(u&&x(p)){let f=n.getTokenBefore(p),S=n.getTokenAfter(p);e.report({fix:$=>[$.remove(f),$.remove(S)],message:"Unnecessary parentheses around simple JSX element",node:p})}if(T&&x(h)){let f=n.getTokenBefore(h),S=n.getTokenAfter(h);e.report({fix:$=>[$.remove(f),$.remove(S)],message:"Unnecessary parentheses around simple JSX element",node:h})}if(u&&T){if(i.loc.start.line!==i.loc.end.line){let f=n.getText(i.test),S=n.getText(p),$=n.getText(h);e.report({fix:P=>P.replaceText(i,`${f} ? ${S} : ${$}`),message:"Simple ternary with single-line JSX should be on one line",node:i})}return}if(u&&l&&!a){i.test.loc.end.line!==m.loc.start.line&&e.report({fix:f=>f.replaceTextRange([i.test.range[1],m.range[0]]," "),message:"'?' should be on same line as condition",node:m}),m.loc.end.line!==p.loc.start.line&&e.report({fix:f=>f.replaceTextRange([m.range[1],p.range[0]]," "),message:"Simple JSX should be on same line as '?'",node:p}),p.loc.end.line!==k.loc.start.line&&e.report({fix:f=>f.replaceTextRange([p.range[1],k.range[0]]," "),message:"':' should be on same line as simple JSX",node:k}),k.loc.end.line!==h.loc.start.line&&e.report({fix:f=>f.replaceTextRange([k.range[1],h.range[0]]," "),message:"Expression should start on same line as ':'",node:h});return}if(u&&!T&&a){i.test.loc.end.line!==m.loc.start.line&&e.report({fix:$=>$.replaceTextRange([i.test.range[1],m.range[0]]," "),message:"'?' should be on same line as condition",node:m}),m.loc.end.line!==p.loc.start.line&&e.report({fix:$=>$.replaceTextRange([m.range[1],p.range[0]]," "),message:"Simple JSX should be on same line as '?'",node:p}),p.loc.end.line!==k.loc.start.line&&e.report({fix:$=>$.replaceTextRange([p.range[1],k.range[0]]," "),message:"':' should be on same line as simple JSX",node:k});let f=n.getTokenAfter(k);if(f&&f.value==="("){k.loc.end.line!==f.loc.start.line&&e.report({fix:P=>P.replaceTextRange([k.range[1],f.range[0]]," "),message:"'(' should be on same line as ':'",node:f});let $=n.getTokenAfter(f);$&&f.loc.end.line===$.loc.start.line&&e.report({fix:P=>P.replaceTextRange([f.range[1],$.range[0]],`
`+b),message:"Complex JSX should start on new line after '('",node:h})}let S=n.getLastToken(i);if(S&&S.value===")"){let $=n.getTokenBefore(S);$&&$.value!=="("&&$.loc.end.line===S.loc.start.line&&e.report({fix:P=>P.replaceTextRange([$.range[1],S.range[0]],`
`+y),message:"Closing ')' should be on new line",node:S}),A&&A.value==="}"&&S.loc.end.line!==A.loc.start.line&&e.report({fix:P=>P.replaceTextRange([S.range[1],A.range[0]],""),message:"Closing ')}' should be together",node:A})}return}if(!u&&T&&l){let f=n.getTokenAfter(m);if(f&&f.value==="("){i.test.loc.end.line!==m.loc.start.line&&e.report({fix:R=>R.replaceTextRange([i.test.range[1],m.range[0]]," "),message:"'?' should be on same line as condition",node:m}),m.loc.end.line!==f.loc.start.line&&e.report({fix:R=>R.replaceTextRange([m.range[1],f.range[0]]," "),message:"'(' should be on same line as '?'",node:f});let P=n.getTokenAfter(f);P&&f.loc.end.line===P.loc.start.line&&e.report({fix:R=>R.replaceTextRange([f.range[1],P.range[0]],`
`+b),message:"Complex JSX should start on new line after '('",node:p})}let S=n.getTokenBefore(k);if(S&&S.value===")"){let P=n.getTokenBefore(S);P&&P.loc.end.line===S.loc.start.line&&e.report({fix:R=>R.replaceTextRange([P.range[1],S.range[0]],`
`+y),message:"Closing ')' should be on new line after complex JSX",node:S}),S.loc.end.line!==k.loc.start.line&&e.report({fix:R=>R.replaceTextRange([S.range[1],k.range[0]]," "),message:"':' should be on same line as ')'",node:k})}let $=n.getTokenAfter(k);if($&&$.value==="("){let P=n.getTokenAfter(h);if(P&&P.value===")"){let R=n.getText(h);e.report({fix:F=>F.replaceTextRange([k.range[1],P.range[1]],` ${R}`),message:"Simple JSX should not be wrapped in parentheses; put on same line as ':'",node:h});return}}k.loc.end.line!==h.loc.start.line&&e.report({fix:P=>P.replaceTextRange([k.range[1],h.range[0]]," "),message:"Simple JSX should be on same line as ':'",node:h}),A&&A.value==="}"&&h.loc.end.line!==A.loc.start.line&&e.report({fix:P=>P.replaceTextRange([h.range[1],A.range[0]],""),message:"'}' should be on same line as simple JSX",node:A});return}let w=!a&&(h.type==="Literal"||h.type==="Identifier"||h.type==="MemberExpression"&&h.loc.start.line===h.loc.end.line);if(!u&&l&&w){let f=n.getTokenAfter(m);if(f&&f.value==="("){i.test.loc.end.line!==m.loc.start.line&&e.report({fix:P=>P.replaceTextRange([i.test.range[1],m.range[0]]," "),message:"'?' should be on same line as condition",node:m}),m.loc.end.line!==f.loc.start.line&&e.report({fix:P=>P.replaceTextRange([m.range[1],f.range[0]]," "),message:"'(' should be on same line as '?'",node:f});let $=n.getTokenAfter(f);$&&f.loc.end.line===$.loc.start.line?e.report({fix:P=>P.replaceTextRange([f.range[1],$.range[0]],`
`+b),message:"Complex JSX should start on new line after '('",node:p}):$&&$.loc.start.line-f.loc.end.line>1&&e.report({fix:P=>P.replaceTextRange([f.range[1],$.range[0]],`
`+b),message:"No empty lines after '(' in ternary",node:$})}let S=n.getTokenBefore(k);if(S&&S.value===")"){let $=n.getTokenBefore(S);$&&$.loc.end.line===S.loc.start.line?e.report({fix:P=>P.replaceTextRange([$.range[1],S.range[0]],`
`+y),message:"Closing ')' should be on new line after complex JSX",node:S}):S.loc.start.line-$.loc.end.line>1&&e.report({fix:P=>P.replaceTextRange([$.range[1],S.range[0]],`
`+y),message:"No empty lines before ')' in ternary",node:S}),S.loc.end.line!==k.loc.start.line&&e.report({fix:P=>P.replaceTextRange([S.range[1],k.range[0]]," "),message:"':' should be on same line as ')'",node:k})}k.loc.end.line!==h.loc.start.line&&e.report({fix:$=>$.replaceTextRange([k.range[1],h.range[0]]," "),message:"Simple expression should be on same line as ':'",node:h});return}if(!l||!a)return;let E=n.getTokenAfter(m);if(E&&E.value==="("){i.test.loc.end.line!==m.loc.start.line&&e.report({fix:S=>S.replaceTextRange([i.test.range[1],m.range[0]]," "),message:"'?' should be on same line as condition",node:m}),m.loc.end.line!==E.loc.start.line&&e.report({fix:S=>S.replaceTextRange([m.range[1],E.range[0]]," "),message:"'(' should be on same line as '?'",node:E});let f=n.getTokenAfter(E);f&&E.loc.end.line===f.loc.start.line?e.report({fix:S=>S.replaceTextRange([E.range[1],f.range[0]],`
`+b),message:"Complex JSX should start on new line after '('",node:p}):f&&f.loc.start.line-E.loc.end.line>1&&e.report({fix:S=>S.replaceTextRange([E.range[1],f.range[0]],`
`+b),message:"No empty lines after '(' in ternary",node:f})}let L=n.getTokenBefore(k),C=n.getTokenAfter(k);if(L&&L.value===")"){let f=n.getTokenBefore(L);f&&f.loc.end.line===L.loc.start.line?e.report({fix:S=>S.replaceTextRange([f.range[1],L.range[0]],`
`+y),message:"Closing ')' should be on new line after complex JSX",node:L}):f&&L.loc.start.line-f.loc.end.line>1&&e.report({fix:S=>S.replaceTextRange([f.range[1],L.range[0]],`
`+y),message:"No empty lines before ')' in ternary",node:L}),L.loc.end.line!==k.loc.start.line&&e.report({fix:S=>S.replaceTextRange([L.range[1],k.range[0]]," "),message:"':' should be on same line as ')'",node:k})}if(C&&C.value==="("){k.loc.end.line!==C.loc.start.line&&e.report({fix:S=>S.replaceTextRange([k.range[1],C.range[0]]," "),message:"'(' should be on same line as ':'",node:C});let f=n.getTokenAfter(C);f&&C.loc.end.line===f.loc.start.line?e.report({fix:S=>S.replaceTextRange([C.range[1],f.range[0]],`
`+b),message:"Complex JSX should start on new line after '('",node:h}):f&&f.loc.start.line-C.loc.end.line>1&&e.report({fix:S=>S.replaceTextRange([C.range[1],f.range[0]],`
`+b),message:"No empty lines after '(' in ternary",node:f})}let g=n.getLastToken(i);if(g&&g.value===")"){let f=n.getTokenBefore(g);f&&f.value!=="("&&f.loc.end.line===g.loc.start.line?e.report({fix:S=>S.replaceTextRange([f.range[1],g.range[0]],`
`+y),message:"Closing ')' should be on new line",node:g}):f&&f.value!=="("&&g.loc.start.line-f.loc.end.line>1&&e.report({fix:S=>S.replaceTextRange([f.range[1],g.range[0]],`
`+y),message:"No empty lines before ')' in ternary",node:g}),A&&A.value==="}"&&g.loc.end.line!==A.loc.start.line&&e.report({fix:S=>S.replaceTextRange([g.range[1],A.range[0]],""),message:"Closing ')}' should be together on same line",node:A})}}}},meta:{docs:{description:"Enforce consistent formatting for JSX ternary expressions"},fixable:"whitespace",schema:[],type:"layout"}},Rt={create(e){let n=e.sourceCode||e.getSourceCode(),I=i=>{let{children:s,closingElement:c,openingElement:o}=i;if(!c)return;let t=s.filter(l=>l.type!=="JSXText"||l.value.trim()!=="");if(t.length===0)return;let h=t[0],p=t[t.length-1];h.loc.start.line-o.loc.end.line>1&&e.report({fix:l=>l.replaceTextRange([o.range[1],h.range[0]],`
`+" ".repeat(h.loc.start.column)),message:"No empty line after opening JSX tag",node:h}),c.loc.start.line-p.loc.end.line>1&&e.report({fix:l=>l.replaceTextRange([p.range[1],c.range[0]],`
`+" ".repeat(c.loc.start.column)),message:"No empty line before closing JSX tag",node:c})},v=i=>i.loc.start.line===i.loc.end.line;return{ArrowFunctionExpression:i=>{if(!i.body||i.body.type==="BlockStatement")return;let s=i.body,c=n.getTokenBefore(s,h=>h.value==="=>");if(!c)return;let o=n.getTokenAfter(c);o&&o.value==="("&&s.loc.start.line-o.loc.end.line>1&&e.report({fix:h=>h.replaceTextRange([o.range[1],s.range[0]],`
`+" ".repeat(s.loc.start.column)),message:"No empty line allowed after opening parenthesis in arrow function",node:s});let t=n.getTokenAfter(s);t&&t.value===")"&&t.loc.start.line-s.loc.end.line>1&&e.report({fix:h=>h.replaceTextRange([s.range[1],t.range[0]],`
`+" ".repeat(t.loc.start.column)),message:"No empty line allowed before closing parenthesis in arrow function",node:s})},JSXElement:I,JSXOpeningElement:i=>{let{attributes:s,name:c}=i,o=n.getFirstToken(c),t=n.getLastToken(i);if(s.length===0)return;let h=s[0],p=s[s.length-1],l=o.loc.start.line===t.loc.end.line,a=s.length===1&&v(h);if(!i.selfClosing&&a&&l){let y=n.getTokenBefore(t);if(y){let b=n.text.slice(y.range[1],t.range[0]);(b.includes(" ")||b.includes(`
`))&&e.report({fix:m=>m.replaceTextRange([y.range[1],t.range[0]],""),message:"No space before closing bracket in non-self-closing JSX element",node:t})}}if(s.length===1&&v(h)&&h.loc.start.line!==o.loc.end.line){let y=n.getText(h),b=i.selfClosing,m=t.range[0],k="";b&&(k=" /"),e.report({fix:A=>A.replaceTextRange([o.range[1],m],` ${y}${k}`),message:"Single simple JSX prop should be on the same line as element",node:h});return}h.loc.start.line-o.loc.end.line>1&&e.report({fix:y=>y.replaceTextRange([o.range[1],h.range[0]],`
`+" ".repeat(h.loc.start.column)),message:"No empty line after JSX element name",node:h});let u=t.range[0],T=t.loc.start.column;if(i.selfClosing){let y=n.getTokenBefore(t);y&&y.value==="/"&&(u=y.range[0],T=y.loc.start.column)}t.loc.start.line-p.loc.end.line>1&&e.report({fix:y=>y.replaceTextRange([p.range[1],u],`
`+" ".repeat(T)),message:"No empty line before closing bracket",node:p});for(let y=0;y<s.length-1;y+=1){let b=s[y],m=s[y+1];m.loc.start.line-b.loc.end.line>1&&e.report({fix:k=>k.replaceTextRange([b.range[1],m.range[0]],`
`+" ".repeat(m.loc.start.column)),message:"No empty line between JSX props",node:m})}},ReturnStatement:i=>{let s=i.argument;if(!s)return;let c=n.getText(),o=c.slice(i.range[0],s.range[0]),t=o.indexOf("(");t!==-1&&o.slice(t+1).split(`
`).length>2&&e.report({fix:a=>a.replaceTextRange([i.range[0]+t+1,s.range[0]],`
`+" ".repeat(s.loc.start.column)),message:"No empty line allowed after opening parenthesis in return",node:s});let h=c.slice(s.range[1],i.range[1]),p=h.lastIndexOf(")");if(p!==-1&&h.slice(0,p).split(`
`).length>2){let a=s.range[1]+p,u=c.slice(0,a).split(`
`).pop().match(/^\s*/)[0];e.report({fix:T=>T.replaceTextRange([s.range[1],a],`
`+u),message:"No empty line allowed before closing parenthesis in return",node:i})}}}},meta:{docs:{description:"Disallow empty lines in JSX"},fixable:"whitespace",schema:[],type:"layout"}};var Ft={create(e){let n=e.sourceCode||e.getSourceCode(),I=(v,x=!1)=>{let{properties:r}=v;if(r.length===0||x&&v.typeAnnotation)return;let d=n.getFirstToken(v),i=n.getLastToken(v),s=r[0],c=r[r.length-1];s.loc.start.line-d.loc.end.line>1&&e.report({fix:o=>o.replaceTextRange([d.range[1],s.range[0]],`
`+" ".repeat(s.loc.start.column)),message:"No empty line after opening brace",node:s}),i.loc.start.line-c.loc.end.line>1&&e.report({fix:o=>o.replaceTextRange([c.range[1],i.range[0]],`
`+" ".repeat(i.loc.start.column)),message:"No empty line before closing brace",node:c});for(let o=0;o<r.length-1;o+=1){let t=r[o],h=r[o+1];if(h.loc.start.line-t.loc.end.line>1){let p=n.getTokenAfter(t);for(;p&&p.value!==","&&p.range[0]<h.range[0];)p=n.getTokenAfter(p);let l=p&&p.value===","&&p.loc.start.line!==t.loc.end.line;e.report({fix:a=>l?a.replaceTextRange([t.range[1],h.range[0]],`,
`+" ".repeat(h.loc.start.column)):a.replaceTextRange([p&&p.value===","?p.range[1]:t.range[1],h.range[0]],`
`+" ".repeat(h.loc.start.column)),message:"No empty line between object properties",node:h})}}};return{ObjectExpression:v=>I(v,!1),ObjectPattern:v=>I(v,!0)}},meta:{docs:{description:"Disallow empty lines in objects"},fixable:"whitespace",schema:[],type:"layout"}},Bt={create(e){let n=e.sourceCode||e.getSourceCode(),I=e.options[0]||{},v=I.minProperties!==void 0?I.minProperties:2,x=i=>{if(!i||["Literal","Identifier","MemberExpression","UnaryExpression"].includes(i.type))return!0;if(i.type==="TemplateLiteral"||i.type==="CallExpression"||i.type==="ArrowFunctionExpression")return i.loc.start.line===i.loc.end.line;if(i.type==="ConditionalExpression")return n.getText(i).replace(/\s*\n\s*/g," ").trim().length<=80;if(i.type==="LogicalExpression")return n.getText(i).replace(/\s*\n\s*/g," ").trim().length<=80;if(i.type==="BinaryExpression")return n.getText(i).replace(/\s*\n\s*/g," ").trim().length<=80;if(i.type==="SpreadElement")return x(i.argument);if(i.type==="ArrayExpression")return i.loc.start.line===i.loc.end.line;if(i.type==="ObjectExpression"){let{properties:s}=i;return s.length===0?!0:s.length>=v?!1:s.every(c=>c.type==="SpreadElement"?x(c.argument):x(c.value))}return!1},r=i=>{if(!i)return"";if(i.type==="ArrayExpression")return n.getText(i).replace(/\s+/g," ").trim();if(i.type==="ObjectExpression"){let{properties:s}=i;return s.length===0?"{}":`{ ${s.map(o=>{if(o.type==="SpreadElement")return`...${r(o.argument)}`;let t=o.computed?`[${n.getText(o.key)}]`:n.getText(o.key),h=r(o.value);return o.shorthand?t:`${t}: ${h}`}).join(", ")} }`}return n.getText(i).trim()},d=i=>{let{properties:s}=i;if(s.length===0)return;if(i.type==="ObjectPattern"){let u=i.parent;for(;u;){if((u.type==="FunctionDeclaration"||u.type==="FunctionExpression"||u.type==="ArrowFunctionExpression")&&u.params&&u.params.includes(i))return;if(u.type==="Property"&&u.parent&&u.parent.type==="ObjectPattern"){u=u.parent;continue}if(u.type==="FunctionDeclaration"||u.type==="FunctionExpression"||u.type==="ArrowFunctionExpression"){let T=i,y=!1;for(;T&&T!==u;){if(u.params&&u.params.some(b=>b===T||c(b,T))){y=!0;break}T=T.parent}if(y)return}u=u.parent}}function c(u,T){let y=T;for(;y;){if(y===u)return!0;y=y.parent}return!1}let o=n.getFirstToken(i),t=n.getLastToken(i),h=s[0],p=s[s.length-1];if(!o||!t||o.value!=="{"||t.value!=="}")return;if(s.length<v){let u=o.loc.start.line!==t.loc.end.line,T=s.every(y=>y.type==="SpreadElement"?x(y.argument):x(y.value));if(u&&T){let y=s.map(b=>{if(b.type==="SpreadElement")return`...${r(b.argument)}`;let m=b.computed?`[${n.getText(b.key)}]`:n.getText(b.key),k=r(b.value);return b.shorthand?m:`${m}: ${k}`}).join(", ");e.report({fix:b=>b.replaceTextRange([o.range[0],t.range[1]],`{ ${y} }`),message:`Objects with <${v} properties should be single line: { key: value }. Multi-line only for ${v}+ properties`,node:i});return}if(!T&&u){let y=" ".repeat(o.loc.start.column),b=y+"    ";o.loc.end.line===h.loc.start.line&&e.report({fix:m=>m.replaceTextRange([o.range[1],h.range[0]],`
`+b),message:"Property with complex value should be on its own line",node:h}),t.loc.start.line===p.loc.end.line&&e.report({fix:m=>{let k=n.getTokenAfter(p);return k&&k.value===","?m.replaceTextRange([k.range[1],t.range[0]],`
`+y):m.replaceTextRange([p.range[1],t.range[0]],`,
`+y)},message:"Closing brace should be on its own line for object with complex value",node:t})}return}let l=" ".repeat(o.loc.start.column),a=l+"    ";o.loc.end.line===h.loc.start.line&&e.report({fix:u=>u.replaceTextRange([o.range[1],h.range[0]],`
`+a),message:`Objects with ${v}+ properties should have first property on its own line`,node:h}),t.loc.start.line===p.loc.end.line&&e.report({fix:u=>{let T=n.getLastToken(p),y=n.getTokenAfter(p);return y&&y.value===","?u.replaceTextRange([y.range[1],t.range[0]],`
`+l):u.replaceTextRange([T.range[1],t.range[0]],`,
`+l)},message:`Objects with ${v}+ properties should have closing brace on its own line`,node:t});for(let u=0;u<s.length-1;u+=1){let T=s[u],y=s[u+1];if(T.loc.end.line===y.loc.start.line){let b=n.getTokenAfter(T,m=>m.value===",");e.report({fix:m=>m.replaceTextRange([b.range[1],y.range[0]],`
`+a),message:"Each property should be on its own line",node:y})}}for(let u of s)if(u.type==="SpreadElement"&&u.argument){let T=u.argument,y=u.loc.start.line!==T.loc.start.line,b=T.type==="LogicalExpression"&&T.loc.start.line!==T.loc.end.line;if(y||b){if(T.type==="LogicalExpression"){if(T.right.type==="ObjectExpression"&&T.right.properties.length===1&&T.right.properties[0].type!=="SpreadElement"||T.right.type==="Identifier"){let k=n.getText(u).replace(/\s*\n\s*/g," ").replace(/\.\.\.\s+/,"...").trim();e.report({fix:A=>A.replaceText(u,k),message:"Spread element with logical expression should be on a single line",node:u})}}else if(y){let m=n.getText(u).replace(/\s*\n\s*/g," ").replace(/\.\.\.\s+/,"...").trim();e.report({fix:k=>k.replaceText(u,m),message:"Spread operator should be on the same line as its argument",node:u})}}}};return{ObjectExpression:d,ObjectPattern:d}},meta:{docs:{description:"Enforce object formatting: collapse to single line when < minProperties (including nested objects/arrays), expand to multiline when >= minProperties"},fixable:"whitespace",schema:[{additionalProperties:!1,properties:{minProperties:{default:2,description:"Minimum properties to enforce multiline formatting (default: 2)",minimum:1,type:"integer"}},type:"object"}],type:"layout"}},Ht={create(e){let n=e.sourceCode||e.getSourceCode();return{Property(I){let{value:v}=I;if(v.type!=="ObjectExpression")return;let x=n.getTokenBefore(v,d=>d.value===":");if(!x)return;let r=n.getFirstToken(v);!r||r.value!=="{"||x.loc.end.line!==r.loc.start.line&&e.report({fix:d=>d.replaceTextRange([x.range[1],r.range[0]]," "),message:"Opening brace should be on the same line as colon for object property values",node:r})}}},meta:{docs:{description:"Enforce opening brace on same line as colon for object property values"},fixable:"code",schema:[],type:"layout"}},Ot={create(e){let n=e.sourceCode||e.getSourceCode();return{Property:v=>{if(v.shorthand||v.computed)return;let x=n.getTokenAfter(v.key,i=>i.value===":");if(!x)return;let r=v.value,d=n.text.slice(x.range[1],x.range[1]+1);if(d!==" "&&d!==`
`){e.report({fix:i=>i.insertTextAfter(x," "),message:"Missing space after colon in object property",node:x});return}if(r.type==="ArrowFunctionExpression"||r.type==="FunctionExpression"){r.loc.start.line>x.loc.end.line&&e.report({fix:i=>i.replaceTextRange([x.range[1],r.range[0]]," "),message:"Arrow function should start on the same line as the colon",node:r});return}if(r.type==="JSXElement"||r.type==="JSXFragment"){let i=n.getTokenAfter(x),s=i&&i.value==="(",c=p=>{if(p.type==="JSXFragment"||p.openingElement.attributes.length>0)return!1;let a=(p.children||[]).filter(u=>u.type==="JSXText"?u.value.trim().length>0:!0);return a.length===0||a.length===1&&a[0].type==="JSXText"},o=p=>{let l=p.openingElement.name.name,u=(p.children||[]).filter(T=>T.type==="JSXText").map(T=>T.value.trim()).join("").trim();return u?`<${l}>${u}</${l}>`:`<${l} />`};if(c(r)){let p=o(r);if(!(n.getText(r)===p&&!s&&x.loc.end.line===r.loc.start.line)){let u=n.getTokenAfter(r);if(s){let m=n.getTokenAfter(r);u=n.getTokenAfter(m)}let T=u&&u.value===",",y=s?n.getTokenAfter(r):null,b=T?u.range[1]:y?y.range[1]:r.range[1];e.report({fix:m=>m.replaceTextRange([x.range[1],b],` ${p}${T?",":""}`),message:"Simple JSX should be inline with property",node:r})}return}if(r.loc.start.line!==r.loc.end.line&&!s){let p=n.getText(r),l=" ".repeat(x.loc.start.column),a=n.getTokenAfter(r),u=a&&a.value===",",T=u?a.range[1]:r.range[1],y=u?",":"";e.report({fix:b=>b.replaceTextRange([x.range[1],T],` (
${l}    ${p.split(`
`).join(`
`+l+"    ")}
${l})${y}`),message:"Multi-line JSX in object property must be wrapped in parentheses",node:r})}return}if(r.type==="ConditionalExpression"){let s=n.getText(r).replace(/\s*\n\s*/g," ").trim();if(r.loc.start.line!==r.loc.end.line&&s.length<=80){e.report({fix:h=>h.replaceText(r,s),message:"Short ternary expression should be on a single line",node:r});return}let o=n.getTokenAfter(r.test,h=>h.value==="?"),t=n.getTokenAfter(r.consequent,h=>h.value===":");if(o){let h=n.getTokenAfter(o);if(h&&o.loc.end.line<h.loc.start.line&&s.length<=80){e.report({fix:p=>p.replaceText(r,s),message:"Ternary operator '?' should not be at end of line",node:o});return}}if(t){let h=n.getTokenAfter(t);if(h&&t.loc.end.line<h.loc.start.line&&s.length<=80){e.report({fix:p=>p.replaceText(r,s),message:"Ternary operator ':' should not be at end of line",node:t});return}}return}if(r.loc.start.line>x.loc.end.line){if((r.type==="ObjectExpression"||r.type==="ArrayExpression")&&r.loc.start.line!==r.loc.end.line)return;let i=n.getTokenAfter(x);if(i&&i.value==="(")return;e.report({fix:s=>s.replaceTextRange([x.range[1],r.range[0]]," "),message:"Property value should be on the same line as the colon",node:r})}}}},meta:{docs:{description:"Enforce property value on same line as colon with proper spacing"},fixable:"whitespace",schema:[],type:"layout"}},jt={create(e){let n=e.sourceCode||e.getSourceCode();return{Property(I){let{key:v}=I;if(v.type!=="Literal"||typeof v.value!="string")return;let x=v.value,r=x.trim();x!==r&&r.length>0&&e.report({fix:d=>d.replaceText(v,`"${r}"`),message:`String property key should not have extra spaces inside quotes: "${r}" not "${x}"`,node:v})}}},meta:{docs:{description:"Enforce no extra spaces inside string property keys"},fixable:"code",schema:[],type:"layout"}};var Mt={create(e){let n={CALLBACK:12,CONTEXT_HOOK:8,CUSTOM_HOOK:9,DERIVED_STATE:10,EFFECT:14,HANDLER_FUNCTION:13,MEMO:11,PROPS_DESTRUCTURE:1,PROPS_DESTRUCTURE_BODY:2,REDUCER:5,REF:3,RETURN:15,ROUTER_HOOK:7,SELECTOR_DISPATCH:6,STATE:4,UNKNOWN:99},I={1:"props destructure",2:"destructured variables from props",3:"useRef",4:"useState",5:"useReducer",6:"useSelector/useDispatch",7:"router hooks",8:"context hooks",9:"custom hooks",10:"derived state/computed variables",11:"useMemo",12:"useCallback",13:"handler functions",14:"useEffect/useLayoutEffect",15:"return statement",99:"unknown"},v=new Set(["useState"]),x=new Set(["useRef"]),r=new Set(["useReducer"]),d=new Set(["useEffect","useLayoutEffect"]),i=new Set(["useMemo"]),s=new Set(["useCallback"]),c=new Set(["useSelector","useDispatch","useStore"]),o=new Set(["useNavigate","useLocation","useParams","useSearchParams","useRouter","usePathname","useMatch","useMatches","useRouteLoaderData","useNavigation","useResolvedPath","useHref","useInRouterContext","useNavigationType","useOutlet","useOutletContext","useRouteError","useRoutes","useBlocker"]),t=new Set(["useContext","useToast","useTheme","useAuth","useModal","useDialog","useNotification","useI18n","useTranslation","useIntl","useForm","useFormContext"]),h=E=>{if(!E)return!1;if(E.type==="JSXElement"||E.type==="JSXFragment")return!0;if(E.type==="BlockStatement"){for(let L of E.body)if(L.type==="ReturnStatement"&&L.argument&&h(L.argument))return!0}return E.type==="ConditionalExpression"?h(E.consequent)||h(E.alternate):E.type==="LogicalExpression"?h(E.left)||h(E.right):E.type==="ParenthesizedExpression"?h(E.expression):!1},p=E=>{if(E.parent){if(E.parent.type==="VariableDeclarator"&&E.parent.id&&E.parent.id.type==="Identifier")return E.parent.id.name;if(E.id&&E.id.type==="Identifier")return E.id.name}return null},l=E=>{let L=p(E);if(L&&/^[A-Z]/.test(L)){let C=E.body;return h(C)}return!1},a=E=>{let L=p(E);return L&&/^use[A-Z]/.test(L)?!(E.body.type!=="BlockStatement"||h(E.body)):!1},u=E=>E.type!=="CallExpression"?null:E.callee.type==="Identifier"?E.callee.name:E.callee.type==="MemberExpression"&&E.callee.property.type==="Identifier"?E.callee.property.name:null,T=E=>{let L=u(E);return L&&/^use[A-Z]/.test(L)},y=E=>E&&(E.type==="ArrowFunctionExpression"||E.type==="FunctionExpression"),b=E=>{if(E.type==="VariableDeclaration"){let L=E.declarations[0];if(L&&L.init&&y(L.init))return L.init.type!=="CallExpression"}return E.type==="FunctionDeclaration"},m=(E,L=new Set)=>{if(E.type==="ReturnStatement")return n.RETURN;if(E.type==="ExpressionStatement"&&E.expression.type==="CallExpression"){let C=u(E.expression);if(C){if(d.has(C))return n.EFFECT;if(T(E.expression))return n.CUSTOM_HOOK}return n.UNKNOWN}if(E.type==="VariableDeclaration"){let C=E.declarations;for(let g of C)if(g.init){if(g.init.type==="CallExpression"){let f=u(g.init);if(f){if(v.has(f))return n.STATE;if(x.has(f))return n.REF;if(r.has(f))return n.REDUCER;if(c.has(f))return n.SELECTOR_DISPATCH;if(o.has(f))return n.ROUTER_HOOK;if(t.has(f))return n.CONTEXT_HOOK;if(i.has(f))return n.MEMO;if(s.has(f))return n.CALLBACK;if(T(g.init))return n.CUSTOM_HOOK}}if(y(g.init))return n.HANDLER_FUNCTION}for(let g of C)if(g.id.type==="ObjectPattern"&&g.init){if(g.init.type==="Identifier"&&L.has(g.init.name))return n.PROPS_DESTRUCTURE_BODY;if(g.init.type==="MemberExpression"){let f=g.init;for(;f.type==="MemberExpression";)f=f.object;if(f.type==="Identifier"&&L.has(f.name))return n.PROPS_DESTRUCTURE_BODY}if(g.init.type==="Identifier"&&g.init.name==="props")return n.PROPS_DESTRUCTURE}for(let g of C)if(g.init&&g.init.type==="CallExpression"){let f=g.init.callee;if(f&&f.type==="Identifier"&&!T(g.init))return n.HANDLER_FUNCTION}return n.DERIVED_STATE}return E.type==="FunctionDeclaration"?n.HANDLER_FUNCTION:n.UNKNOWN},k=(E,L)=>{let C=E.body,g=e.sourceCode||e.getSourceCode();if(C.type!=="BlockStatement")return;let f=C.body;if(f.length===0)return;let S=new Set;for(let O of E.params)if(O.type==="Identifier")S.add(O.name);else if(O.type==="ObjectPattern")for(let N of O.properties)N.type==="Property"&&N.value?N.value.type==="Identifier"?S.add(N.value.name):N.value.type==="AssignmentPattern"&&N.value.left.type==="Identifier"&&S.add(N.value.left.name):N.type==="RestElement"&&N.argument.type==="Identifier"&&S.add(N.argument.name);else if(O.type==="AssignmentPattern"&&O.left){if(O.left.type==="Identifier")S.add(O.left.name);else if(O.left.type==="ObjectPattern")for(let N of O.left.properties)N.type==="Property"&&N.value&&(N.value.type==="Identifier"?S.add(N.value.name):N.value.type==="AssignmentPattern"&&N.value.left.type==="Identifier"&&S.add(N.value.left.name))}let $=O=>O.type==="VariableDeclaration"||O.type==="FunctionDeclaration"||O.type==="ExpressionStatement"||O.type==="ReturnStatement",P=O=>{let N=new Set;if(O.type==="VariableDeclaration"){for(let z of O.declarations)if(z.id.type==="Identifier")N.add(z.id.name);else if(z.id.type==="ObjectPattern")for(let Z of z.id.properties)Z.type==="Property"&&Z.value.type==="Identifier"?N.add(Z.value.name):Z.type==="RestElement"&&Z.argument.type==="Identifier"&&N.add(Z.argument.name);else if(z.id.type==="ArrayPattern")for(let Z of z.id.elements)Z&&Z.type==="Identifier"&&N.add(Z.name)}else O.type==="FunctionDeclaration"&&O.id&&N.add(O.id.name);return N},R=(O,N=new Set)=>(O&&(O.type==="Identifier"?N.add(O.name):O.type==="MemberExpression"?R(O.object,N):O.type==="CallExpression"?(R(O.callee,N),O.arguments.forEach(z=>R(z,N))):O.type==="BinaryExpression"||O.type==="LogicalExpression"?(R(O.left,N),R(O.right,N)):O.type==="ConditionalExpression"?(R(O.test,N),R(O.consequent,N),R(O.alternate,N)):O.type==="UnaryExpression"?R(O.argument,N):O.type==="ArrayExpression"?O.elements.forEach(z=>R(z,N)):O.type==="ObjectExpression"?O.properties.forEach(z=>{z.type==="Property"&&R(z.value,N)}):O.type==="TemplateLiteral"?O.expressions.forEach(z=>R(z,N)):(O.type==="ChainExpression"||O.type==="TSAsExpression"||O.type==="TSNonNullExpression")&&R(O.expression,N)),N),F=O=>{let N=new Set;if(O.type==="VariableDeclaration")for(let z of O.declarations)z.init&&R(z.init,N);return N},B=f.filter($);if(B.length<2)return;let j=new Map,H=new Map;for(let O=0;O<f.length;O++){let N=f[O],z=P(N);for(let Z of z)H.set(Z,O)}for(let O=0;O<f.length;O++){let N=f[O],z=P(N),Z=F(N),Q=$(N)?m(N,S):n.UNKNOWN;j.set(O,{category:Q,declared:z,dependencies:Z,index:O,statement:N})}let M=new Map;for(let O=0;O<f.length;O++){let N=j.get(O),z=new Set;for(let Z of N.dependencies){let Q=H.get(Z);Q!==void 0&&Q!==O&&z.add(Q)}M.set(O,z)}let D=!1,J=!1,_=0,W=null,K=null,ee=null,X=null,q=null;for(let O of B){let N=m(O,S);N!==n.UNKNOWN&&(N<_&&!D&&(D=!0,W=O,K=N,ee=_),_=N)}for(let O=0;O<f.length;O++){let N=M.get(O)||new Set;for(let z of N)if(z>O){J=!0,X=f[O];let Z=j.get(z);for(let Q of Z.declared)if(j.get(O).dependencies.has(Q)){q=Q;break}break}if(J)break}if(!D&&!J)return;let U=(()=>{let O=[],N=new Set,z=new Set,Z=G=>{if(N.has(G)||z.has(G))return;z.add(G);let re=M.get(G)||new Set;for(let te of re)Z(te);z.delete(G),N.add(G),O.push(G)},Q=new Map;for(let G=0;G<f.length;G++){let re=j.get(G),te=re.category;if(te===n.UNKNOWN){for(let oe=G+1;oe<f.length;oe++){let ue=j.get(oe);if(ue.category!==n.UNKNOWN){te=ue.category;break}}te===n.UNKNOWN&&(te=n.RETURN)}let ae=M.get(G)||new Set,ce=te;for(let oe of ae){let ge=j.get(oe).category;ge===n.UNKNOWN&&(ge=n.DERIVED_STATE),ge>ce&&(ce=ge)}let se=Math.max(te,ce);Q.has(se)||Q.set(se,[]),Q.get(se).push({deps:ae,effectiveCategory:te,index:G,originalCategory:re.category})}let he=[...Q.keys()].sort((G,re)=>G-re),xe=[];for(let G of he){let re=Q.get(G),te=new Set,ae=[],ce=se=>{if(!te.has(se.index)){te.add(se.index);for(let oe of se.deps){let ue=re.find(ge=>ge.index===oe);ue&&!te.has(oe)&&ce(ue)}ae.push(se.index)}};re.sort((se,oe)=>se.index-oe.index);for(let se of re)ce(se);xe.push(...ae)}return xe})();if(!U.some((O,N)=>O!==N))return;let le=O=>{let z=g.lines[f[0].loc.start.line-1].match(/^\s*/)[0],Z="",Q=null;for(let G=0;G<U.length;G++){let re=U[G],te=j.get(re),ae=te.category!==n.UNKNOWN?te.category:null;Q!==null&&ae!==null&&ae!==Q&&(Z+=`
`);let ce=g.getText(te.statement);Z+=z+ce.trim()+`
`,ae!==null&&(Q=ae)}let he=f[0],xe=f[f.length-1];return O.replaceTextRange([he.range[0],xe.range[1]],Z.trimEnd())};J&&X?e.report({data:{type:L?"hook":"component",varName:q||"variable"},fix:le,message:'"{{varName}}" is used before it is declared. Reorder statements so dependencies are declared first in {{type}}',node:X}):D&&W&&e.report({data:{current:I[K],previous:I[ee],type:L?"hook":"component"},fix:le,message:'"{{current}}" should come before "{{previous}}" in {{type}}. Order: refs \u2192 state \u2192 redux \u2192 router \u2192 context \u2192 custom hooks \u2192 derived \u2192 useMemo \u2192 useCallback \u2192 handlers \u2192 useEffect \u2192 return',node:W})},A=(E,L)=>{let C=e.sourceCode||e.getSourceCode(),g=E;for(;g.parent;)g=g.parent;if(g.type!=="Program")return;let f=E.body;if(f.type!=="BlockStatement")return;let S=p(E);for(let $ of g.body)if($.type==="VariableDeclaration")for(let P of $.declarations){if(!P.init||!P.id||P.id.type!=="Identifier")continue;let R=P.id.name;if(!(P.init.type==="Literal"&&(typeof P.init.value=="number"||typeof P.init.value=="string"||typeof P.init.value=="boolean"))||/^[A-Z][A-Z0-9_]*$/.test(R))continue;let B=C.getText(E);if(new RegExp(`\\b${R}\\b`).test(B)){let H=M=>{let D=[],J=C.getText(P),_=$.kind;if($.declarations.length===1){let q=C.getTokenAfter($),V=$.range[1],U=C.text.slice($.range[1],$.range[1]+2),Y=U.startsWith(`
`)?$.range[1]+1:U.startsWith(`\r
`)?$.range[1]+2:$.range[1];D.push(M.removeRange([$.range[0],Y]))}else{let q=$.declarations.indexOf(P);if(q===$.declarations.length-1){let U=$.declarations[q-1];D.push(M.removeRange([U.range[1],P.range[1]]))}else{let U=$.declarations[q+1];D.push(M.removeRange([P.range[0],U.range[0]]))}}let W=f.body,K="    ";W.length>0&&(K=C.lines[W[0].loc.start.line-1].match(/^\s*/)[0]);let ee=0;for(let q=0;q<W.length;q++){let V=W[q];if(V.type==="VariableDeclaration"){let U=V.declarations[0];if(U&&U.init){if(U.init.type==="CallExpression"){let Y=U.init.callee,le=Y.type==="Identifier"?Y.name:Y.type==="MemberExpression"&&Y.property.type==="Identifier"?Y.property.name:"";if(/^use[A-Z]/.test(le)){ee=q+1;continue}}if(U.init.type==="ArrowFunctionExpression"||U.init.type==="FunctionExpression")break;ee=q+1}}else if(V.type==="FunctionDeclaration")break}let X=`${K}${_} ${J};

`;return ee===0&&W.length>0?D.push(M.insertTextBefore(W[0],X)):ee<W.length?D.push(M.insertTextBefore(W[ee],X)):W.length>0&&D.push(M.insertTextAfter(W[W.length-1],`

`+K+_+" "+J+";")),D};e.report({data:{name:R,type:L?"hook":"component"},fix:H,message:'Constant "{{name}}" should be declared inside the {{type}} as derived state, not at module level',node:P.id})}}},w=E=>{if(l(E)){k(E,!1),A(E,!1);return}a(E)&&(k(E,!0),A(E,!0))};return{ArrowFunctionExpression:w,FunctionDeclaration:w,FunctionExpression:w}},meta:{docs:{description:"Enforce consistent ordering of code blocks in React components and custom hooks"},fixable:"code",schema:[],type:"suggestion"}};var Nt={create(e){let n=e.sourceCode||e.getSourceCode();return{VariableDeclaration:v=>{let x=n.getFirstToken(v);x&&v.declarations.forEach(r=>{let{id:d,init:i}=r;if(v.declarations[0]===r){if(d.type==="Identifier"&&x.loc.end.line!==d.loc.start.line){e.report({fix:o=>o.replaceTextRange([x.range[1],d.range[0]]," "),message:"Variable name should be on the same line as declaration keyword",node:d});return}if(d.type==="ObjectPattern"||d.type==="ArrayPattern"){let o=n.getFirstToken(d);if(x.loc.end.line!==o.loc.start.line){e.report({fix:t=>t.replaceTextRange([x.range[1],o.range[0]]," "),message:"Destructuring pattern should be on the same line as declaration keyword",node:o});return}}}if(!i)return;let c=n.getTokenBefore(i,o=>o.value==="=");if(c){if(d.loc.end.line!==c.loc.start.line){e.report({fix:o=>o.replaceTextRange([d.range[1],c.range[0]]," "),message:"Assignment operator should be on the same line as variable",node:c});return}i.loc.start.line>c.loc.end.line&&e.report({fix:o=>o.replaceTextRange([c.range[1],i.range[0]]," "),message:"Value should be on the same line as the assignment operator",node:i})}})}}},meta:{docs:{description:"Enforce assignment value on same line as equals sign"},fixable:"whitespace",schema:[],type:"layout"}},Dt={create(e){let n=e.sourceCode||e.getSourceCode(),I=(v,x,r)=>{let d=n.getTokenBefore(r),i=n.getTokenAfter(r);if(!d||d.value!=="["||!i||i.value!=="]")return;let s=n.getLastToken(x);if(s){let t=n.text.slice(s.range[1],d.range[0]);/\s/.test(t)&&e.report({fix:h=>h.replaceTextRange([s.range[1],d.range[0]],""),message:"No space before opening bracket in member expression",node:d})}let c=n.text.slice(d.range[1],r.range[0]);(c.includes(" ")||c.includes(`
`))&&e.report({fix:t=>t.replaceTextRange([d.range[1],r.range[0]],""),message:"No space after opening bracket in member expression",node:d});let o=n.text.slice(r.range[1],i.range[0]);(o.includes(" ")||o.includes(`
`))&&e.report({fix:t=>t.replaceTextRange([r.range[1],i.range[0]],""),message:"No space before closing bracket in member expression",node:i})};return{MemberExpression(v){v.computed&&I(v,v.object,v.property)},TSIndexedAccessType(v){I(v,v.objectType,v.indexType)}}},meta:{docs:{description:"Enforce no spaces inside brackets for member expressions"},fixable:"code",schema:[],type:"layout"}};var Jt={create(e){let n=e.options[0]||{},I=["accept","acceptCharset","accessKey","action","align","allow","allowFullScreen","alt","as","async","autoCapitalize","autoComplete","autoCorrect","autoFocus","autoPlay","capture","cellPadding","cellSpacing","charSet","className","clipPath","clipRule","colorInterpolation","colorInterpolationFilters","classNames","colSpan","contentEditable","controls","controlsList","coords","crossOrigin","d","data","data-*","dateTime","decoding","default","defer","dir","disabled","download","draggable","encType","enterKeyHint","fill","fillOpacity","fillRule","filter","filterUnits","floodColor","floodOpacity","for","form","formAction","formEncType","formMethod","formNoValidate","formTarget","frameBorder","headers","height","hidden","high","href","hrefLang","htmlFor","httpEquiv","gradientTransform","gradientUnits","icon","id","in","in2","imagesizes","imagesrcset","inputMode","integrity","is","itemID","itemProp","itemRef","itemScope","itemType","key","keyParams","keyType","kind","lang","list","loading","loop","low","marginHeight","marginWidth","markerEnd","markerMid","markerStart","markerUnits","mask","max","mode","maxLength","media","mediaGroup","method","min","minLength","multiple","muted","name","noModule","noValidate","nonce","open","optimum","pattern","patternContentUnits","patternTransform","patternUnits","ping","preserveAspectRatio","playsInline","poster","preload","profile","radioGroup","readOnly","referrerPolicy","rel","repeatCount","repeatDur","required","result","reversed","role","rowSpan","rows","sandbox","scope","scoped","scrolling","seamless","selected","shape","sizes","slot","span","spellCheck","src","srcDoc","srcLang","srcSet","start","step","spreadMethod","stdDeviation","stopColor","stopOpacity","stroke","strokeDasharray","strokeDashoffset","strokeLinecap","strokeLinejoin","strokeMiterlimit","strokeOpacity","strokeWidth","style","summary","tabIndex","target","testId","textAnchor","textDecoration","transform","translate","vectorEffect","useMap","value","viewBox","width","wmode","wrap","x","x1","x2","xmlns","y","y1","y2","baseFrequency","numOctaves","seed","stitchTiles","operator","k1","k2","k3","k4","surfaceScale","diffuseConstant","specularConstant","specularExponent","kernelMatrix","order","targetX","targetY","edgeMode","kernelUnitLength","bias","divisor","preserveAlpha","radius","azimuth","elevation","limitingConeAngle","pointsAtX","pointsAtY","pointsAtZ","cx","cy","r","rx","ry","points","pathLength","offset","dx","dy","rotate","lengthAdjust","textLength"],v=n.ignoreAttributes||[...I,...n.extraIgnoreAttributes||[]],x=[/^\s*$/,/^.$/,/^-?\d+(\.\d+)?(px|em|rem|%|vh|vw|vmin|vmax|ch|ex|cm|mm|in|pt|pc|deg|rad|turn|s|ms|fr)?$/,/^-?\d+(\.\d+)?e[+-]?\d+$/i,/^#[0-9a-fA-F]{3,8}$/,/^(rgb|rgba|hsl|hsla)\(.+\)$/,/^url\(#?.+\)$/,/^(round|butt|square|miter|bevel|none|normal|evenodd|nonzero|sRGB|linearRGB|userSpaceOnUse|objectBoundingBox|pad|reflect|repeat|auto|inherit|currentColor|meet|slice|xMinYMin|xMidYMin|xMaxYMin|xMinYMid|xMidYMid|xMaxYMid|xMinYMax|xMidYMax|xMaxYMax|stitch|noStitch|duplicate|wrap|arithmetic|atop|in|out|over|xor|dilate|erode|matrix|saturate|hueRotate|luminanceToAlpha|discrete|linear|gamma|table|identity|SourceGraphic|SourceAlpha|BackgroundImage|BackgroundAlpha|FillPaint|StrokePaint)$/,/^[a-zA-Z]+\d*[_a-zA-Z0-9]*(_[a-zA-Z0-9]+)+$/,/^(white|black|red|green|blue|yellow|orange|purple|pink|brown|gray|grey|cyan|magenta|transparent)$/i,/^(auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|vertical-text|alias|copy|move|no-drop|not-allowed|grab|grabbing|all-scroll|col-resize|row-resize|n-resize|e-resize|s-resize|w-resize|ne-resize|nw-resize|se-resize|sw-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|zoom-in|zoom-out)$/,/^(block|inline|inline-block|flex|inline-flex|grid|inline-grid|flow-root|contents|table|table-row|table-cell|list-item|none|visible|hidden|collapse)$/,/^(static|relative|absolute|fixed|sticky)$/,/^(visible|hidden|scroll|auto|clip)$/,/^(https?:\/\/|\/\/|\/|\.\/|\.\.\/)/,/^data:/,/^mailto:/,/^tel:/,/^\.[a-zA-Z0-9]+$/,/^[a-z]+\/[a-z0-9.+-]+$/,/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2})?/,/^\d{1,2}:\d{2}(:\d{2})?(\s?(AM|PM|am|pm))?$/,/^[a-z]+[A-Z][a-zA-Z0-9]*$/,/^[a-z][a-z0-9]*_[a-z0-9_]*$/,/^[A-Z][A-Z0-9]*_[A-Z0-9_]+$/,/^(true|false|null|undefined|NaN|Infinity)$/,/^application\//,/^[a-z][a-zA-Z0-9_]*=/,/^[a-z]+-[a-z]+(-[a-z]+)*$/,/^-?[a-z]+-\d+(\.\d+)?(\/\d+)?$/,/^-?[a-z]+-[a-z]+-\d+(\.\d+)?(\/\d+)?$/,/^[a-z]+:[a-z][-a-z0-9/]*$/,/^[a-z]+-[a-z]+(-[a-z]+)*\/\d+$/,/^-?[a-z]+(-[a-z]+)*-\[.+\]$/,/^-[a-z]+-[a-z]+-\d+\/\d+$/,/^[a-z]+-(full|auto|screen|none|inherit|initial|px|fit|min|max)$/,/^(sm|md|lg|xl|2xl|hover|focus|active|disabled|first|last|odd|even|group-hover|dark|motion-safe|motion-reduce):[a-z][-a-z0-9/[\]]*$/,/^[\d,._]+$/,/^\d+\.\d+\.\d+/,/^[,;:|\-/\\]+$/,/^&[a-z]+;$/,/^[.!?,;:'"()\[\]{}]+$/,/^(rotate|translate|translateX|translateY|translateZ|translate3d|scale|scaleX|scaleY|scaleZ|scale3d|skew|skewX|skewY|matrix|matrix3d|perspective)\(.+\)$/,/^(rotate|translate|translateX|translateY|scale|scaleX|scaleY|skew|skewX|skewY|matrix)\([^)]+\)(\s+(rotate|translate|translateX|translateY|scale|scaleX|scaleY|skew|skewX|skewY|matrix)\([^)]+\))+$/,/^(linear-gradient|radial-gradient|conic-gradient|repeating-linear-gradient|repeating-radial-gradient)\(.+\)$/,/^[a-zA-Z][\w-]*\s+[\d.]+m?s\s+[\w-]+(\s+[\w-]+)*$/,/^(\d+%|center|top|bottom|left|right)(\s+(\d+%|center|top|bottom|left|right))?$/,/^calc\(.+\)$/,/^var\(.+\)$/,/^clamp\(.+\)$/,/^(min|max)\(.+\)$/],r=(n.ignorePatterns||[]).map(g=>typeof g=="string"?new RegExp(g):g),d=[...x,...r],i=/^-?[a-z]+(-[a-z0-9]+)*(\/\d+)?$|^-?[a-z]+(-[a-z0-9]+)*-\[.+\]$|^[a-z]+:[a-z][-a-z0-9/[\]]*$/,s=new Set(["block","contents","flex","flow","grid","hidden","inline","table","absolute","fixed","relative","static","sticky","collapse","invisible","visible","antialiased","capitalize","italic","lowercase","ordinal","overline","subpixel","truncate","underline","uppercase","container","isolate","grow","shrink","border","rounded","group","peer","resize","snap","touch","select","pointer","transition","animate","filter","backdrop","transform","appearance","cursor","outline","ring","shadow","opacity","blur","invert","sepia","grayscale","hue","saturate","brightness","contrast"]),c=g=>{let f=g.trim().split(/\s+/).filter(Boolean);return f.length===0||!f.some($=>$.includes("-")||$.includes(":")||$.includes("/")||$.includes("["))?!1:f.every($=>$.includes("${")||s.has($)?!0:/^-?[a-z]+(-[a-z0-9.]+)+$/.test($)||/^-?[a-z]+(-[a-z0-9.]+)*\/\d+$/.test($)||/^[a-z][-a-z0-9]*(\[[-\w=]+\])?:[a-z][-a-z0-9./[\]]*$/.test($)||/^\[.+\]:[a-z][-a-z0-9./[\]]*$/.test($)||/^-?[a-z]+(-[a-z]+)*-?\[.+\]$/.test($))},o=new Set(["button","checkbox","color","date","datetime-local","email","file","hidden","image","month","number","password","radio","range","reset","search","submit","tel","text","time","url","week"]),t=g=>o.has(g.toLowerCase()),h=g=>{let f=g.parent;for(;f;){if(f.type==="Property"&&f.parent&&f.parent.type==="ObjectExpression"){let S=f.parent;if(S.parent&&S.parent.type==="JSXExpressionContainer"){let $=S.parent;if($.parent&&$.parent.type==="JSXAttribute"&&($.parent.name&&$.parent.name.name)==="style")return!0}}f=f.parent}return!1},p=[/gradient/i,/transform/i,/animation/i,/transition/i,/color/i,/background/i,/border/i,/shadow/i,/filter/i,/clip/i,/mask/i,/font/i,/^style/i,/Style$/i,/css/i],l=g=>!!(/^(linear-gradient|radial-gradient|conic-gradient|repeating-linear-gradient|repeating-radial-gradient|rotate|translate|translateX|translateY|translateZ|translate3d|scale|scaleX|scaleY|scaleZ|scale3d|skew|skewX|skewY|matrix|matrix3d|perspective|calc|var|clamp|min|max|cubic-bezier|steps|url)\(/i.test(g)||/^(#[0-9a-fA-F]{3,8}|rgb|rgba|hsl|hsla)\(/i.test(g)||/^\d+(\.\d+)?(px|em|rem|%|vh|vw|vmin|vmax|deg|rad|turn|s|ms|fr)\s*/.test(g)),a=g=>{let f=g.parent;for(;f;){if(f.type==="VariableDeclarator"&&f.id&&f.id.name){let S=f.id.name;if(p.some($=>$.test(S)))return!0}if(f.type==="Property"&&f.key){let S=f.key.name||f.key.value&&String(f.key.value);if(S&&p.some($=>$.test(S)))return!0}f=f.parent}return!1},u=g=>{let f=g.parent,S=0;for(;f;){if(S++,f.type==="ExportNamedDeclaration"&&S<=3){let $=f.declaration;if($&&$.type==="VariableDeclaration"){let P=$.declarations[0];if(P&&P.id&&P.id.name){let R=P.id.name;return!(/^[A-Z][A-Z0-9_]*$/.test(R)||/^(constants?|strings?|messages?|labels?|texts?|data)$/i.test(R))}}}if(f.type==="FunctionDeclaration"||f.type==="FunctionExpression"||f.type==="ArrowFunctionExpression")return!1;f=f.parent}return!1},T=(g,f="")=>{let S=g.length>30?`${g.substring(0,30)}...`:g,$=f?` in ${f}`:"",P=!/\s/.test(g)&&g.length<=30,R=/^[a-z_]+$/.test(g),F=f.includes("attribute");return P&&R?F?`Hardcoded "${S}"${$} should be imported from @/enums (preferred) or @/data to prevent typos (e.g., import { InputTypeEnum } from "@/enums")`:`Hardcoded "${S}"${$} should be imported from @/enums (preferred) or @/data (e.g., import { StatusEnum } from "@/enums")`:`Hardcoded UI string "${S}"${$} should be imported from @/strings or @/constants (e.g., import { strings } from "@/strings")`},y=new Set(["cn","cva","clsx","twMerge","classnames","cx","tv","twJoin"]),b=g=>{let f=g.parent,S=!1;for(;f;){if(f.type==="CallExpression"&&f.callee){let $=f.callee.name||f.callee.property&&f.callee.property.name;if($&&y.has($))return!0;S=!0}if(S&&f.type==="JSXAttribute"&&f.name){let $=f.name.name;if($==="className"||$==="class")return!0}f=f.parent}return!1},m=(g,f)=>f&&b(f)||c(g)?!0:d.some(S=>S.test(g)),k=()=>{let f=(e.filename||e.getFilename()).replace(/\\/g,"/").toLowerCase();return/\/(constants|strings|@constants|@strings|data|@data|enums|@enums)(\/|\.)/i.test(f)||/\/data\/(constants|strings)/i.test(f)},A=new Set,w=g=>{let f=g.source.value;if(typeof f!="string")return;/@?\/?(@?constants|@?strings|@?data|@?enums|data\/constants|data\/strings)/i.test(f)&&g.specifiers.forEach($=>{$.local&&$.local.name&&A.add($.local.name)})},E=g=>g.type==="Identifier"?A.has(g.name):g.type==="MemberExpression"&&g.object.type==="Identifier"?A.has(g.object.name):!1,L=g=>{let f=g.parent;for(;f;){if(f.type==="FunctionDeclaration"||f.type==="FunctionExpression"||f.type==="ArrowFunctionExpression"){let S=null;return f.id&&f.id.name?S=f.id.name:f.parent&&f.parent.type==="VariableDeclarator"&&f.parent.id&&f.parent.id.name&&(S=f.parent.id.name),S&&(/^[A-Z]/.test(S)||/^use[A-Z]/.test(S)||/Handler$|Helper$|Util$|Utils$/i.test(S)),!0}if(f.type==="JSXElement"||f.type==="JSXFragment")return!0;f=f.parent}return!1},C=g=>{let f=g.parent,S=0;for(;f;){if(S++,f.type==="VariableDeclarator"){let $=f.id&&f.id.name;if($&&(/^[A-Z][A-Z0-9_]*$/.test($)||/^(constants?|strings?|messages?|labels?|texts?|data)$/i.test($)))return!0}if(f.type==="ExportNamedDeclaration"&&S<=3){let $=f.declaration;if($&&$.type==="VariableDeclaration"){let P=$.declarations[0];if(P&&P.init){let R=P.init.type;if(R==="Literal"||R==="ObjectExpression"||R==="ArrayExpression")return!0}}}if(f.type==="FunctionDeclaration"||f.type==="FunctionExpression"||f.type==="ArrowFunctionExpression")return!1;f=f.parent}return!1};return k()?{}:{ImportDeclaration:w,JSXText(g){let f=g.value.trim();f&&(m(f,g)||/[a-zA-Z]/.test(f)&&e.report({message:T(f,"JSX"),node:g}))},JSXExpressionContainer(g){let{expression:f}=g;if(!E(f)){if(g.parent&&g.parent.type==="JSXAttribute"){let S=g.parent.name.name||g.parent.name.namespace&&`${g.parent.name.namespace.name}:${g.parent.name.name.name}`;if(v.includes(S)||S&&(S.startsWith("data-")||S.startsWith("aria-")))return}if(f.type==="Literal"&&typeof f.value=="string"){let S=f.value;if(m(S,f)||!/[a-zA-Z]/.test(S))return;e.report({message:T(S,"JSX expression"),node:f})}f.type==="TemplateLiteral"&&f.quasis.forEach(S=>{let $=S.value.cooked||S.value.raw;m($,f)||/[a-zA-Z]{2,}/.test($)&&(/^[/.]|https?:\/\//.test($)||e.report({message:T($,"template literal"),node:S}))})}},JSXAttribute(g){if(!g.value)return;let f=g.name.name||g.name.namespace&&`${g.name.namespace.name}:${g.name.name.name}`;if(!v.includes(f)&&!(f&&f.startsWith("data-"))&&!(f&&f.startsWith("aria-"))){if(g.value.type==="Literal"&&typeof g.value.value=="string"){let S=g.value.value;if(m(S,g.value)||!/[a-zA-Z]/.test(S))return;e.report({message:T(S,`attribute "${f}"`),node:g.value})}if(g.value.type==="JSXExpressionContainer"){let{expression:S}=g.value;if(E(S))return;if(S.type==="Literal"&&typeof S.value=="string"){let $=S.value;if(m($,S)||!/[a-zA-Z]/.test($))return;e.report({message:T($,`attribute "${f}"`),node:S})}}}},Literal(g){if(typeof g.value!="string")return;let f=g.value;if(!h(g)){if(u(g)){if(!/[a-zA-Z]/.test(f))return;e.report({message:T(f,"exported constant"),node:g});return}m(f,g)||L(g)&&(C(g)||g.parent.type==="JSXAttribute"||g.parent.type==="JSXExpressionContainer"||g.parent.type==="ImportDeclaration"||g.parent.type==="ExportNamedDeclaration"||g.parent.type==="ExportAllDeclaration"||g.parent.type==="Property"&&g.parent.key===g||/[a-zA-Z]/.test(f)&&e.report({message:T(f),node:g}))}},TemplateLiteral(g){if(g.parent.type!=="JSXExpressionContainer"&&!h(g)){if(a(g)){let f=g.quasis.map(S=>S.value.cooked||S.value.raw).join("");if(l(f))return}L(g)&&(C(g)||g.quasis.forEach(f=>{let S=f.value.cooked||f.value.raw;m(S,g)||/[a-zA-Z]{3,}/.test(S)&&(/^[/.]|^https?:\/\/|^[?&]/.test(S)||g.expressions.length>g.quasis.length||e.report({message:T(S,"template literal"),node:f}))}))}}}},meta:{docs:{description:"Enforce importing strings from constants/strings modules instead of hardcoding them"},schema:[{additionalProperties:!1,properties:{extraIgnoreAttributes:{description:"Additional JSX attributes to ignore (extends defaults)",items:{type:"string"},type:"array"},ignoreAttributes:{description:"JSX attributes to ignore (replaces defaults)",items:{type:"string"},type:"array"},ignorePatterns:{description:"Regex patterns for strings to ignore",items:{type:"string"},type:"array"}},type:"object"}],type:"suggestion"}};var Xt={create(e){let n=e.sourceCode||e.getSourceCode(),I=new Map,v=c=>c.endsWith("Type")?c.slice(0,-4)+"Enum":null,x=c=>c.toUpperCase().replace(/-/g,"_"),r=c=>{if(!c)return null;let o=c.typeAnnotation;if(!o)return null;if(o.type==="TSTypeReference"&&o.typeName?.type==="Identifier"){let t=o.typeName.name;if(t.endsWith("Type"))return{enumName:v(t),typeName:t}}return null},d=c=>{c.forEach(o=>{if(o.type==="TSPropertySignature"&&o.key?.type==="Identifier"){let t=o.key.name,h=r(o.typeAnnotation);h&&I.set(t,h)}})},i=c=>{c.forEach(o=>{if(o.type==="ObjectPattern"&&o.typeAnnotation){let t=o.typeAnnotation.typeAnnotation;t&&t.type==="TSTypeLiteral"&&d(t.members),t&&t.type==="TSIntersectionType"&&t.types.forEach(h=>{h.type==="TSTypeLiteral"&&d(h.members)})}if(o.type==="Identifier"&&o.typeAnnotation){let t=r(o);t&&I.set(o.name,t)}})},s=(c,o)=>{let h=n.getScope?n.getScope(o):e.getScope();for(;h;){if(h.variables.some(p=>p.name===c))return!0;h=h.upper}return!1};return{"ArrowFunctionExpression, FunctionDeclaration, FunctionExpression"(c){i(c.params)},AssignmentPattern(c){if(c.left.type!=="Identifier")return;let o=c.left.name,t=I.get(o);if(t&&c.right.type==="Literal"&&typeof c.right.value=="string"){let h=c.right.value,p=x(h),l=`${t.enumName}.${p}`,a=s(t.enumName,c);e.report({fix:a?u=>u.replaceText(c.right,l):void 0,message:`Use "${l}" instead of string literal "${h}"`,node:c.right})}},BinaryExpression(c){if(c.operator!=="==="&&c.operator!=="!==")return;let o=null,t=null;if(c.left.type==="Identifier"&&c.right.type==="Literal"?(o=c.left,t=c.right):c.right.type==="Identifier"&&c.left.type==="Literal"&&(o=c.right,t=c.left),!o||!t||typeof t.value!="string")return;let h=I.get(o.name);if(!h)return;let p=t.value,l=x(p),a=`${h.enumName}.${l}`,u=s(h.enumName,c);e.report({fix:u?T=>T.replaceText(t,a):void 0,message:`Use "${a}" instead of string literal "${p}"`,node:t})},"ArrowFunctionExpression:exit"(){I.clear()},"FunctionDeclaration:exit"(){I.clear()},"FunctionExpression:exit"(){I.clear()}}},meta:{docs:{description:"Enforce using enum values instead of string literals for typed variables"},fixable:"code",schema:[],type:"suggestion"}},zt={create(e){let n=e.options[0]||{},I=["is","has","with","without"],v=n.booleanPrefixes||[...I,...n.extendBooleanPrefixes||[]],x=n.allowPastVerbBoolean||!1,r=n.allowContinuousVerbBoolean||!1,d=n.callbackPrefix||"on",i=n.allowActionSuffix||!1,s=new RegExp(`^(${v.join("|")})[A-Z]`),c=new RegExp(`^${d}[A-Z]`),o=/^[a-z]+ed$/,t=/^[a-z]+ing$/,h=["children","content","data","error","errors","items","permission","permissions","value","values"],p=C=>{let g=C.toLowerCase();return(h.some(S=>g.includes(S))?"has":"is")+C[0].toUpperCase()+C.slice(1)},l=C=>{if(C.startsWith("handle")&&C.length>6){let g=C.slice(6);return d+g[0].toUpperCase()+g.slice(1)}if(C.endsWith("Handler")&&C.length>7){let g=C.slice(0,-7);return d+g[0].toUpperCase()+g.slice(1)}return d+C[0].toUpperCase()+C.slice(1)},a=C=>{if(!C)return!1;let g=C.typeAnnotation;return g?g.type==="TSBooleanKeyword"?!0:g.type==="TSUnionType"?g.types.some(f=>f.type==="TSBooleanKeyword"):!1:!1},u=["MouseEventHandler","ChangeEventHandler","FormEventHandler","KeyboardEventHandler","FocusEventHandler","TouchEventHandler","PointerEventHandler","DragEventHandler","WheelEventHandler","AnimationEventHandler","TransitionEventHandler","ClipboardEventHandler","CompositionEventHandler","UIEventHandler","ScrollEventHandler","EventHandler"],T=C=>{if(!C)return!1;let g=C.typeAnnotation;if(!g)return!1;if(g.type==="TSFunctionType")return!0;if(g.type==="TSTypeReference"){let f=g.typeName?.name;if(f==="Function"||f==="VoidFunction"||u.includes(f))return!0}return g.type==="TSUnionType"?g.types.some(f=>f.type==="TSFunctionType"||f.type==="TSTypeReference"&&(f.typeName?.name==="Function"||f.typeName?.name==="VoidFunction"||u.includes(f.typeName?.name))):!1},y=C=>{if(!C)return!1;let g=C.typeAnnotation;return g?g.type==="TSTypeLiteral":!1},b=C=>!!(s.test(C)||x&&o.test(C)||r&&t.test(C)),m=C=>!!(c.test(C)||i&&C.endsWith("Action")&&C.length>6),k=C=>{let g=C;for(;g;){if(g.type==="ArrowFunctionExpression"||g.type==="FunctionExpression"||g.type==="FunctionDeclaration")return g;g=g.parent}return null},A=(C,g)=>{if(!C||!C.params||C.params.length===0)return null;let f=C.params[0];if(f.type!=="ObjectPattern")return null;for(let S of f.properties)if(S.type==="Property"&&S.key&&S.key.type==="Identifier"&&S.key.name===g)return S;return null},w=(C,g,f,S)=>{let $=[C.replaceText(g.key,S)],P=k(g);if(!P)return $;let R=A(P,f);if(!R)return $;let F=R.value||R.key;if(!F||F.type!=="Identifier")return $;R.shorthand!==!1&&R.key===R.value?$.push(C.replaceText(R,`${f}: ${S}`)):$.push(C.replaceText(F,S));let j=e.sourceCode?e.sourceCode.getScope(P):e.getScope(),H=(D,J)=>{let _=D.variables.find(W=>W.name===J);return _||(D.upper?H(D.upper,J):null)},M=H(j,f);if(M){let D=new Set;M.references.forEach(J=>{if(J.identifier===F)return;let _=`${J.identifier.range[0]}-${J.identifier.range[1]}`;D.has(_)||(D.add(_),$.push(C.replaceText(J.identifier,S)))})}return $},E=C=>{if(C.type!=="TSPropertySignature"||!C.key||C.key.type!=="Identifier")return;let g=C.key.name;if(!g.startsWith("_")){if(y(C.typeAnnotation)){let f=C.typeAnnotation.typeAnnotation;f&&f.members&&f.members.forEach(E);return}if(a(C.typeAnnotation)){if(!b(g)){let f=p(g);e.report({fix:S=>w(S,C,g,f),message:`Boolean prop "${g}" should start with a valid prefix (${v.join(", ")}). Use "${f}" instead.`,node:C.key})}return}if(T(C.typeAnnotation)&&!m(g)){let f=l(g);e.report({fix:S=>w(S,C,g,f),message:`Callback prop "${g}" should start with "${d}" prefix. Use "${f}" instead.`,node:C.key})}}},L=C=>{C.members&&C.members.forEach(E)};return{TSInterfaceDeclaration(C){!C.body||!C.body.body||C.body.body.forEach(E)},TSTypeAliasDeclaration(C){C.typeAnnotation?.type==="TSTypeLiteral"&&L(C.typeAnnotation)},TSTypeLiteral(C){C.parent?.type!=="TSTypeAliasDeclaration"&&L(C)}}},meta:{docs:{description:"Enforce naming conventions: boolean props must start with is/has/with/without, callback props must start with on"},fixable:"code",schema:[{additionalProperties:!1,properties:{allowActionSuffix:{default:!1,description:"Allow 'xxxAction' pattern for callback props (e.g., submitAction, copyAction)",type:"boolean"},allowContinuousVerbBoolean:{default:!1,description:"Allow continuous verb boolean props without prefix (e.g., loading, saving, fetching, closing)",type:"boolean"},allowPastVerbBoolean:{default:!1,description:"Allow past verb boolean props without prefix (e.g., disabled, selected, checked, opened)",type:"boolean"},booleanPrefixes:{description:"Replace default boolean prefixes entirely. If not provided, defaults are used with extendBooleanPrefixes",items:{type:"string"},type:"array"},callbackPrefix:{default:"on",description:"Required prefix for callback props",type:"string"},extendBooleanPrefixes:{default:[],description:"Add additional prefixes to the defaults (is, has, with, without)",items:{type:"string"},type:"array"}},type:"object"}],type:"suggestion"}},Wt={create(e){let n=e.sourceCode||e.getSourceCode(),I=e.options[0]||{},v=I.maxUnionMembers??2,x=I.maxLength??50,r=new Set(["any","bigint","boolean","never","null","number","object","string","symbol","undefined","unknown","void"]),d=new Set(["Array","BigInt","Boolean","Date","Error","Function","Map","Number","Object","Promise","ReadonlyArray","RegExp","Set","String","Symbol","WeakMap","WeakSet"]),i=t=>{if(!t)return!1;if(t.type==="TSStringKeyword"||t.type==="TSNumberKeyword"||t.type==="TSBooleanKeyword"||t.type==="TSNullKeyword"||t.type==="TSUndefinedKeyword"||t.type==="TSVoidKeyword"||t.type==="TSAnyKeyword"||t.type==="TSUnknownKeyword"||t.type==="TSNeverKeyword"||t.type==="TSObjectKeyword"||t.type==="TSSymbolKeyword"||t.type==="TSBigIntKeyword")return!0;if(t.type==="TSTypeReference"&&t.typeName){let h=t.typeName.name||t.typeName.type==="Identifier"&&t.typeName.name;if(h&&d.has(h))return!0}return t.type==="TSLiteralType"},s=t=>t.type!=="TSUnionType"?!1:t.types.every(h=>i(h)),c=t=>{if(t.type!=="TSUnionType")return 1;let h=0;for(let p of t.types)h+=c(p);return h},o=(t,h)=>{if(t){if(t.type==="TSUnionType"){if(s(t))return;let p=c(t),l=n.getText(t);(p>=v||l.length>x)&&e.report({message:`Inline union type with ${p} members is too complex. Extract to a named type in a types file.`,node:t});return}if(t.type==="TSIntersectionType"){for(let p of t.types)o(p,h);return}if(t.type==="TSTypeLiteral"){for(let p of t.members)if(p.type==="TSPropertySignature"&&p.typeAnnotation){let l=p.typeAnnotation.typeAnnotation,a=p.key&&p.key.name?p.key.name:"unknown";if(l&&l.type==="TSUnionType"){let u=c(l),T=n.getText(l);(u>=v||T.length>x)&&e.report({message:`Property "${a}" has inline union type with ${u} members. Extract to a named type in a types file.`,node:l})}}}}};return{ArrowFunctionExpression(t){for(let h of t.params)if(h.typeAnnotation&&h.typeAnnotation.typeAnnotation){let p=h.type==="Identifier"?h.name:"param";o(h.typeAnnotation.typeAnnotation,p)}},FunctionDeclaration(t){for(let h of t.params)if(h.typeAnnotation&&h.typeAnnotation.typeAnnotation){let p=h.type==="Identifier"?h.name:"param";o(h.typeAnnotation.typeAnnotation,p)}},FunctionExpression(t){for(let h of t.params)if(h.typeAnnotation&&h.typeAnnotation.typeAnnotation){let p=h.type==="Identifier"?h.name:"param";o(h.typeAnnotation.typeAnnotation,p)}}}},meta:{docs:{description:"Enforce extracting inline union types to named types in type files"},schema:[{additionalProperties:!1,properties:{maxLength:{default:50,description:"Maximum character length for inline union types (default: 50)",minimum:1,type:"integer"},maxUnionMembers:{default:2,description:"Maximum union members to keep inline (default: 2)",minimum:1,type:"integer"}},type:"object"}],type:"suggestion"}},Vt={create(e){let n=e.sourceCode||e.getSourceCode(),I=e.options[0]||{},v=I.minUnionMembersForMultiline!==void 0?I.minUnionMembersForMultiline:5,x=/^[A-Z][a-zA-Z0-9]*$/,r=/^[a-z][a-zA-Z0-9]*$/,d=c=>/^[A-Z][A-Z0-9_]*$/.test(c)?c.toLowerCase().replace(/_([a-z0-9])/g,(o,t)=>t.toUpperCase()):/_/.test(c)?c.toLowerCase().replace(/_([a-z0-9])/g,(o,t)=>t.toUpperCase()):/^[A-Z]/.test(c)?c[0].toLowerCase()+c.slice(1):c,i=(c,o,t)=>{if(t.length===0)return;let p=n.lines[c.loc.start.line-1].match(/^\s*/)[0],l=p+"    ",a=n.getFirstToken(o),u=n.getLastToken(o),T=t[0];T.loc.start.line-a.loc.end.line>1&&e.report({fix:b=>b.replaceTextRange([a.range[1],T.range[0]],`
`+l),message:"No empty line after opening brace in type",node:T});let y=t[t.length-1];u.loc.start.line-y.loc.end.line>1&&e.report({fix:b=>b.replaceTextRange([y.range[1],u.range[0]],`
`+p),message:"No empty line before closing brace in type",node:y}),t.length>=2&&u.loc.start.line===y.loc.end.line&&e.report({fix:b=>b.replaceTextRange([y.range[1],u.range[0]],`
`+p),message:"Closing brace should be on its own line in multiline type literal",node:u}),t.length>1&&T.loc.start.line===a.loc.end.line&&e.report({fix:b=>b.replaceTextRange([a.range[1],T.range[0]],`
`+l),message:"First type property must be on a new line when there are multiple properties",node:T}),t.forEach((b,m)=>{if(b.type==="TSPropertySignature"&&b.key&&b.key.type==="Identifier"){let w=b.key.name;if(!r.test(w)){let E=d(w);e.report({fix:L=>L.replaceText(b.key,E),message:`Type property "${w}" must be camelCase. Use "${E}" instead.`,node:b.key})}}let k=null;if(b.type==="TSPropertySignature"&&b.typeAnnotation?.typeAnnotation){let w=b.typeAnnotation.typeAnnotation;w.type==="TSTypeLiteral"?k=w:w.type==="TSArrayType"&&w.elementType?.type==="TSTypeLiteral"&&(k=w.elementType)}if(k){let w=k;if(w.members&&w.members.length===1){let E=n.getFirstToken(w),L=n.getLastToken(w);if(E.loc.end.line!==L.loc.start.line){let g=w.members[0],f=n.getText(g).trim();(f.endsWith(",")||f.endsWith(";"))&&(f=f.slice(0,-1)),e.report({fix:S=>S.replaceTextRange([E.range[0],L.range[1]],`{ ${f} }`),message:"Single property nested object type should be on one line",node:w})}}else w.members&&w.members.length>=2&&i(b,w,w.members)}if(b.type==="TSPropertySignature"&&b.optional){let w=n.getFirstToken(b),E=n.getTokenAfter(w);E&&E.value==="?"&&n.getText().slice(w.range[1],E.range[0])!==""&&e.report({fix:C=>C.replaceTextRange([w.range[1],E.range[0]],""),message:'No space allowed before "?" in optional property',node:b})}let A=n.getText(b);if(A.trimEnd().endsWith(";")&&e.report({fix(w){let E=A.lastIndexOf(";"),L=b.range[0]+E;return w.replaceTextRange([L,L+1],",")},message:"Type properties must end with comma (,) not semicolon (;)",node:b}),t.length>=2&&m===t.length-1){let w=A.trimEnd();!w.endsWith(",")&&!w.endsWith(";")&&e.report({fix:E=>E.insertTextAfter(b,","),message:"Last type property must have trailing comma",node:b})}if(t.length>1&&m>0){let w=t[m-1];b.loc.start.line===w.loc.end.line&&e.report({fix:E=>{let L=n.getTokenAfter(w);for(;L&&L.value!==","&&L.range[0]<b.range[0];)L=n.getTokenAfter(L);let C=L&&L.value===","?L.range[1]:w.range[1];return E.replaceTextRange([C,b.range[0]],`
`+l)},message:"Each type property must be on its own line when there are multiple properties",node:b}),b.loc.start.line-w.loc.end.line>1&&e.report({fix(E){let C=n.getText().slice(w.range[1],b.range[0]).replace(/\n\s*\n/g,`
`);return E.replaceTextRange([w.range[1],b.range[0]],C)},message:"No empty lines allowed between type properties",node:b})}})},s=(c,o)=>{let{members:t}=c;if(t.length===0)return;let h=n.getFirstToken(c),p=n.getLastToken(c),l=h.loc.start.line!==p.loc.end.line;if(t.length===1){let T=t[0],y=n.getText(T);if(y.trimEnd().endsWith(",")){e.report({fix:b=>{let m=T.range[1]-1,A=n.getText().slice(T.range[0],T.range[1]).lastIndexOf(",");return A!==-1?b.removeRange([T.range[0]+A,T.range[0]+A+1]):null},message:"Single property inline type should not have trailing comma",node:T});return}if(l){let b=`{ ${y.trim().replace(/,$/,"")} }`;e.report({fix:m=>m.replaceText(c,b),message:"Single property inline type should be on one line",node:c})}return}if(!l){let T=n.getTokenBefore(c),y=n.getText().lastIndexOf(`
`,T.range[0])+1,m=n.getText().slice(y,T.range[0]).match(/^\s*/)[0],k=m+"        ",w=`{
${t.map(E=>{let L=n.getText(E).trim();return L.endsWith(";")?L=L.slice(0,-1)+",":L.endsWith(",")||(L+=","),k+L}).join(`
`)}
${m}    }`;e.report({fix:E=>E.replaceText(c,w),message:"Inline type with 2+ properties should be multiline with trailing commas",node:c});return}t.forEach((T,y)=>{let b=n.getText(T);if(b.trimEnd().endsWith(";")){let m=b.lastIndexOf(";");e.report({fix:k=>k.replaceTextRange([T.range[0]+m,T.range[0]+m+1],","),message:"Type properties must end with comma (,) not semicolon (;)",node:T})}else y===t.length-1&&!b.trimEnd().endsWith(",")&&e.report({fix:m=>m.insertTextAfter(T,","),message:"Last property in multiline inline type should have trailing comma",node:T});if(y<t.length-1){let m=t[y+1];m.loc.start.line-T.loc.end.line>1&&e.report({fix:k=>k.replaceTextRange([T.range[1],m.range[0]],`
`+" ".repeat(m.loc.start.column)),message:"No empty lines between type properties",node:m})}});let a=t[0];if(a.loc.start.line-h.loc.end.line>1&&e.report({fix:T=>T.replaceTextRange([h.range[1],a.range[0]],`
`+" ".repeat(a.loc.start.column)),message:"No empty line after opening brace in inline type",node:a}),t.length>=2&&h.loc.end.line===a.loc.start.line){let T=t[t.length-1],y=" ".repeat(T.loc.start.column);e.report({fix:b=>b.replaceTextRange([h.range[1],a.range[0]],`
`+y),message:"First property of multiline inline type should be on its own line",node:a})}let u=t[t.length-1];if(p.loc.start.line-u.loc.end.line>1){let T=" ".repeat(p.loc.start.column);e.report({fix:y=>y.replaceTextRange([u.range[1],p.range[0]],`
`+T),message:"No empty line before closing brace in inline type",node:p})}if(t.length>=2&&p.loc.start.line===u.loc.end.line){let T=n.getTokenBefore(c,y=>y.value==="as");if(T){let y=n.getText().lastIndexOf(`
`,T.range[0])+1,m=n.getText().slice(y,T.range[0]).match(/^\s*/)[0];e.report({fix:k=>k.replaceTextRange([u.range[1],p.range[0]],`
`+m+"    "),message:"Closing brace should be on its own line in multiline type literal",node:p})}}};return{TSAsExpression(c){let{typeAnnotation:o}=c,t=n.getTokenBefore(o,h=>h.value==="as");if(t&&o){let h=n.getFirstToken(o),p=n.text.slice(t.range[1],h.range[0]);h.value==="{"?p!==" "&&e.report({fix:l=>l.replaceTextRange([t.range[1],h.range[0]]," "),message:"Type assertion should have exactly one space after 'as' and opening brace on same line",node:h}):t.loc.end.line!==h.loc.start.line&&e.report({fix:l=>l.replaceTextRange([t.range[1],h.range[0]]," "),message:"Type should be on same line as 'as' keyword",node:h})}o&&o.type==="TSTypeLiteral"&&s(o,c)},TSTypeAliasDeclaration(c){let o=c.id.name;if(x.test(o)?o.endsWith("Type")||e.report({fix(t){return t.replaceText(c.id,`${o}Type`)},message:`Type name "${o}" must end with "Type" suffix. Use "${o}Type" instead of "${o}"`,node:c.id}):e.report({message:`Type name "${o}" must be PascalCase`,node:c.id}),c.typeAnnotation&&c.typeAnnotation.type==="TSTypeLiteral"){let{members:t}=c.typeAnnotation;if(t.length===1){let h=n.getFirstToken(c.typeAnnotation),p=n.getLastToken(c.typeAnnotation),l=h.loc.start.line!==p.loc.end.line,a=t[0],u=n.getText(a).trim();if((u.endsWith(",")||u.endsWith(";"))&&(u=u.slice(0,-1)),l){let T=n.getTokenAfter(c.id);e.report({fix:y=>y.replaceTextRange([T.range[0],p.range[1]],`= { ${u} }`),message:"Single property type should be on one line",node:c.typeAnnotation})}else{let T=n.getText(a);if(T.trimEnd().endsWith(",")){let y=T.lastIndexOf(",");e.report({fix:b=>b.removeRange([a.range[0]+y,a.range[0]+y+1]),message:"Single property inline type should not have trailing comma",node:a})}else if(T.trimEnd().endsWith(";")){let y=T.lastIndexOf(";");e.report({fix:b=>b.replaceTextRange([a.range[0]+y,a.range[0]+y+1],","),message:"Type properties must end with comma (,) not semicolon (;)",node:a})}}}else{let h=n.getFirstToken(c.typeAnnotation);h&&h.loc.start.line!==c.id.loc.end.line&&e.report({fix:p=>{let l=n.getTokenAfter(c.id);return p.replaceTextRange([l.range[1],h.range[0]]," ")},message:"Opening brace must be on the same line as type name",node:h}),i(c,c.typeAnnotation,c.typeAnnotation.members)}}if(c.typeAnnotation&&c.typeAnnotation.type==="TSIntersectionType"){let t=c.typeAnnotation.types,h=n.getTokenAfter(c.id);t.forEach(p=>{if(p.type!=="TSTypeLiteral")return;let{members:l}=p;if(l.length!==0)if(l.length===1){let a=n.getFirstToken(p),u=n.getLastToken(p),T=l[0];if(a.loc.start.line!==u.loc.end.line){let b=n.getText(T).trim();(b.endsWith(",")||b.endsWith(";"))&&(b=b.slice(0,-1)),e.report({fix:m=>m.replaceTextRange([a.range[0],u.range[1]],`{ ${b} }`),message:"Single property type in intersection should be inline",node:p})}else{let b=n.getText(T);if(b.trimEnd().endsWith(",")){let m=b.lastIndexOf(",");e.report({fix:k=>k.removeRange([T.range[0]+m,T.range[0]+m+1]),message:"Single property inline type should not have trailing comma",node:T})}else if(b.trimEnd().endsWith(";")){let m=b.lastIndexOf(";");e.report({fix:k=>k.replaceTextRange([T.range[0]+m,T.range[0]+m+1],","),message:"Type properties must end with comma (,) not semicolon (;)",node:T})}}}else i(c,p,l)}),h&&t[0]&&t[0].loc.start.line!==h.loc.end.line&&e.report({fix:p=>p.replaceTextRange([h.range[1],t[0].range[0]]," "),message:"First intersection member should be on same line as '='",node:t[0]});for(let p=1;p<t.length;p++){let l=t[p-1],a=t[p],u=n.getTokenBefore(a,T=>T.value==="&");u&&(u.loc.start.line!==l.loc.end.line&&e.report({fix:T=>T.replaceTextRange([l.range[1],u.range[0]]," "),message:"'&' should be on same line as previous intersection member",node:u}),a.loc.start.line!==u.loc.start.line&&e.report({fix:T=>T.replaceTextRange([u.range[1],a.range[0]]," "),message:"Intersection member should be on same line as '&'",node:a}))}}if(c.typeAnnotation&&c.typeAnnotation.type==="TSUnionType"){let t=c.typeAnnotation,h=t.types,p=v,u=n.lines[c.loc.start.line-1].match(/^\s*/)[0]+"    ",T=n.getTokenAfter(c.id),y=h[0],b=h[h.length-1],m=y.loc.start.line===b.loc.end.line&&T.loc.end.line===y.loc.start.line,k=y.loc.start.line>T.loc.end.line;if(h.length>=p){let A=!1;if(k||(A=!0),!A){for(let w=1;w<h.length;w++)if(h[w].loc.start.line===h[w-1].loc.end.line){A=!0;break}}if(!A)for(let w=1;w<h.length;w++){let E=n.getTokenBefore(h[w]);if(E&&E.value==="|"&&E.loc.start.line!==h[w].loc.start.line){A=!0;break}}if(A){let E=`= 
${h.map((L,C)=>{let g=n.getText(L);return C===0?u+g:u+"| "+g}).join(`
`)}`;e.report({fix:L=>L.replaceTextRange([T.range[0],b.range[1]],E),message:`Union type with ${h.length} members should be multiline with each member on its own line`,node:t})}}else{let A=h.some(w=>w.type==="TSTypeLiteral"&&w.members&&w.members.length>=2);if(!m&&!A){let E=`= ${h.map(L=>n.getText(L)).join(" | ")}`;e.report({fix:L=>L.replaceTextRange([T.range[0],b.range[1]],E),message:`Union type with ${h.length} members should be on a single line`,node:t})}}}},TSTypeLiteral(c){if(c.parent?.type==="TSTypeAliasDeclaration"||c.parent?.type==="TSAsExpression"||c.parent?.type==="TSTypeAnnotation"&&c.parent.parent?.type==="TSPropertySignature"&&c.parent.parent.parent?.type==="TSTypeLiteral"&&(c.parent.parent.parent.parent?.type==="TSTypeAliasDeclaration"||c.parent.parent.parent.parent?.type==="TSIntersectionType")||!c.members||c.members.length===0)return;let o=c.parent;for(;o&&!o.loc;)o=o.parent;o&&i(o,c,c.members)}}},meta:{docs:{description:"Enforce type naming (PascalCase + Type suffix), camelCase properties, proper formatting, union type formatting, and trailing commas"},fixable:"code",schema:[{additionalProperties:!1,properties:{minUnionMembersForMultiline:{default:5,description:"Minimum number of union members to require multiline format",minimum:2,type:"integer"}},type:"object"}],type:"suggestion"}},Ut={create(e){let n=e.sourceCode||e.getSourceCode();return{ArrowFunctionExpression(I){if(I.async){let v=n.getFirstToken(I,r=>r.value==="async"),x=n.getTokenAfter(v,r=>r.value==="(");if(v&&x){let r=n.text.slice(v.range[1],x.range[0]);r===""?e.report({fix:d=>d.insertTextAfter(v," "),message:"Missing space after async keyword",node:v}):r!==" "&&!r.includes(`
`)&&e.report({fix:d=>d.replaceTextRange([v.range[1],x.range[0]]," "),message:"Should have exactly one space after async keyword",node:v})}}},FunctionExpression(I){if(I.async){let v=n.getFirstToken(I,r=>r.value==="async"),x=n.getTokenAfter(v,r=>r.value==="function");if(x){let r=n.getTokenAfter(x,d=>d.value==="(");r&&n.text.slice(x.range[1],r.range[0])===""&&e.report({fix:i=>i.insertTextAfter(x," "),message:"Missing space after function keyword",node:x})}}},TSArrayType(I){let v=I.elementType,x=n.getTokenAfter(v,r=>r.value==="[");x&&n.text.slice(v.range[1],x.range[0])!==""&&e.report({fix:d=>d.removeRange([v.range[1],x.range[0]]),message:"No space allowed before [] in array type",node:x})},TSTypeReference(I){if(I.typeArguments||I.typeParameters){let v=I.typeArguments||I.typeParameters,x=n.getFirstToken(v);if(x&&x.value==="<"){let r=n.getTokenBefore(x);r&&n.text.slice(r.range[1],x.range[0])!==""&&e.report({fix:i=>i.removeRange([r.range[1],x.range[0]]),message:"No space allowed before < in generic type",node:x})}}},TSTypeAnnotation(I){let v=n.getFirstToken(I);if(!v||v.value!==":")return;let x=n.getTokenBefore(v);if(x&&n.getText().slice(x.range[1],v.range[0])!==""){e.report({fix:i=>i.removeRange([x.range[1],v.range[0]]),message:"No space allowed before colon in type annotation",node:v});return}let r=I.typeAnnotation;if(r&&n.text.slice(v.range[1],r.range[0])===""){e.report({fix:i=>i.insertTextAfter(v," "),message:"Missing space after colon in type annotation",node:v});return}r&&v.loc.end.line!==r.loc.start.line&&e.report({fix:d=>d.replaceTextRange([v.range[1],r.range[0]]," "),message:"Type should be on the same line as colon in type annotation",node:r})},TSTypeParameterInstantiation(I){let v=n.getFirstToken(I),x=n.getLastToken(I);if(!v||!x||v.value!=="<"||x.value!==">")return;let r=I.params[0],d=r&&v.loc.end.line===x.loc.start.line;if(r&&d){let o=n.getText().slice(v.range[1],r.range[0]);o.trim()===""&&o!==""&&e.report({fix:t=>t.removeRange([v.range[1],r.range[0]]),message:"No space allowed after < in generic type",node:v})}let i=I.params[I.params.length-1];if(i&&d){let o=n.getText().slice(i.range[1],x.range[0]);o.trim()===""&&o!==""&&e.report({fix:t=>t.removeRange([i.range[1],x.range[0]]),message:"No space allowed before > in generic type",node:x})}let s=I.params;if(s.length===1){let o=s[0];if(v.loc.end.line!==x.loc.start.line){let p=n.getText(o).trim(),l=p.endsWith(",")?p.slice(0,-1):p;e.report({fix:a=>a.replaceTextRange([v.range[1],x.range[0]],l),message:"Single generic type parameter should be inline",node:I});return}let h=n.getText(o);if(h.trimEnd().endsWith(",")){let p=h.lastIndexOf(",");e.report({fix:l=>l.removeRange([o.range[0]+p,o.range[0]+p+1]),message:"Single generic type parameter should not have trailing comma",node:o});return}}else if(s.length>=2){if(n.getText().slice(v.range[0],x.range[1]).length<=80&&v.loc.start.line===x.loc.end.line)return;let h=n.lines[I.loc.start.line-1].match(/^\s*/)[0],p=h+"    ",l=r.loc.start.line>v.loc.end.line,a=x.loc.start.line>i.loc.end.line,u=!l||!a;if(!u){for(let T=1;T<s.length;T++)if(s[T].loc.start.line===s[T-1].loc.end.line){u=!0;break}}if(!u){for(let T=0;T<s.length-1;T++){let y=n.getTokenAfter(s[T]);if(!y||y.value!==","){u=!0;break}}if(!u){let T=n.getTokenAfter(i);T&&T.value===","&&(u=!0)}}if(u){let T=s.map((y,b)=>{let m=n.getText(y).trim(),k=b<s.length-1?",":"";return p+m+k}).join(`
`);e.report({fix:y=>y.replaceTextRange([v.range[1],x.range[0]],`
`+T+`
`+h),message:"Generic type parameters should each be on their own line",node:I});return}}I.params.forEach(o=>{if(o.type==="TSTypeLiteral"&&o.members&&o.members.length>0){let t=n.getFirstToken(o),h=n.getLastToken(o);if(!t||!h||t.value!=="{"||h.value!=="}")return;let p=o.members,l=t.loc.start.line!==h.loc.end.line;if(p.length===1){let T=p[0],y=n.getText(T).trim(),b=y;if((y.endsWith(",")||y.endsWith(";"))&&(y=y.slice(0,-1)),l){let m=`{ ${y} }`;e.report({fix:k=>k.replaceText(o,m),message:"Single property generic type literal should be on one line",node:o});return}if(b.endsWith(",")||b.endsWith(";")){let m=`{ ${y} }`;e.report({fix:k=>k.replaceText(o,m),message:"Single property generic type literal should not have trailing punctuation",node:o})}return}if(!l){let T=n.getText().lastIndexOf(`
`,I.range[0])+1,b=n.getText().slice(T,I.range[0]).match(/^\s*/)[0],m=b+"    ",A=`{
${p.map(w=>{let E=n.getText(w).trim();return E.endsWith(";")?E=E.slice(0,-1)+",":E.endsWith(",")||(E+=","),m+E}).join(`
`)}
${b}}`;e.report({fix:w=>w.replaceText(o,A),message:"Generic type literal with 2+ properties should be multiline",node:o});return}let a=p[0],u=p[p.length-1];a&&t.loc.end.line<a.loc.start.line-1&&e.report({fix:T=>{let b=n.text.slice(t.range[1],a.range[0]).replace(/\n\s*\n/,`
`);return T.replaceTextRange([t.range[1],a.range[0]],b)},message:"No empty line allowed after opening brace in generic type literal",node:t}),u&&u.loc.end.line<h.loc.start.line-1&&e.report({fix:T=>{let b=n.text.slice(u.range[1],h.range[0]).replace(/\n\s*\n/,`
`);return T.replaceTextRange([u.range[1],h.range[0]],b)},message:"No empty line allowed before closing brace in generic type literal",node:h}),p.forEach((T,y)=>{let b=n.getText(T);if(b.trimEnd().endsWith(";")){let m=b.lastIndexOf(";");e.report({fix:k=>k.replaceTextRange([T.range[0]+m,T.range[0]+m+1],","),message:"Type properties must end with comma (,) not semicolon (;)",node:T})}else y===p.length-1&&!b.trimEnd().endsWith(",")&&e.report({fix:m=>m.insertTextAfter(T,","),message:"Last property in generic type literal should have trailing comma",node:T});if(y<p.length-1){let m=p[y+1];m.loc.start.line-T.loc.end.line>1&&e.report({fix:k=>k.replaceTextRange([T.range[1],m.range[0]],`
`+" ".repeat(m.loc.start.column)),message:"No empty lines between type properties in generic",node:m})}})}});let c=I.parent;if(c&&c.type==="CallExpression"&&c.typeArguments===I){let o=c.arguments;if(o&&o.length>0){let t=n.getTokenAfter(x,h=>h.value==="(");if(t&&(x.loc.end.line!==t.loc.start.line&&e.report({fix:h=>h.replaceTextRange([x.range[1],t.range[0]],""),message:"Opening parenthesis should be on same line as closing > in generic call",node:t}),o.length===1)){let h=o[0];if(h&&(h.type==="ObjectExpression"||h.type==="ArrayExpression")){let p=n.getFirstToken(h);p&&t.loc.end.line!==p.loc.start.line&&e.report({fix:u=>u.replaceTextRange([t.range[1],p.range[0]],""),message:"First argument should be on same line as opening parenthesis in generic call",node:h});let l=n.getLastToken(h),a=n.getTokenAfter(h,u=>u.value===")");if(l&&a){let u=n.text.slice(l.range[1],a.range[0]);if(u.includes(`
`)){let T=u.trim()===",";e.report({fix:y=>T?y.replaceTextRange([l.range[1],a.range[0]],""):y.replaceTextRange([l.range[1],a.range[0]],""),message:"Closing parenthesis should be on same line as closing brace in generic call",node:a})}}}}}}},VariableDeclaration(I){let v=n.getLastToken(I);if(v&&v.value===";"){let x=n.getTokenBefore(v);x&&v.loc.start.line>x.loc.end.line&&e.report({fix:r=>r.replaceTextRange([x.range[1],v.range[1]],";"),message:"Semicolon should be on the same line as statement",node:v})}},TSFunctionType(I){let v=n.getTokens(I),x=v.find(i=>i.value==="=>");if(x){let i=n.getTokenAfter(x);if(i){let s=n.text.slice(x.range[1],i.range[0]);s===""?e.report({fix:c=>c.insertTextAfter(x," "),message:"Missing space after => in function type",node:x}):s!==" "&&!s.includes(`
`)&&e.report({fix:c=>c.replaceTextRange([x.range[1],i.range[0]]," "),message:"Should have exactly one space after => in function type",node:x})}}let r=I.params,d=v.find(i=>i.value==="(");if(d&&x){let i=n.getTokenBefore(x,s=>s.value===")");if(i){let s=d.loc.start.line!==i.loc.end.line;if(r&&r.length>=3&&!s){let c=n.text.lastIndexOf(`
`,I.range[0])+1,t=n.text.slice(c,I.range[0]).match(/^(\s*)/),h=t?t[1]:"",p=h+"    ",a=`(
${r.map(u=>{let T=n.getText(u);return p+T}).join(`,
`)},
${h})`;e.report({fix:u=>u.replaceTextRange([d.range[0],i.range[1]],a),message:"Function type with 3+ parameters should have each parameter on its own line",node:I})}else if(r&&r.length<=2&&s){let o=`(${r.map(t=>n.getText(t).trim()).join(", ")})`;e.report({fix:t=>t.replaceTextRange([d.range[0],i.range[1]],o),message:"Function type with 2 or fewer parameters should be on one line",node:I})}}}},VariableDeclarator(I){if(I.id&&I.id.typeAnnotation){let v=I.id.typeAnnotation.typeAnnotation;if(v&&v.type==="TSTypeReference"&&v.typeArguments){let x=v.typeName,r=v.typeArguments;n.getText().slice(x.range[1],r.range[0])!==""&&e.report({fix:i=>i.removeRange([x.range[1],r.range[0]]),message:"No space allowed between type name and generic parameters",node:r})}}}}},meta:{docs:{description:"Enforce proper spacing in TypeScript type annotations"},fixable:"whitespace",schema:[],type:"layout"}},_t={create(e){let n=e.sourceCode||e.getSourceCode(),I=/^[A-Z][a-zA-Z0-9]*$/,v=/^[A-Z][A-Z0-9_]*$/;return{TSEnumDeclaration(x){let r=x.id.name;I.test(r)?r.endsWith("Enum")||e.report({fix(a){return a.replaceText(x.id,`${r}Enum`)},message:`Enum name "${r}" must end with "Enum" suffix. Use "${r}Enum" instead of "${r}"`,node:x.id}):e.report({message:`Enum name "${r}" must be PascalCase`,node:x.id});let d=n.getTokenAfter(x.id,{filter:a=>a.value==="{"});d&&d.loc.start.line!==x.id.loc.end.line&&e.report({fix:a=>a.replaceTextRange([x.id.range[1],d.range[0]]," "),message:"Opening brace must be on the same line as enum name",node:d});let i=x.members;if(i.length===0)return;let c=n.lines[x.loc.start.line-1].match(/^\s*/)[0],o=c+"    ",t=n.getLastToken(x),h=i[0];d&&h.loc.start.line-d.loc.end.line>1&&e.report({fix:a=>a.replaceTextRange([d.range[1],h.range[0]],`
`+o),message:"No empty line after opening brace in enum",node:h});let p=i[i.length-1];if(t&&t.loc.start.line-p.loc.end.line>1&&e.report({fix:a=>a.replaceTextRange([p.range[1],t.range[0]],`
`+c),message:"No empty line before closing brace in enum",node:p}),i.length===1){let a=i[0],u=n.getText(a);if(d.loc.end.line!==t.loc.start.line){let y=u.trim();y.endsWith(",")&&(y=y.slice(0,-1));let b=`{ ${y} }`;e.report({fix:m=>m.replaceTextRange([d.range[0],t.range[1]],b),message:"Single member enum should be on one line without trailing comma",node:x});return}if(u.trimEnd().endsWith(",")){let y=u.lastIndexOf(",");e.report({fix:b=>b.removeRange([a.range[0]+y,a.range[0]+y+1]),message:"Single member enum should not have trailing comma",node:a})}return}d&&h.loc.start.line===d.loc.end.line&&e.report({fix:a=>a.replaceTextRange([d.range[1],h.range[0]],`
`+o),message:"First enum member must be on a new line when there are multiple members",node:h});let l=a=>a.replace(/([a-z0-9])([A-Z])/g,"$1_$2").replace(/([A-Z]+)([A-Z][a-z])/g,"$1_$2").toUpperCase();if(i.forEach((a,u)=>{if(a.id&&a.id.type==="Identifier"){let y=a.id.name;if(!v.test(y)){let b=l(y);e.report({fix:m=>m.replaceText(a.id,b),message:`Enum member "${y}" must be UPPER_CASE (e.g., ${b})`,node:a.id})}}if(!(u===i.length-1)||i.length===1){let y=n.getText(a);y.trimEnd().endsWith(";")&&e.report({fix(b){let m=y.lastIndexOf(";"),k=a.range[0]+m;return b.replaceTextRange([k,k+1],",")},message:"Enum members must end with comma (,) not semicolon (;)",node:a})}if(i.length>1&&u>0){let y=i[u-1];a.loc.start.line===y.loc.end.line&&e.report({fix:b=>{let m=n.getTokenAfter(y);for(;m&&m.value!==","&&m.range[0]<a.range[0];)m=n.getTokenAfter(m);let k=m&&m.value===","?m.range[1]:y.range[1];return b.replaceTextRange([k,a.range[0]],`
`+o)},message:"Each enum member must be on its own line when there are multiple members",node:a}),a.loc.start.line-y.loc.end.line>1&&e.report({fix(b){let k=n.getText().slice(y.range[1],a.range[0]).replace(/\n\s*\n/g,`
`);return b.replaceTextRange([y.range[1],a.range[0]],k)},message:"No empty lines allowed between enum members",node:a})}}),i.length>1){let a=n.getText(p),u=a.trimEnd(),T=n.getTokenAfter(p),y=u.endsWith(",")||T&&T.value===",",b=u.endsWith(";"),m=t&&t.loc.start.line===p.loc.end.line;if(b){let k=a.lastIndexOf(";"),A=p.range[0]+k;m?e.report({fix:w=>w.replaceTextRange([A,t.range[0]],`,
`+c),message:"Last enum member must end with comma and closing brace must be on its own line",node:p}):e.report({fix:w=>w.replaceTextRange([A,A+1],","),message:"Enum members must end with comma (,) not semicolon (;)",node:p})}else!y&&m?e.report({fix:k=>k.replaceTextRange([p.range[1],t.range[0]],`,
`+c),message:"Last enum member must have trailing comma and closing brace must be on its own line",node:p}):y?m&&e.report({fix:k=>k.replaceTextRange([p.range[1],t.range[0]],`
`+c),message:"Closing brace must be on its own line",node:t}):e.report({fix:k=>k.insertTextAfter(p,","),message:"Last enum member must have trailing comma",node:p})}}}},meta:{docs:{description:"Enforce enum naming (PascalCase + Enum suffix), UPPER_CASE members, proper formatting, and trailing commas"},fixable:"code",schema:[],type:"suggestion"}},qt={create(e){let n=e.sourceCode||e.getSourceCode(),I=/^[A-Z][a-zA-Z0-9]*$/,v=/^[a-z][a-zA-Z0-9]*$/,x=r=>/^[A-Z][A-Z0-9_]*$/.test(r)?r.toLowerCase().replace(/_([a-z0-9])/g,(d,i)=>i.toUpperCase()):/_/.test(r)?r.toLowerCase().replace(/_([a-z0-9])/g,(d,i)=>i.toUpperCase()):/^[A-Z]/.test(r)?r[0].toLowerCase()+r.slice(1):r;return{TSInterfaceDeclaration(r){let d=r.id.name;I.test(d)?d.endsWith("Interface")||e.report({fix(a){return a.replaceText(r.id,`${d}Interface`)},message:`Interface name "${d}" must end with "Interface" suffix. Use "${d}Interface" instead of "${d}"`,node:r.id}):e.report({message:`Interface name "${d}" must be PascalCase`,node:r.id});let i=n.getFirstToken(r.body);i&&i.loc.start.line!==r.id.loc.end.line&&e.report({fix:a=>a.replaceTextRange([r.id.range[1],i.range[0]]," "),message:"Opening brace must be on the same line as interface name",node:i});let s=r.body.body;if(s.length===0)return;let o=n.lines[r.loc.start.line-1].match(/^\s*/)[0],t=o+"    ",h=n.getLastToken(r.body),p=s[0];p.loc.start.line-i.loc.end.line>1&&e.report({fix:a=>a.replaceTextRange([i.range[1],p.range[0]],`
`+t),message:"No empty line after opening brace in interface",node:p});let l=s[s.length-1];if(h.loc.start.line-l.loc.end.line>1&&e.report({fix:a=>a.replaceTextRange([l.range[1],h.range[0]],`
`+o),message:"No empty line before closing brace in interface",node:l}),s.length===1){let a=s[0],u=i.loc.end.line!==h.loc.start.line,T=a.typeAnnotation?.typeAnnotation,y=T?.type==="TSTypeLiteral",b=y&&T.members?.length>=2,m=y&&T.members?.length===1,k=T?.type==="TSFunctionType"&&T.loc.start.line!==T.loc.end.line;if(u&&!b&&!k){let w;if(m){let L=T.members[0],C=n.getText(L).trim();(C.endsWith(",")||C.endsWith(";"))&&(C=C.slice(0,-1));let g=a.key.name,f=a.optional?"?":"";w=`${g}${f}: { ${C} }`}else w=n.getText(a).trim(),(w.endsWith(",")||w.endsWith(";"))&&(w=w.slice(0,-1));let E=`{ ${w} }`;e.report({fix:L=>L.replaceTextRange([i.range[0],h.range[1]],E),message:"Single property interface should be on one line without trailing punctuation",node:r});return}let A=n.getText(a);if(A.trimEnd().endsWith(",")||A.trimEnd().endsWith(";")){let w=Math.max(A.lastIndexOf(","),A.lastIndexOf(";"));e.report({fix:E=>E.removeRange([a.range[0]+w,a.range[0]+w+1]),message:"Single property interface should not have trailing punctuation",node:a})}return}if(p.loc.start.line===i.loc.end.line&&e.report({fix:a=>a.replaceTextRange([i.range[1],p.range[0]],`
`+t),message:"First interface property must be on a new line when there are multiple properties",node:p}),s.forEach((a,u)=>{if(a.type==="TSPropertySignature"&&a.key&&a.key.type==="Identifier"){let y=a.key.name;if(!v.test(y)){let b=x(y);e.report({fix:m=>m.replaceText(a.key,b),message:`Interface property "${y}" must be camelCase. Use "${b}" instead.`,node:a.key})}}if(a.type==="TSPropertySignature"&&a.typeAnnotation?.typeAnnotation?.type==="TSTypeLiteral"){let y=a.typeAnnotation.typeAnnotation;if(y.members&&y.members.length===1){let b=n.getFirstToken(y),m=n.getLastToken(y);if(b.loc.end.line!==m.loc.start.line){let A=y.members[0],w=n.getText(A).trim();(w.endsWith(",")||w.endsWith(";"))&&(w=w.slice(0,-1)),e.report({fix:E=>E.replaceTextRange([b.range[0],m.range[1]],`{ ${w} }`),message:"Single property nested object type should be on one line",node:y})}}}if(a.type==="TSPropertySignature"&&a.optional){let y=n.getFirstToken(a),b=n.getTokenAfter(y);b&&b.value==="?"&&n.getText().slice(y.range[1],b.range[0])!==""&&e.report({fix:k=>k.replaceTextRange([y.range[1],b.range[0]],""),message:'No space allowed before "?" in optional property',node:a})}if(!(u===s.length-1)||s.length===1){let y=n.getText(a);y.trimEnd().endsWith(";")&&e.report({fix(b){let m=y.lastIndexOf(";"),k=a.range[0]+m;return b.replaceTextRange([k,k+1],",")},message:"Interface properties must end with comma (,) not semicolon (;)",node:a})}if(s.length>1&&u>0){let y=s[u-1];a.loc.start.line===y.loc.end.line&&e.report({fix:b=>{let m=n.getTokenAfter(y);for(;m&&m.value!==","&&m.range[0]<a.range[0];)m=n.getTokenAfter(m);let k=m&&m.value===","?m.range[1]:y.range[1];return b.replaceTextRange([k,a.range[0]],`
`+t)},message:"Each interface property must be on its own line when there are multiple properties",node:a}),a.loc.start.line-y.loc.end.line>1&&e.report({fix(b){let k=n.getText().slice(y.range[1],a.range[0]).replace(/\n\s*\n/g,`
`);return b.replaceTextRange([y.range[1],a.range[0]],k)},message:"No empty lines allowed between interface properties",node:a})}}),s.length>1){let a=n.getText(l),u=a.trimEnd(),T=n.getTokenAfter(l),y=u.endsWith(",")||T&&T.value===",",b=u.endsWith(";"),m=h.loc.start.line===l.loc.end.line;if(b){let k=a.lastIndexOf(";"),A=l.range[0]+k;m?e.report({fix:w=>w.replaceTextRange([A,h.range[0]],`,
`+o),message:"Last interface property must end with comma and closing brace must be on its own line",node:l}):e.report({fix:w=>w.replaceTextRange([A,A+1],","),message:"Interface properties must end with comma (,) not semicolon (;)",node:l})}else!y&&m?e.report({fix:k=>k.replaceTextRange([l.range[1],h.range[0]],`,
`+o),message:"Last interface property must have trailing comma and closing brace must be on its own line",node:l}):y?m&&e.report({fix:k=>k.replaceTextRange([l.range[1],h.range[0]],`
`+o),message:"Closing brace must be on its own line",node:h}):e.report({fix:k=>k.insertTextAfter(l,","),message:"Last interface property must have trailing comma",node:l})}}}},meta:{docs:{description:"Enforce interface naming (PascalCase + Interface suffix), camelCase properties, proper formatting, and trailing commas"},fixable:"code",schema:[],type:"suggestion"}},Zt={create(e){let I=(e.filename||e.getFilename()).replace(/\\/g,"/"),v=r=>new RegExp(`/${r}/[^/]+\\.(ts|tsx)$`).test(I),x=()=>/\.(ts|tsx)$/.test(I);return{TSInterfaceDeclaration(r){x()&&(v("interfaces")||e.report({message:'Interfaces must be declared in files inside the "interfaces" folder',node:r.id||r}))},TSEnumDeclaration(r){x()&&(v("enums")||e.report({message:'Enums must be declared in files inside the "enums" folder',node:r.id||r}))},TSTypeAliasDeclaration(r){x()&&(v("types")||e.report({message:'Type aliases must be declared in files inside the "types" folder',node:r.id||r}))}}},meta:{docs:{description:"Enforce that interfaces are in interfaces folder, enums in enums folder, and types in types folder"},schema:[],type:"suggestion"}};var Kt={create(e){let n=e.sourceCode||e.getSourceCode(),I=/^[a-z][a-zA-Z0-9]*$/,v=/^[A-Z][a-zA-Z0-9]*$/,x=/^use[A-Z][a-zA-Z0-9]*$/,r=/^[A-Z][A-Z0-9_]*$/,d=m=>/^[A-Z][A-Z0-9_]*$/.test(m)?m.toLowerCase().replace(/_([a-z0-9])/g,(k,A)=>A.toUpperCase()):/_/.test(m)?m.toLowerCase().replace(/_([a-z0-9])/g,(k,A)=>A.toUpperCase()):/^[A-Z]/.test(m)?m[0].toLowerCase()+m.slice(1):m,i=m=>{let A=(n.getScope?n.getScope(m):e.getScope()).variables.find(w=>w.name===m.name);return A?A.references.map(w=>w.identifier):[]},s=["ArrowFunctionExpression","CallExpression","FunctionDeclaration","FunctionExpression","Property","VariableDeclarator","JSXElement","JSXOpeningElement","ReturnStatement","SwitchCase","SwitchStatement","ObjectExpression","ObjectPattern","BlockStatement","IfStatement","Identifier","RestElement","AssignmentPattern","ArrayPattern","MemberExpression","JSXText","JSXAttribute","JSXExpressionContainer","Function","Object","Array","String","Number","Boolean","Symbol","BigInt","Date","RegExp","Error","Map","Set","WeakMap","WeakSet","Promise"],c=m=>{if(!m||m.type!=="CallExpression")return!1;let{callee:k}=m;if(k.type==="CallExpression"){let A=k.callee;if(A.type==="Identifier"&&A.name==="styled"||A.type==="MemberExpression"&&A.object.name==="styled")return!0}return!1},o=m=>{if(m.type!=="CallExpression")return!1;let{callee:k}=m;return k.type==="Identifier"&&k.name==="styled"},t=m=>{if(!m)return!1;if(m.type==="ArrowFunctionExpression"||m.type==="FunctionExpression")return!0;if(m.type==="CallExpression"&&m.callee){let k=m.callee.name||m.callee.property&&m.callee.property.name;return["memo","forwardRef","lazy","createContext"].includes(k)}return!1},h=m=>{if(!m.init)return!1;let k=m.id.name;if(/^[A-Z]/.test(k)&&t(m.init)||/^[A-Z]/.test(k)&&m.init.type==="MemberExpression"&&m.init.object.type==="Identifier"&&/^[A-Z]/.test(m.init.object.name))return!0;if(/^[A-Z]/.test(k)&&m.init.type==="ConditionalExpression"){let{consequent:A,alternate:w}=m.init,E=L=>L.type==="Identifier"&&/^[A-Z]/.test(L.name)||L.type==="Literal"&&typeof L.value=="string"||L.type==="MemberExpression"&&L.object.type==="Identifier"&&/^[A-Z]/.test(L.object.name);if(E(A)||E(w))return!0}return!1},p=m=>{if(!m.init)return!1;let k=m.id.name;return k.startsWith("use")&&/^use[A-Z]/.test(k)&&t(m.init)},l=["Icon","Component","FormComponent","Layout","Wrapper","Container","Provider"],a=(m,k)=>{if(m.type==="Identifier"){let A=m.name;if(A.startsWith("_")||r.test(A)||s.includes(A)||l.includes(A))return;I.test(A)||e.report({message:`${k} "${A}" should be camelCase`,node:m})}else m.type==="ObjectPattern"?m.properties.forEach(A=>{A.type==="Property"?a(A.value,k):A.type==="RestElement"&&a(A.argument,k)}):m.type==="ArrayPattern"?m.elements.forEach(A=>{A&&a(A,k)}):m.type==="AssignmentPattern"?a(m.left,k):m.type==="RestElement"&&a(m.argument,k)},u=m=>{if(m.id.type!=="Identifier"){a(m.id,"Variable");return}let k=m.id.name;if(c(m.init)){v.test(k)||e.report({message:`Styled component "${k}" should be PascalCase (e.g., StyledCard instead of styledCard)`,node:m.id});return}if(k.startsWith("_")||h(m))return;let A=["Component","Icon","Layout","Wrapper","Container","Provider","View","Screen","Page"];if(v.test(k)&&A.some(E=>k.endsWith(E)))return;if(p(m)){x.test(k)||e.report({message:`Hook "${k}" should start with "use" followed by PascalCase (e.g., useEventsList)`,node:m.id});return}if(!([/^[A-Z][a-zA-Z]*Data$/,/^[A-Z][a-zA-Z]*Config$/,/^Routes$/].some(E=>E.test(k))&&m.init&&(m.init.type==="ArrayExpression"||m.init.type==="ObjectExpression"||m.init.type==="CallExpression"))&&!I.test(k)){let E=d(k),L=i(m.id);e.report({fix:C=>{let g=[];return L.forEach(f=>{g.push(C.replaceText(f,E))}),g},message:`Variable "${k}" should be camelCase (e.g., ${E} instead of ${k})`,node:m.id})}},T=m=>{if(m.computed||m.key.type!=="Identifier")return;let k=m.key.name;if(!(k.startsWith("_")||s.includes(k))){if(m.value&&m.value.type==="Identifier"){let A=m.value.name;if(v.test(A)&&v.test(k))return}if(!l.includes(k)&&!k.startsWith("Mui")&&!I.test(k)){let A=d(k);e.report({fix:w=>w.replaceText(m.key,A),message:`Property "${k}" should be camelCase (e.g., ${A} instead of ${k})`,node:m.key})}}},y=m=>{m.params.forEach(k=>a(k,"Parameter"))};return{ArrowFunctionExpression:y,CallExpression:m=>{o(m)||m.arguments.forEach(k=>{if(k.type==="Identifier"){let A=k.name;if(A.startsWith("_")||r.test(A)||s.includes(A)||l.includes(A)||v.test(A))return;if(!I.test(A)){let w=d(A);e.report({fix(E){let L=n.getScope?n.getScope(k):e.getScope(),C=L.variables.find(S=>S.name===A)||L.upper&&L.upper.variables.find(S=>S.name===A);if(!C)return E.replaceText(k,w);let g=[],f=new Set;return C.references.forEach(S=>{let $=`${S.identifier.range[0]}-${S.identifier.range[1]}`;f.has($)||(f.add($),g.push(E.replaceText(S.identifier,w)))}),g},message:`Argument "${A}" should be camelCase (e.g., ${w} instead of ${A})`,node:k})}}})},FunctionDeclaration:y,FunctionExpression:y,Property:T,VariableDeclarator:u}},meta:{docs:{description:"Enforce naming conventions: camelCase for variables/properties/params/arguments, PascalCase for components, useXxx for hooks"},fixable:"code",schema:[],type:"suggestion"}};var Jn={meta:{name:"eslint-plugin-code-style",version:"2.2.1"},rules:{"array-callback-destructure":ve,"array-items-per-line":we,"array-objects-on-new-lines":Ce,"arrow-function-block-body":Ae,"arrow-function-simple-jsx":$e,"arrow-function-simplify":Le,"curried-arrow-same-line":Ie,"function-arguments-format":Pe,"nested-call-closing-brackets":Re,"no-empty-lines-in-function-calls":Fe,"opening-brackets-same-line":Be,"simple-call-single-line":He,"single-argument-on-one-line":Oe,"comment-format":Ne,"component-props-destructure":De,"component-props-inline-type":Je,"folder-based-naming-convention":ze,"folder-structure-consistency":We,"no-redundant-folder-suffix":Ve,"svg-icon-naming-convention":Xe,"react-code-order":Mt,"block-statement-newlines":Ue,"empty-line-after-block":Ye,"if-else-spacing":qe,"if-statement-format":_e,"logical-expression-multiline":Ge,"multiline-if-conditions":Ze,"no-empty-lines-in-switch-cases":Qe,"ternary-condition-multiline":Ke,"class-method-definition-format":Me,"class-naming-convention":je,"function-call-spacing":et,"function-declaration-style":tt,"function-naming-convention":nt,"function-object-destructure":it,"function-params-per-line":rt,"no-empty-lines-in-function-params":st,"hook-callback-format":at,"hook-deps-per-line":ot,"hook-file-naming-convention":ct,"hook-function-naming-convention":pt,"use-state-naming-convention":lt,"absolute-imports-only":ft,"export-format":ut,"import-format":gt,"import-source-spacing":mt,"index-export-style":yt,"index-exports-only":ht,"inline-export-declaration":xt,"module-index-exports":dt,"classname-dynamic-at-end":Ct,"classname-multiline":Lt,"classname-no-extra-spaces":At,"classname-order":$t,"jsx-children-on-new-line":Tt,"jsx-closing-bracket-spacing":bt,"jsx-element-child-new-line":kt,"jsx-logical-expression-simplify":Et,"jsx-parentheses-position":St,"jsx-prop-naming-convention":wt,"jsx-simple-element-one-line":vt,"jsx-string-value-trim":It,"jsx-ternary-format":Pt,"no-empty-lines-in-jsx":Rt,"no-empty-lines-in-objects":Ft,"object-property-per-line":Bt,"object-property-value-brace":Ht,"object-property-value-format":Ot,"string-property-spacing":jt,"assignment-value-same-line":Nt,"member-expression-bracket-spacing":Dt,"enum-format":_t,"enum-type-enforcement":Xt,"interface-format":qt,"no-inline-type-definitions":Wt,"prop-naming-convention":zt,"type-annotation-spacing":Ut,"type-format":Vt,"typescript-definition-location":Zt,"no-hardcoded-strings":Jt,"variable-naming-convention":Kt}};export{Jn as default};
